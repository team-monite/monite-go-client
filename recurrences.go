// This file was auto-generated by Fern from our API Definition.

package fluidstack

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/team-monite/monite-go-client/internal"
	time "time"
)

type CreateRecurrencePayload struct {
	DayOfMonth DayOfMonth `json:"day_of_month" url:"-"`
	EndMonth   int        `json:"end_month" url:"-"`
	EndYear    int        `json:"end_year" url:"-"`
	InvoiceId  string     `json:"invoice_id" url:"-"`
	StartMonth int        `json:"start_month" url:"-"`
	StartYear  int        `json:"start_year" url:"-"`
}

type DayOfMonth string

const (
	DayOfMonthFirstDay DayOfMonth = "first_day"
	DayOfMonthLastDay  DayOfMonth = "last_day"
)

func NewDayOfMonthFromString(s string) (DayOfMonth, error) {
	switch s {
	case "first_day":
		return DayOfMonthFirstDay, nil
	case "last_day":
		return DayOfMonthLastDay, nil
	}
	var t DayOfMonth
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DayOfMonth) Ptr() *DayOfMonth {
	return &d
}

type GetAllRecurrences struct {
	Data []*Recurrence `json:"data" url:"data"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetAllRecurrences) GetData() []*Recurrence {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GetAllRecurrences) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetAllRecurrences) UnmarshalJSON(data []byte) error {
	type unmarshaler GetAllRecurrences
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetAllRecurrences(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetAllRecurrences) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type IterationStatus string

const (
	IterationStatusPending     IterationStatus = "pending"
	IterationStatusCompleted   IterationStatus = "completed"
	IterationStatusCanceled    IterationStatus = "canceled"
	IterationStatusIssueFailed IterationStatus = "issue_failed"
	IterationStatusSendFailed  IterationStatus = "send_failed"
)

func NewIterationStatusFromString(s string) (IterationStatus, error) {
	switch s {
	case "pending":
		return IterationStatusPending, nil
	case "completed":
		return IterationStatusCompleted, nil
	case "canceled":
		return IterationStatusCanceled, nil
	case "issue_failed":
		return IterationStatusIssueFailed, nil
	case "send_failed":
		return IterationStatusSendFailed, nil
	}
	var t IterationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IterationStatus) Ptr() *IterationStatus {
	return &i
}

type Recurrence struct {
	Id string `json:"id" url:"id"`
	// Time at which the receivable was created. Timestamps follow the ISO 8601 standard.
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Time at which the receivable was last updated. Timestamps follow the ISO 8601 standard.
	UpdatedAt        time.Time              `json:"updated_at" url:"updated_at"`
	CurrentIteration int                    `json:"current_iteration" url:"current_iteration"`
	DayOfMonth       DayOfMonth             `json:"day_of_month" url:"day_of_month"`
	EndMonth         int                    `json:"end_month" url:"end_month"`
	EndYear          int                    `json:"end_year" url:"end_year"`
	InvoiceId        string                 `json:"invoice_id" url:"invoice_id"`
	Iterations       []*RecurrenceIteration `json:"iterations" url:"iterations"`
	StartMonth       int                    `json:"start_month" url:"start_month"`
	StartYear        int                    `json:"start_year" url:"start_year"`
	Status           RecurrenceStatus       `json:"status" url:"status"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *Recurrence) GetId() string {
	if r == nil {
		return ""
	}
	return r.Id
}

func (r *Recurrence) GetCreatedAt() time.Time {
	if r == nil {
		return time.Time{}
	}
	return r.CreatedAt
}

func (r *Recurrence) GetUpdatedAt() time.Time {
	if r == nil {
		return time.Time{}
	}
	return r.UpdatedAt
}

func (r *Recurrence) GetCurrentIteration() int {
	if r == nil {
		return 0
	}
	return r.CurrentIteration
}

func (r *Recurrence) GetDayOfMonth() DayOfMonth {
	if r == nil {
		return ""
	}
	return r.DayOfMonth
}

func (r *Recurrence) GetEndMonth() int {
	if r == nil {
		return 0
	}
	return r.EndMonth
}

func (r *Recurrence) GetEndYear() int {
	if r == nil {
		return 0
	}
	return r.EndYear
}

func (r *Recurrence) GetInvoiceId() string {
	if r == nil {
		return ""
	}
	return r.InvoiceId
}

func (r *Recurrence) GetIterations() []*RecurrenceIteration {
	if r == nil {
		return nil
	}
	return r.Iterations
}

func (r *Recurrence) GetStartMonth() int {
	if r == nil {
		return 0
	}
	return r.StartMonth
}

func (r *Recurrence) GetStartYear() int {
	if r == nil {
		return 0
	}
	return r.StartYear
}

func (r *Recurrence) GetStatus() RecurrenceStatus {
	if r == nil {
		return ""
	}
	return r.Status
}

func (r *Recurrence) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Recurrence) UnmarshalJSON(data []byte) error {
	type embed Recurrence
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at"`
		UpdatedAt *internal.DateTime `json:"updated_at"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = Recurrence(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.Time()
	r.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *Recurrence) MarshalJSON() ([]byte, error) {
	type embed Recurrence
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at"`
		UpdatedAt *internal.DateTime `json:"updated_at"`
	}{
		embed:     embed(*r),
		CreatedAt: internal.NewDateTime(r.CreatedAt),
		UpdatedAt: internal.NewDateTime(r.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (r *Recurrence) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RecurrenceIteration struct {
	IssueAt         string          `json:"issue_at" url:"issue_at"`
	IssuedInvoiceId *string         `json:"issued_invoice_id,omitempty" url:"issued_invoice_id,omitempty"`
	Iteration       *int            `json:"iteration,omitempty" url:"iteration,omitempty"`
	Status          IterationStatus `json:"status" url:"status"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RecurrenceIteration) GetIssueAt() string {
	if r == nil {
		return ""
	}
	return r.IssueAt
}

func (r *RecurrenceIteration) GetIssuedInvoiceId() *string {
	if r == nil {
		return nil
	}
	return r.IssuedInvoiceId
}

func (r *RecurrenceIteration) GetIteration() *int {
	if r == nil {
		return nil
	}
	return r.Iteration
}

func (r *RecurrenceIteration) GetStatus() IterationStatus {
	if r == nil {
		return ""
	}
	return r.Status
}

func (r *RecurrenceIteration) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecurrenceIteration) UnmarshalJSON(data []byte) error {
	type unmarshaler RecurrenceIteration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecurrenceIteration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecurrenceIteration) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RecurrenceStatus string

const (
	RecurrenceStatusActive    RecurrenceStatus = "active"
	RecurrenceStatusCanceled  RecurrenceStatus = "canceled"
	RecurrenceStatusCompleted RecurrenceStatus = "completed"
)

func NewRecurrenceStatusFromString(s string) (RecurrenceStatus, error) {
	switch s {
	case "active":
		return RecurrenceStatusActive, nil
	case "canceled":
		return RecurrenceStatusCanceled, nil
	case "completed":
		return RecurrenceStatusCompleted, nil
	}
	var t RecurrenceStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RecurrenceStatus) Ptr() *RecurrenceStatus {
	return &r
}

type UpdateRecurrencePayload struct {
	DayOfMonth *DayOfMonth `json:"day_of_month,omitempty" url:"-"`
	EndMonth   *int        `json:"end_month,omitempty" url:"-"`
	EndYear    *int        `json:"end_year,omitempty" url:"-"`
}
