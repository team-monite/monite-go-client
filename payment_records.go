// This file was auto-generated by Fern from our API Definition.

package fluidstack

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/team-monite/monite-go-client/internal"
	time "time"
)

type PaymentRecordRequest struct {
	Amount          int                         `json:"amount" url:"-"`
	Currency        CurrencyEnum                `json:"currency" url:"-"`
	EntityUserId    *string                     `json:"entity_user_id,omitempty" url:"-"`
	Object          *PaymentRecordObjectRequest `json:"object,omitempty" url:"-"`
	PaidAt          time.Time                   `json:"paid_at" url:"-"`
	PaymentIntentId string                      `json:"payment_intent_id" url:"-"`
}

func (p *PaymentRecordRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentRecordRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*p = PaymentRecordRequest(body)
	return nil
}

func (p *PaymentRecordRequest) MarshalJSON() ([]byte, error) {
	type embed PaymentRecordRequest
	var marshaler = struct {
		embed
		PaidAt *internal.DateTime `json:"paid_at"`
	}{
		embed:  embed(*p),
		PaidAt: internal.NewDateTime(p.PaidAt),
	}
	return json.Marshal(marshaler)
}

type PaymentRecordsGetRequest struct {
	// Order by
	Order *OrderEnum `json:"-" url:"order,omitempty"`
	// Max is 100
	Limit *int `json:"-" url:"limit,omitempty"`
	// A token, obtained from previous page. Prior over other filters
	PaginationToken *string `json:"-" url:"pagination_token,omitempty"`
	// Allowed sort fields
	Sort       *PaymentRecordCursorFields `json:"-" url:"sort,omitempty"`
	IsExternal *bool                      `json:"-" url:"is_external,omitempty"`
	ObjectId   *string                    `json:"-" url:"object_id,omitempty"`
}

type ObjectTypeEnum string

const (
	ObjectTypeEnumReceivable ObjectTypeEnum = "receivable"
	ObjectTypeEnumPayable    ObjectTypeEnum = "payable"
)

func NewObjectTypeEnumFromString(s string) (ObjectTypeEnum, error) {
	switch s {
	case "receivable":
		return ObjectTypeEnumReceivable, nil
	case "payable":
		return ObjectTypeEnumPayable, nil
	}
	var t ObjectTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o ObjectTypeEnum) Ptr() *ObjectTypeEnum {
	return &o
}

type PaymentRecordCursorFields string

const (
	PaymentRecordCursorFieldsPaidAt         PaymentRecordCursorFields = "paid_at"
	PaymentRecordCursorFieldsAmount         PaymentRecordCursorFields = "amount"
	PaymentRecordCursorFieldsOverpaidAmount PaymentRecordCursorFields = "overpaid_amount"
)

func NewPaymentRecordCursorFieldsFromString(s string) (PaymentRecordCursorFields, error) {
	switch s {
	case "paid_at":
		return PaymentRecordCursorFieldsPaidAt, nil
	case "amount":
		return PaymentRecordCursorFieldsAmount, nil
	case "overpaid_amount":
		return PaymentRecordCursorFieldsOverpaidAmount, nil
	}
	var t PaymentRecordCursorFields
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentRecordCursorFields) Ptr() *PaymentRecordCursorFields {
	return &p
}

type PaymentRecordObjectRequest struct {
	// ID of the invoice
	Id   string         `json:"id" url:"id"`
	Type ObjectTypeEnum `json:"type" url:"type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentRecordObjectRequest) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PaymentRecordObjectRequest) GetType() ObjectTypeEnum {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PaymentRecordObjectRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentRecordObjectRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentRecordObjectRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentRecordObjectRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRecordObjectRequest) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentRecordObjectResponse struct {
	// ID of the invoice
	Id string `json:"id" url:"id"`
	// Status, in which object has been moved
	NewStatus string `json:"new_status" url:"new_status"`
	// Status, in which object was before payment
	OldStatus string         `json:"old_status" url:"old_status"`
	Type      ObjectTypeEnum `json:"type" url:"type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentRecordObjectResponse) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PaymentRecordObjectResponse) GetNewStatus() string {
	if p == nil {
		return ""
	}
	return p.NewStatus
}

func (p *PaymentRecordObjectResponse) GetOldStatus() string {
	if p == nil {
		return ""
	}
	return p.OldStatus
}

func (p *PaymentRecordObjectResponse) GetType() ObjectTypeEnum {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PaymentRecordObjectResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentRecordObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentRecordObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentRecordObjectResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRecordObjectResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentRecordResponse struct {
	Id           string                       `json:"id" url:"id"`
	Amount       int                          `json:"amount" url:"amount"`
	Currency     CurrencyEnum                 `json:"currency" url:"currency"`
	EntityUserId *string                      `json:"entity_user_id,omitempty" url:"entity_user_id,omitempty"`
	IsExternal   bool                         `json:"is_external" url:"is_external"`
	Object       *PaymentRecordObjectResponse `json:"object" url:"object"`
	// Filled in a case, if payment amount is more, than total_amount
	OverpaidAmount  *int      `json:"overpaid_amount,omitempty" url:"overpaid_amount,omitempty"`
	PaidAt          time.Time `json:"paid_at" url:"paid_at"`
	PaymentIntentId string    `json:"payment_intent_id" url:"payment_intent_id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentRecordResponse) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PaymentRecordResponse) GetAmount() int {
	if p == nil {
		return 0
	}
	return p.Amount
}

func (p *PaymentRecordResponse) GetCurrency() CurrencyEnum {
	if p == nil {
		return ""
	}
	return p.Currency
}

func (p *PaymentRecordResponse) GetEntityUserId() *string {
	if p == nil {
		return nil
	}
	return p.EntityUserId
}

func (p *PaymentRecordResponse) GetIsExternal() bool {
	if p == nil {
		return false
	}
	return p.IsExternal
}

func (p *PaymentRecordResponse) GetObject() *PaymentRecordObjectResponse {
	if p == nil {
		return nil
	}
	return p.Object
}

func (p *PaymentRecordResponse) GetOverpaidAmount() *int {
	if p == nil {
		return nil
	}
	return p.OverpaidAmount
}

func (p *PaymentRecordResponse) GetPaidAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.PaidAt
}

func (p *PaymentRecordResponse) GetPaymentIntentId() string {
	if p == nil {
		return ""
	}
	return p.PaymentIntentId
}

func (p *PaymentRecordResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentRecordResponse) UnmarshalJSON(data []byte) error {
	type embed PaymentRecordResponse
	var unmarshaler = struct {
		embed
		PaidAt *internal.DateTime `json:"paid_at"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentRecordResponse(unmarshaler.embed)
	p.PaidAt = unmarshaler.PaidAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRecordResponse) MarshalJSON() ([]byte, error) {
	type embed PaymentRecordResponse
	var marshaler = struct {
		embed
		PaidAt *internal.DateTime `json:"paid_at"`
	}{
		embed:  embed(*p),
		PaidAt: internal.NewDateTime(p.PaidAt),
	}
	return json.Marshal(marshaler)
}

func (p *PaymentRecordResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentRecordResponseList struct {
	Data []*PaymentRecordResponse `json:"data" url:"data"`
	// A token that can be sent in the `pagination_token` query parameter to get the next page of results, or `null` if there is no next page (i.e. you've reached the last page).
	NextPaginationToken *string `json:"next_pagination_token,omitempty" url:"next_pagination_token,omitempty"`
	// A token that can be sent in the `pagination_token` query parameter to get the previous page of results, or `null` if there is no previous page (i.e. you've reached the first page).
	PrevPaginationToken *string `json:"prev_pagination_token,omitempty" url:"prev_pagination_token,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentRecordResponseList) GetData() []*PaymentRecordResponse {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaymentRecordResponseList) GetNextPaginationToken() *string {
	if p == nil {
		return nil
	}
	return p.NextPaginationToken
}

func (p *PaymentRecordResponseList) GetPrevPaginationToken() *string {
	if p == nil {
		return nil
	}
	return p.PrevPaginationToken
}

func (p *PaymentRecordResponseList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentRecordResponseList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentRecordResponseList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentRecordResponseList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRecordResponseList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
