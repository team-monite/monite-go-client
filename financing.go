// This file was auto-generated by Fern from our API Definition.

package fluidstack

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/team-monite/monite-go-client/internal"
	time "time"
)

type GetFinancingInvoicesRequest struct {
	// Order by
	Order *OrderEnum `json:"-" url:"order,omitempty"`
	// Max is 100
	Limit *int `json:"-" url:"limit,omitempty"`
	// A token, obtained from previous page. Prior over other filters
	PaginationToken *string `json:"-" url:"pagination_token,omitempty"`
	// Allowed sort fields
	Sort *FinancingInvoiceCursorFields `json:"-" url:"sort,omitempty"`
	// ID of a payable or receivable invoice.
	InvoiceId *string `json:"-" url:"invoice_id,omitempty"`
	// List of invoice IDs.
	InvoiceIdIn []*string `json:"-" url:"invoice_id__in,omitempty"`
	// Status of the invoice.
	Status *WcInvoiceStatus `json:"-" url:"status,omitempty"`
	// List of invoice statuses.
	StatusIn []*WcInvoiceStatus `json:"-" url:"status__in,omitempty"`
	// Type of the invoice. payable or receivable.
	Type *FinancingInvoiceType `json:"-" url:"type,omitempty"`
	// List of invoice types.
	TypeIn []*FinancingInvoiceType `json:"-" url:"type__in,omitempty"`
	// Document ID of the invoice.
	DocumentId *string `json:"-" url:"document_id,omitempty"`
	// List of document IDs.
	DocumentIdIn []*string `json:"-" url:"document_id__in,omitempty"`
	// Issue date greater than.
	IssueDateGt *time.Time `json:"-" url:"issue_date__gt,omitempty"`
	// Issue date less than.
	IssueDateLt *time.Time `json:"-" url:"issue_date__lt,omitempty"`
	// Issue date greater than or equal.
	IssueDateGte *time.Time `json:"-" url:"issue_date__gte,omitempty"`
	// Issue date less than or equal.
	IssueDateLte *time.Time `json:"-" url:"issue_date__lte,omitempty"`
	// Due date greater than.
	DueDateGt *time.Time `json:"-" url:"due_date__gt,omitempty"`
	// Due date less than.
	DueDateLt *time.Time `json:"-" url:"due_date__lt,omitempty"`
	// Due date greater than or equal.
	DueDateGte *time.Time `json:"-" url:"due_date__gte,omitempty"`
	// Due date less than or equal.
	DueDateLte *time.Time `json:"-" url:"due_date__lte,omitempty"`
	// Created date greater than.
	CreatedAtGt *time.Time `json:"-" url:"created_at__gt,omitempty"`
	// Created date less than.
	CreatedAtLt *time.Time `json:"-" url:"created_at__lt,omitempty"`
	// Created date greater than or equal.
	CreatedAtGte *time.Time `json:"-" url:"created_at__gte,omitempty"`
	// Created date less than or equal.
	CreatedAtLte *time.Time `json:"-" url:"created_at__lte,omitempty"`
	// Total amount of the invoice in minor units.
	TotalAmount *int `json:"-" url:"total_amount,omitempty"`
	// Total amount greater than.
	TotalAmountGt *int `json:"-" url:"total_amount__gt,omitempty"`
	// Total amount less than.
	TotalAmountLt *int `json:"-" url:"total_amount__lt,omitempty"`
	// Total amount greater than or equal.
	TotalAmountGte *int `json:"-" url:"total_amount__gte,omitempty"`
	// Total amount less than or equal.
	TotalAmountLte *int `json:"-" url:"total_amount__lte,omitempty"`
}

type FinancingPushInvoicesRequest struct {
	// A list of invoices to request financing for.
	Invoices []*FinancingPushInvoicesRequestInvoice `json:"invoices,omitempty" url:"-"`
}

type FinancingInvoice struct {
	// The type of the invoice i.e. receivable or payable.
	Type FinancingInvoiceType `json:"type" url:"type"`
	// Status of the invoice.
	Status WcInvoiceStatus `json:"status" url:"status"`
	// Monite invoice ID.
	InvoiceId string `json:"invoice_id" url:"invoice_id"`
	// Monite document ID.
	DocumentId string `json:"document_id" url:"document_id"`
	// Monite invoice due date.
	DueDate string `json:"due_date" url:"due_date"`
	// Monite invoice issue date.
	IssueDate string `json:"issue_date" url:"issue_date"`
	// Total amount of the invoice in minor units.
	TotalAmount int `json:"total_amount" url:"total_amount"`
	// Currency code.
	Currency CurrencyEnum `json:"currency" url:"currency"`
	// Description of the invoice.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Payer type. BUSINESS or INDIVIDUAL
	PayerType string `json:"payer_type" url:"payer_type"`
	// Payer business name. Only applicable for BUSINESS payer type.
	PayerBusinessName *string `json:"payer_business_name,omitempty" url:"payer_business_name,omitempty"`
	// Payer first name. Only applicable for INDIVIDUAL payer type.
	PayerFirstName *string `json:"payer_first_name,omitempty" url:"payer_first_name,omitempty"`
	// Payer last name. Only applicable for INDIVIDUAL payer type.
	PayerLastName *string `json:"payer_last_name,omitempty" url:"payer_last_name,omitempty"`
	// Repayment schedule of the invoice.
	RepaymentSchedule *RepaymentSchedule `json:"repayment_schedule,omitempty" url:"repayment_schedule,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FinancingInvoice) GetType() FinancingInvoiceType {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FinancingInvoice) GetStatus() WcInvoiceStatus {
	if f == nil {
		return ""
	}
	return f.Status
}

func (f *FinancingInvoice) GetInvoiceId() string {
	if f == nil {
		return ""
	}
	return f.InvoiceId
}

func (f *FinancingInvoice) GetDocumentId() string {
	if f == nil {
		return ""
	}
	return f.DocumentId
}

func (f *FinancingInvoice) GetDueDate() string {
	if f == nil {
		return ""
	}
	return f.DueDate
}

func (f *FinancingInvoice) GetIssueDate() string {
	if f == nil {
		return ""
	}
	return f.IssueDate
}

func (f *FinancingInvoice) GetTotalAmount() int {
	if f == nil {
		return 0
	}
	return f.TotalAmount
}

func (f *FinancingInvoice) GetCurrency() CurrencyEnum {
	if f == nil {
		return ""
	}
	return f.Currency
}

func (f *FinancingInvoice) GetDescription() *string {
	if f == nil {
		return nil
	}
	return f.Description
}

func (f *FinancingInvoice) GetPayerType() string {
	if f == nil {
		return ""
	}
	return f.PayerType
}

func (f *FinancingInvoice) GetPayerBusinessName() *string {
	if f == nil {
		return nil
	}
	return f.PayerBusinessName
}

func (f *FinancingInvoice) GetPayerFirstName() *string {
	if f == nil {
		return nil
	}
	return f.PayerFirstName
}

func (f *FinancingInvoice) GetPayerLastName() *string {
	if f == nil {
		return nil
	}
	return f.PayerLastName
}

func (f *FinancingInvoice) GetRepaymentSchedule() *RepaymentSchedule {
	if f == nil {
		return nil
	}
	return f.RepaymentSchedule
}

func (f *FinancingInvoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FinancingInvoice) UnmarshalJSON(data []byte) error {
	type unmarshaler FinancingInvoice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FinancingInvoice(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FinancingInvoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FinancingInvoiceCursorFields string

const (
	FinancingInvoiceCursorFieldsId        FinancingInvoiceCursorFields = "id"
	FinancingInvoiceCursorFieldsCreatedAt FinancingInvoiceCursorFields = "created_at"
)

func NewFinancingInvoiceCursorFieldsFromString(s string) (FinancingInvoiceCursorFields, error) {
	switch s {
	case "id":
		return FinancingInvoiceCursorFieldsId, nil
	case "created_at":
		return FinancingInvoiceCursorFieldsCreatedAt, nil
	}
	var t FinancingInvoiceCursorFields
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FinancingInvoiceCursorFields) Ptr() *FinancingInvoiceCursorFields {
	return &f
}

type FinancingInvoiceListResponse struct {
	// A list of invoices requested for financing.
	Data []*FinancingInvoice `json:"data" url:"data"`
	// A token that can be sent in the `pagination_token` query parameter to get the previous page of results, or `null` if there is no previous page (i.e. you've reached the first page).
	PrevPaginationToken *string `json:"prev_pagination_token,omitempty" url:"prev_pagination_token,omitempty"`
	// A token that can be sent in the `pagination_token` query parameter to get the next page of results, or `null` if there is no next page (i.e. you've reached the last page).
	NextPaginationToken *string `json:"next_pagination_token,omitempty" url:"next_pagination_token,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FinancingInvoiceListResponse) GetData() []*FinancingInvoice {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FinancingInvoiceListResponse) GetPrevPaginationToken() *string {
	if f == nil {
		return nil
	}
	return f.PrevPaginationToken
}

func (f *FinancingInvoiceListResponse) GetNextPaginationToken() *string {
	if f == nil {
		return nil
	}
	return f.NextPaginationToken
}

func (f *FinancingInvoiceListResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FinancingInvoiceListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FinancingInvoiceListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FinancingInvoiceListResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FinancingInvoiceListResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FinancingInvoiceType string

const (
	FinancingInvoiceTypePayable    FinancingInvoiceType = "payable"
	FinancingInvoiceTypeReceivable FinancingInvoiceType = "receivable"
)

func NewFinancingInvoiceTypeFromString(s string) (FinancingInvoiceType, error) {
	switch s {
	case "payable":
		return FinancingInvoiceTypePayable, nil
	case "receivable":
		return FinancingInvoiceTypeReceivable, nil
	}
	var t FinancingInvoiceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FinancingInvoiceType) Ptr() *FinancingInvoiceType {
	return &f
}

type FinancingOffer struct {
	// The status of the financing offer.
	Status WcOfferStatus `json:"status" url:"status"`
	// The total credit limit in minor units.
	TotalAmount int `json:"total_amount" url:"total_amount"`
	// The available credit limit in minor units.
	AvailableAmount *int `json:"available_amount,omitempty" url:"available_amount,omitempty"`
	// The currency code.
	Currency CurrencyEnum `json:"currency" url:"currency"`
	// A list of pricing plans for the offer.
	PricingPlans []*PricingPlan `json:"pricing_plans" url:"pricing_plans"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FinancingOffer) GetStatus() WcOfferStatus {
	if f == nil {
		return ""
	}
	return f.Status
}

func (f *FinancingOffer) GetTotalAmount() int {
	if f == nil {
		return 0
	}
	return f.TotalAmount
}

func (f *FinancingOffer) GetAvailableAmount() *int {
	if f == nil {
		return nil
	}
	return f.AvailableAmount
}

func (f *FinancingOffer) GetCurrency() CurrencyEnum {
	if f == nil {
		return ""
	}
	return f.Currency
}

func (f *FinancingOffer) GetPricingPlans() []*PricingPlan {
	if f == nil {
		return nil
	}
	return f.PricingPlans
}

func (f *FinancingOffer) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FinancingOffer) UnmarshalJSON(data []byte) error {
	type unmarshaler FinancingOffer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FinancingOffer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FinancingOffer) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FinancingOffersResponse struct {
	// A list of financing offers extended to the business.
	Offers []*FinancingOffer `json:"offers" url:"offers"`
	// The business's onboarding status.
	BusinessStatus WcBusinessStatus `json:"business_status" url:"business_status"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FinancingOffersResponse) GetOffers() []*FinancingOffer {
	if f == nil {
		return nil
	}
	return f.Offers
}

func (f *FinancingOffersResponse) GetBusinessStatus() WcBusinessStatus {
	if f == nil {
		return ""
	}
	return f.BusinessStatus
}

func (f *FinancingOffersResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FinancingOffersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FinancingOffersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FinancingOffersResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FinancingOffersResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FinancingPushInvoicesRequestInvoice struct {
	// The invoice ID.
	Id string `json:"id" url:"id"`
	// The invoice type.
	Type FinancingInvoiceType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FinancingPushInvoicesRequestInvoice) GetId() string {
	if f == nil {
		return ""
	}
	return f.Id
}

func (f *FinancingPushInvoicesRequestInvoice) GetType() FinancingInvoiceType {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FinancingPushInvoicesRequestInvoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FinancingPushInvoicesRequestInvoice) UnmarshalJSON(data []byte) error {
	type unmarshaler FinancingPushInvoicesRequestInvoice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FinancingPushInvoicesRequestInvoice(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FinancingPushInvoicesRequestInvoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FinancingPushInvoicesResponse struct {
	// A connect token for Kanmon SDK.
	ConnectToken string `json:"connect_token" url:"connect_token"`
	// An embedded session token for Kanmon SDK.
	SessionToken string `json:"session_token" url:"session_token"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FinancingPushInvoicesResponse) GetConnectToken() string {
	if f == nil {
		return ""
	}
	return f.ConnectToken
}

func (f *FinancingPushInvoicesResponse) GetSessionToken() string {
	if f == nil {
		return ""
	}
	return f.SessionToken
}

func (f *FinancingPushInvoicesResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FinancingPushInvoicesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FinancingPushInvoicesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FinancingPushInvoicesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FinancingPushInvoicesResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FinancingTokenResponse struct {
	// A connect token for Kanmon SDK.
	ConnectToken string `json:"connect_token" url:"connect_token"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FinancingTokenResponse) GetConnectToken() string {
	if f == nil {
		return ""
	}
	return f.ConnectToken
}

func (f *FinancingTokenResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FinancingTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FinancingTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FinancingTokenResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FinancingTokenResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// A pricing plan of a financing offer
type PricingPlan struct {
	// Advance rate percentage. 10000 means 100%
	AdvanceRatePercentage int `json:"advance_rate_percentage" url:"advance_rate_percentage"`
	// Transaction fee percentage. 300 means 3.00%
	FeePercentage int `json:"fee_percentage" url:"fee_percentage"`
	// Repayment type of the loan.
	RepaymentType WcRepaymentType `json:"repayment_type" url:"repayment_type"`
	// This amount of days after which the repayment duration is due. This is only applicable for FIXED_DURATION repayment type
	RepaymentDurationDays *int `json:"repayment_duration_days,omitempty" url:"repayment_duration_days,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PricingPlan) GetAdvanceRatePercentage() int {
	if p == nil {
		return 0
	}
	return p.AdvanceRatePercentage
}

func (p *PricingPlan) GetFeePercentage() int {
	if p == nil {
		return 0
	}
	return p.FeePercentage
}

func (p *PricingPlan) GetRepaymentType() WcRepaymentType {
	if p == nil {
		return ""
	}
	return p.RepaymentType
}

func (p *PricingPlan) GetRepaymentDurationDays() *int {
	if p == nil {
		return nil
	}
	return p.RepaymentDurationDays
}

func (p *PricingPlan) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PricingPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler PricingPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PricingPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PricingPlan) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Repayment schedule model
type RepaymentSchedule struct {
	// Repayment date in ISO 8601 format
	RepaymentDate string `json:"repayment_date" url:"repayment_date"`
	// Repayment amount in minor units
	RepaymentAmount int `json:"repayment_amount" url:"repayment_amount"`
	// Repayment fee amount in minor units
	RepaymentFeeAmount int `json:"repayment_fee_amount" url:"repayment_fee_amount"`
	// Repayment principal amount in minor units
	RepaymentPrincipalAmount int `json:"repayment_principal_amount" url:"repayment_principal_amount"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RepaymentSchedule) GetRepaymentDate() string {
	if r == nil {
		return ""
	}
	return r.RepaymentDate
}

func (r *RepaymentSchedule) GetRepaymentAmount() int {
	if r == nil {
		return 0
	}
	return r.RepaymentAmount
}

func (r *RepaymentSchedule) GetRepaymentFeeAmount() int {
	if r == nil {
		return 0
	}
	return r.RepaymentFeeAmount
}

func (r *RepaymentSchedule) GetRepaymentPrincipalAmount() int {
	if r == nil {
		return 0
	}
	return r.RepaymentPrincipalAmount
}

func (r *RepaymentSchedule) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RepaymentSchedule) UnmarshalJSON(data []byte) error {
	type unmarshaler RepaymentSchedule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RepaymentSchedule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RepaymentSchedule) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// - NEW: A business has been created within Kanmon
// - ONBOARDED: A business has completed all of the onboarding steps within Kanmon and is now awaiting underwriting.
// - INPUT_REQUIRED: A business will be asked to provide required data
type WcBusinessStatus string

const (
	WcBusinessStatusNew           WcBusinessStatus = "NEW"
	WcBusinessStatusInputRequired WcBusinessStatus = "INPUT_REQUIRED"
	WcBusinessStatusOnboarded     WcBusinessStatus = "ONBOARDED"
)

func NewWcBusinessStatusFromString(s string) (WcBusinessStatus, error) {
	switch s {
	case "NEW":
		return WcBusinessStatusNew, nil
	case "INPUT_REQUIRED":
		return WcBusinessStatusInputRequired, nil
	case "ONBOARDED":
		return WcBusinessStatusOnboarded, nil
	}
	var t WcBusinessStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WcBusinessStatus) Ptr() *WcBusinessStatus {
	return &w
}

// - NEW: The business has submitted an invoice and it is under review.
// - FUNDED: The funds for the invoice have been disbursed. The business is now expected to pay back the funds.
// - PAID: A payment was made that fully paid off an outstanding invoice.
// - LATE: A payment was not made towards an outstanding invoice.
// - REJECTED: An invoice was rejected during the funding step.
// - DEFAULTED: A payment was not made towards an outstanding invoice.
type WcInvoiceStatus string

const (
	WcInvoiceStatusNew       WcInvoiceStatus = "NEW"
	WcInvoiceStatusFunded    WcInvoiceStatus = "FUNDED"
	WcInvoiceStatusPaid      WcInvoiceStatus = "PAID"
	WcInvoiceStatusLate      WcInvoiceStatus = "LATE"
	WcInvoiceStatusRejected  WcInvoiceStatus = "REJECTED"
	WcInvoiceStatusDefaulted WcInvoiceStatus = "DEFAULTED"
)

func NewWcInvoiceStatusFromString(s string) (WcInvoiceStatus, error) {
	switch s {
	case "NEW":
		return WcInvoiceStatusNew, nil
	case "FUNDED":
		return WcInvoiceStatusFunded, nil
	case "PAID":
		return WcInvoiceStatusPaid, nil
	case "LATE":
		return WcInvoiceStatusLate, nil
	case "REJECTED":
		return WcInvoiceStatusRejected, nil
	case "DEFAULTED":
		return WcInvoiceStatusDefaulted, nil
	}
	var t WcInvoiceStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WcInvoiceStatus) Ptr() *WcInvoiceStatus {
	return &w
}

// - NEW: A new offer has been extended to the business.
// - ACCEPTED: Business has accepted an offer and is waiting on the closing process.
// - EXPIRED: Business has not accepted the offer, and the offer has expired.
// - CURRENT: A loan has been originated and does not currently have any outstanding delayed payments.
// - LATE: One or more repayments on the issued product have failed.
// - CLOSED: The issued product is no longer available to the business.
// - DEFAULTED: The business has failed to meet agreed-upon terms of the loan agreement.
type WcOfferStatus string

const (
	WcOfferStatusNew       WcOfferStatus = "NEW"
	WcOfferStatusAccepted  WcOfferStatus = "ACCEPTED"
	WcOfferStatusExpired   WcOfferStatus = "EXPIRED"
	WcOfferStatusCurrent   WcOfferStatus = "CURRENT"
	WcOfferStatusLate      WcOfferStatus = "LATE"
	WcOfferStatusClosed    WcOfferStatus = "CLOSED"
	WcOfferStatusDefaulted WcOfferStatus = "DEFAULTED"
)

func NewWcOfferStatusFromString(s string) (WcOfferStatus, error) {
	switch s {
	case "NEW":
		return WcOfferStatusNew, nil
	case "ACCEPTED":
		return WcOfferStatusAccepted, nil
	case "EXPIRED":
		return WcOfferStatusExpired, nil
	case "CURRENT":
		return WcOfferStatusCurrent, nil
	case "LATE":
		return WcOfferStatusLate, nil
	case "CLOSED":
		return WcOfferStatusClosed, nil
	case "DEFAULTED":
		return WcOfferStatusDefaulted, nil
	}
	var t WcOfferStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WcOfferStatus) Ptr() *WcOfferStatus {
	return &w
}

// - MULTIPLE_DURATION: The business can repay the loan over multiple durations.
// - FIXED_DURATION: The business must repay the loan over a fixed duration.
// - FIXED_DATE: The business must repay the loan on a fixed date.
type WcRepaymentType string

const (
	WcRepaymentTypeMultipleDuration WcRepaymentType = "MULTIPLE_DURATION"
	WcRepaymentTypeFixedDuration    WcRepaymentType = "FIXED_DURATION"
	WcRepaymentTypeFixedDate        WcRepaymentType = "FIXED_DATE"
)

func NewWcRepaymentTypeFromString(s string) (WcRepaymentType, error) {
	switch s {
	case "MULTIPLE_DURATION":
		return WcRepaymentTypeMultipleDuration, nil
	case "FIXED_DURATION":
		return WcRepaymentTypeFixedDuration, nil
	case "FIXED_DATE":
		return WcRepaymentTypeFixedDate, nil
	}
	var t WcRepaymentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WcRepaymentType) Ptr() *WcRepaymentType {
	return &w
}
