// This file was auto-generated by Fern from our API Definition.

package fluidstack

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/team-monite/monite-go-client/internal"
	io "io"
	time "time"
)

type CreateEntityRequest struct {
	// An address description of the entity
	Address *EntityAddressSchema `json:"address,omitempty" url:"-"`
	// An official email address of the entity
	Email string `json:"email" url:"-"`
	// A set of meta data describing the individual
	Individual *IndividualSchema `json:"individual,omitempty" url:"-"`
	// A set of meta data describing the organization
	Organization *OrganizationSchema `json:"organization,omitempty" url:"-"`
	// A phone number of the entity
	Phone *string `json:"phone,omitempty" url:"-"`
	// The entity's taxpayer identification number or tax ID. This field is required for entities that are non-VAT registered.
	TaxId *string `json:"tax_id,omitempty" url:"-"`
	// A type for an entity
	Type EntityTypeEnum `json:"type" url:"-"`
	// A website of the entity
	Website *string `json:"website,omitempty" url:"-"`
}

type EntitiesGetRequest struct {
	// Order by
	Order *OrderEnum `json:"-" url:"order,omitempty"`
	// Max is 100
	Limit *int `json:"-" url:"limit,omitempty"`
	// A token, obtained from previous page. Prior over other filters
	PaginationToken *string `json:"-" url:"pagination_token,omitempty"`
	// Allowed sort fields
	Sort         *EntityCursorFields `json:"-" url:"sort,omitempty"`
	Type         *EntityTypeEnum     `json:"-" url:"type,omitempty"`
	CreatedAtGt  *time.Time          `json:"-" url:"created_at__gt,omitempty"`
	CreatedAtLt  *time.Time          `json:"-" url:"created_at__lt,omitempty"`
	CreatedAtGte *time.Time          `json:"-" url:"created_at__gte,omitempty"`
	CreatedAtLte *time.Time          `json:"-" url:"created_at__lte,omitempty"`
	IdIn         []*string           `json:"-" url:"id__in,omitempty"`
	IdNotIn      []*string           `json:"-" url:"id__not_in,omitempty"`
	Email        *string             `json:"-" url:"email,omitempty"`
	EmailIn      []*string           `json:"-" url:"email__in,omitempty"`
	EmailNotIn   []*string           `json:"-" url:"email__not_in,omitempty"`
}

type DocumentIDsSettings struct {
	// Optionally add 4-digit of the current year
	IncludeDate *bool `json:"include_date,omitempty" url:"include_date,omitempty"`
	// Optional prefix. Does not substitute document_type prefix
	Prefix *string `json:"prefix,omitempty" url:"prefix,omitempty"`
	// Which character should separate each part of the document_id
	Separator *DocumentIdSeparators `json:"separator,omitempty" url:"separator,omitempty"`
	// Prefixes for each document_type
	DocumentTypePrefix *DocumentTypePrefix `json:"document_type_prefix,omitempty" url:"document_type_prefix,omitempty"`
	// Minimal size of number in document ID Number will be left padded with zeros if less
	MinDigits *int `json:"min_digits,omitempty" url:"min_digits,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DocumentIDsSettings) GetIncludeDate() *bool {
	if d == nil {
		return nil
	}
	return d.IncludeDate
}

func (d *DocumentIDsSettings) GetPrefix() *string {
	if d == nil {
		return nil
	}
	return d.Prefix
}

func (d *DocumentIDsSettings) GetSeparator() *DocumentIdSeparators {
	if d == nil {
		return nil
	}
	return d.Separator
}

func (d *DocumentIDsSettings) GetDocumentTypePrefix() *DocumentTypePrefix {
	if d == nil {
		return nil
	}
	return d.DocumentTypePrefix
}

func (d *DocumentIDsSettings) GetMinDigits() *int {
	if d == nil {
		return nil
	}
	return d.MinDigits
}

func (d *DocumentIDsSettings) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentIDsSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentIDsSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentIDsSettings(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentIDsSettings) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DocumentIDsSettingsNextNumber struct {
	Quote         *int `json:"quote,omitempty" url:"quote,omitempty"`
	Invoice       *int `json:"invoice,omitempty" url:"invoice,omitempty"`
	CreditNote    *int `json:"credit_note,omitempty" url:"credit_note,omitempty"`
	PurchaseOrder *int `json:"purchase_order,omitempty" url:"purchase_order,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DocumentIDsSettingsNextNumber) GetQuote() *int {
	if d == nil {
		return nil
	}
	return d.Quote
}

func (d *DocumentIDsSettingsNextNumber) GetInvoice() *int {
	if d == nil {
		return nil
	}
	return d.Invoice
}

func (d *DocumentIDsSettingsNextNumber) GetCreditNote() *int {
	if d == nil {
		return nil
	}
	return d.CreditNote
}

func (d *DocumentIDsSettingsNextNumber) GetPurchaseOrder() *int {
	if d == nil {
		return nil
	}
	return d.PurchaseOrder
}

func (d *DocumentIDsSettingsNextNumber) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentIDsSettingsNextNumber) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentIDsSettingsNextNumber
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentIDsSettingsNextNumber(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentIDsSettingsNextNumber) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DocumentIDsSettingsRequest struct {
	// Optionally add 4-digit of the current year
	IncludeDate *bool `json:"include_date,omitempty" url:"include_date,omitempty"`
	// Optional prefix. Does not substitute document_type prefix
	Prefix *string `json:"prefix,omitempty" url:"prefix,omitempty"`
	// Which character should separate each part of the document_id
	Separator *DocumentIdSeparators `json:"separator,omitempty" url:"separator,omitempty"`
	// Prefixes for each document_type
	DocumentTypePrefix *DocumentTypePrefix `json:"document_type_prefix,omitempty" url:"document_type_prefix,omitempty"`
	// Minimal size of number in document ID Number will be left padded with zeros if less
	MinDigits *int `json:"min_digits,omitempty" url:"min_digits,omitempty"`
	// Write-only field. Changes which number will be issued next. Can't be less than the last issued document number
	NextNumber *DocumentIDsSettingsNextNumber `json:"next_number,omitempty" url:"next_number,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DocumentIDsSettingsRequest) GetIncludeDate() *bool {
	if d == nil {
		return nil
	}
	return d.IncludeDate
}

func (d *DocumentIDsSettingsRequest) GetPrefix() *string {
	if d == nil {
		return nil
	}
	return d.Prefix
}

func (d *DocumentIDsSettingsRequest) GetSeparator() *DocumentIdSeparators {
	if d == nil {
		return nil
	}
	return d.Separator
}

func (d *DocumentIDsSettingsRequest) GetDocumentTypePrefix() *DocumentTypePrefix {
	if d == nil {
		return nil
	}
	return d.DocumentTypePrefix
}

func (d *DocumentIDsSettingsRequest) GetMinDigits() *int {
	if d == nil {
		return nil
	}
	return d.MinDigits
}

func (d *DocumentIDsSettingsRequest) GetNextNumber() *DocumentIDsSettingsNextNumber {
	if d == nil {
		return nil
	}
	return d.NextNumber
}

func (d *DocumentIDsSettingsRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentIDsSettingsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentIDsSettingsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentIDsSettingsRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentIDsSettingsRequest) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DocumentIdSeparators string

const (
	DocumentIdSeparatorsSlash  DocumentIdSeparators = "/"
	DocumentIdSeparatorsHyphen DocumentIdSeparators = "-"
	DocumentIdSeparatorsPipe   DocumentIdSeparators = "|"
	DocumentIdSeparatorsDot    DocumentIdSeparators = "."
	DocumentIdSeparatorsEmpty  DocumentIdSeparators = ""
)

func NewDocumentIdSeparatorsFromString(s string) (DocumentIdSeparators, error) {
	switch s {
	case "/":
		return DocumentIdSeparatorsSlash, nil
	case "-":
		return DocumentIdSeparatorsHyphen, nil
	case "|":
		return DocumentIdSeparatorsPipe, nil
	case ".":
		return DocumentIdSeparatorsDot, nil
	case "":
		return DocumentIdSeparatorsEmpty, nil
	}
	var t DocumentIdSeparators
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DocumentIdSeparators) Ptr() *DocumentIdSeparators {
	return &d
}

type DocumentTypePrefix struct {
	Quote         *string `json:"quote,omitempty" url:"quote,omitempty"`
	Invoice       *string `json:"invoice,omitempty" url:"invoice,omitempty"`
	CreditNote    *string `json:"credit_note,omitempty" url:"credit_note,omitempty"`
	PurchaseOrder *string `json:"purchase_order,omitempty" url:"purchase_order,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DocumentTypePrefix) GetQuote() *string {
	if d == nil {
		return nil
	}
	return d.Quote
}

func (d *DocumentTypePrefix) GetInvoice() *string {
	if d == nil {
		return nil
	}
	return d.Invoice
}

func (d *DocumentTypePrefix) GetCreditNote() *string {
	if d == nil {
		return nil
	}
	return d.CreditNote
}

func (d *DocumentTypePrefix) GetPurchaseOrder() *string {
	if d == nil {
		return nil
	}
	return d.PurchaseOrder
}

func (d *DocumentTypePrefix) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentTypePrefix) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentTypePrefix
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentTypePrefix(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentTypePrefix) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// A schema represents address info of the entity
type EntityAddressSchema struct {
	// A city (a full name) where the entity is registered
	City string `json:"city" url:"city"`
	// A country name (as ISO code) where the entity is registered
	Country AllowedCountries `json:"country" url:"country"`
	// A street where the entity is registered
	Line1 string `json:"line1" url:"line1"`
	// An alternative street used by the entity
	Line2 *string `json:"line2,omitempty" url:"line2,omitempty"`
	// A postal code of the address where the entity is registered
	PostalCode string `json:"postal_code" url:"postal_code"`
	// State, county, province, prefecture, region, or similar component of the entity's address. For US entities, `state` is required and must be a two-letter [USPS state abbreviation](https://pe.usps.com/text/pub28/28apb.htm), for example, NY or CA.
	State *string `json:"state,omitempty" url:"state,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityAddressSchema) GetCity() string {
	if e == nil {
		return ""
	}
	return e.City
}

func (e *EntityAddressSchema) GetCountry() AllowedCountries {
	if e == nil {
		return ""
	}
	return e.Country
}

func (e *EntityAddressSchema) GetLine1() string {
	if e == nil {
		return ""
	}
	return e.Line1
}

func (e *EntityAddressSchema) GetLine2() *string {
	if e == nil {
		return nil
	}
	return e.Line2
}

func (e *EntityAddressSchema) GetPostalCode() string {
	if e == nil {
		return ""
	}
	return e.PostalCode
}

func (e *EntityAddressSchema) GetState() *string {
	if e == nil {
		return nil
	}
	return e.State
}

func (e *EntityAddressSchema) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityAddressSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityAddressSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityAddressSchema(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityAddressSchema) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityCursorFields string

const (
	EntityCursorFieldsCreatedAt EntityCursorFields = "created_at"
	EntityCursorFieldsUpdatedAt EntityCursorFields = "updated_at"
)

func NewEntityCursorFieldsFromString(s string) (EntityCursorFields, error) {
	switch s {
	case "created_at":
		return EntityCursorFieldsCreatedAt, nil
	case "updated_at":
		return EntityCursorFieldsUpdatedAt, nil
	}
	var t EntityCursorFields
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EntityCursorFields) Ptr() *EntityCursorFields {
	return &e
}

type EntityPaginationResponse struct {
	// A set of entities of different types returned per page
	Data []*EntityResponse `json:"data" url:"data"`
	// A token that can be sent in the `pagination_token` query parameter to get the next page of results, or `null` if there is no next page (i.e. you've reached the last page).
	NextPaginationToken *string `json:"next_pagination_token,omitempty" url:"next_pagination_token,omitempty"`
	// A token that can be sent in the `pagination_token` query parameter to get the previous page of results, or `null` if there is no previous page (i.e. you've reached the first page).
	PrevPaginationToken *string `json:"prev_pagination_token,omitempty" url:"prev_pagination_token,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityPaginationResponse) GetData() []*EntityResponse {
	if e == nil {
		return nil
	}
	return e.Data
}

func (e *EntityPaginationResponse) GetNextPaginationToken() *string {
	if e == nil {
		return nil
	}
	return e.NextPaginationToken
}

func (e *EntityPaginationResponse) GetPrevPaginationToken() *string {
	if e == nil {
		return nil
	}
	return e.PrevPaginationToken
}

func (e *EntityPaginationResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityPaginationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityPaginationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityPaginationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityPaginationResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityTypeEnum string

const (
	EntityTypeEnumIndividual   EntityTypeEnum = "individual"
	EntityTypeEnumOrganization EntityTypeEnum = "organization"
)

func NewEntityTypeEnumFromString(s string) (EntityTypeEnum, error) {
	switch s {
	case "individual":
		return EntityTypeEnumIndividual, nil
	case "organization":
		return EntityTypeEnumOrganization, nil
	}
	var t EntityTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EntityTypeEnum) Ptr() *EntityTypeEnum {
	return &e
}

type GetOnboardingRequirementsResponse struct {
	Data []*SingleOnboardingRequirementsResponse `json:"data" url:"data"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetOnboardingRequirementsResponse) GetData() []*SingleOnboardingRequirementsResponse {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GetOnboardingRequirementsResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetOnboardingRequirementsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetOnboardingRequirementsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetOnboardingRequirementsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetOnboardingRequirementsResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A schema contains metadata for an individual
type IndividualSchema struct {
	DateOfBirth *string `json:"date_of_birth,omitempty" url:"date_of_birth,omitempty"`
	// A first name of an individual
	FirstName string  `json:"first_name" url:"first_name"`
	IdNumber  *string `json:"id_number,omitempty" url:"id_number,omitempty"`
	// A last name of an individual
	LastName string `json:"last_name" url:"last_name"`
	// The last four digits of the individual's Social Security number
	SsnLast4 *string `json:"ssn_last_4,omitempty" url:"ssn_last_4,omitempty"`
	// A title of an individual
	Title *string `json:"title,omitempty" url:"title,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IndividualSchema) GetDateOfBirth() *string {
	if i == nil {
		return nil
	}
	return i.DateOfBirth
}

func (i *IndividualSchema) GetFirstName() string {
	if i == nil {
		return ""
	}
	return i.FirstName
}

func (i *IndividualSchema) GetIdNumber() *string {
	if i == nil {
		return nil
	}
	return i.IdNumber
}

func (i *IndividualSchema) GetLastName() string {
	if i == nil {
		return ""
	}
	return i.LastName
}

func (i *IndividualSchema) GetSsnLast4() *string {
	if i == nil {
		return nil
	}
	return i.SsnLast4
}

func (i *IndividualSchema) GetTitle() *string {
	if i == nil {
		return nil
	}
	return i.Title
}

func (i *IndividualSchema) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndividualSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualSchema(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualSchema) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type MergedSettingsResponse struct {
	// Settings for the accounting module.
	Accounting *AccountingSettingsResponse `json:"accounting,omitempty" url:"accounting,omitempty"`
	// Automatically attempt to find a corresponding purchase order for all incoming payables.
	AllowPurchaseOrderAutolinking *bool `json:"allow_purchase_order_autolinking,omitempty" url:"allow_purchase_order_autolinking,omitempty"`
	// Default API version for partner.
	ApiVersion *ApiVersion `json:"api_version,omitempty" url:"api_version,omitempty"`
	// Commercial conditions for receivables.
	CommercialConditions []string `json:"commercial_conditions,omitempty" url:"commercial_conditions,omitempty"`
	// Custom currency exchange rates.
	Currency *CurrencySettings `json:"currency,omitempty" url:"currency,omitempty"`
	// A default role to provision upon new entity creation.
	DefaultRole map[string]interface{} `json:"default_role,omitempty" url:"default_role,omitempty"`
	DocumentIds *DocumentIDsSettings   `json:"document_ids,omitempty" url:"document_ids,omitempty"`
	// Settings for the e-invoicing module.
	Einvoicing *EInvoicingSettingsResponse `json:"einvoicing,omitempty" url:"einvoicing,omitempty"`
	// If enabled, the paid invoice's PDF will be in a new layout set by the user
	GeneratePaidInvoicePdf *bool             `json:"generate_paid_invoice_pdf,omitempty" url:"generate_paid_invoice_pdf,omitempty"`
	Language               *LanguageCodeEnum `json:"language,omitempty" url:"language,omitempty"`
	// Settings for email and mailboxes.
	Mail *MailSettingsResponse `json:"mail,omitempty" url:"mail,omitempty"`
	// Settings for the payables module.
	Payable *PayableSettingsResponse `json:"payable,omitempty" url:"payable,omitempty"`
	// Auto tagging settings for all incoming OCR payable documents.
	PayablesOcrAutoTagging []*OcrAutoTaggingSettingsRequest `json:"payables_ocr_auto_tagging,omitempty" url:"payables_ocr_auto_tagging,omitempty"`
	// Payment preferences for entity to automate calculating suggested payment date basing on payment terms and entity preferences
	PaymentPriority *PaymentPriorityEnum `json:"payment_priority,omitempty" url:"payment_priority,omitempty"`
	// Settings for the payments module.
	Payments *PaymentsSettingsResponse `json:"payments,omitempty" url:"payments,omitempty"`
	// Sets the default behavior of whether a signature is required to accept quotes
	QuoteSignatureRequired *bool `json:"quote_signature_required,omitempty" url:"quote_signature_required,omitempty"`
	// Settings for the receivables module.
	Receivable         *ReceivableSettingsResponse `json:"receivable,omitempty" url:"receivable,omitempty"`
	ReceivableEditFlow *ReceivableEditFlow         `json:"receivable_edit_flow,omitempty" url:"receivable_edit_flow,omitempty"`
	Reminder           *RemindersSettings          `json:"reminder,omitempty" url:"reminder,omitempty"`
	// Measurement units.
	Units []*Unit `json:"units,omitempty" url:"units,omitempty"`
	// Defines whether the prices of products in receivables will already include VAT or not.
	VatMode *VatModeEnum `json:"vat_mode,omitempty" url:"vat_mode,omitempty"`
	Website *string      `json:"website,omitempty" url:"website,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MergedSettingsResponse) GetAccounting() *AccountingSettingsResponse {
	if m == nil {
		return nil
	}
	return m.Accounting
}

func (m *MergedSettingsResponse) GetAllowPurchaseOrderAutolinking() *bool {
	if m == nil {
		return nil
	}
	return m.AllowPurchaseOrderAutolinking
}

func (m *MergedSettingsResponse) GetApiVersion() *ApiVersion {
	if m == nil {
		return nil
	}
	return m.ApiVersion
}

func (m *MergedSettingsResponse) GetCommercialConditions() []string {
	if m == nil {
		return nil
	}
	return m.CommercialConditions
}

func (m *MergedSettingsResponse) GetCurrency() *CurrencySettings {
	if m == nil {
		return nil
	}
	return m.Currency
}

func (m *MergedSettingsResponse) GetDefaultRole() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.DefaultRole
}

func (m *MergedSettingsResponse) GetDocumentIds() *DocumentIDsSettings {
	if m == nil {
		return nil
	}
	return m.DocumentIds
}

func (m *MergedSettingsResponse) GetEinvoicing() *EInvoicingSettingsResponse {
	if m == nil {
		return nil
	}
	return m.Einvoicing
}

func (m *MergedSettingsResponse) GetGeneratePaidInvoicePdf() *bool {
	if m == nil {
		return nil
	}
	return m.GeneratePaidInvoicePdf
}

func (m *MergedSettingsResponse) GetLanguage() *LanguageCodeEnum {
	if m == nil {
		return nil
	}
	return m.Language
}

func (m *MergedSettingsResponse) GetMail() *MailSettingsResponse {
	if m == nil {
		return nil
	}
	return m.Mail
}

func (m *MergedSettingsResponse) GetPayable() *PayableSettingsResponse {
	if m == nil {
		return nil
	}
	return m.Payable
}

func (m *MergedSettingsResponse) GetPayablesOcrAutoTagging() []*OcrAutoTaggingSettingsRequest {
	if m == nil {
		return nil
	}
	return m.PayablesOcrAutoTagging
}

func (m *MergedSettingsResponse) GetPaymentPriority() *PaymentPriorityEnum {
	if m == nil {
		return nil
	}
	return m.PaymentPriority
}

func (m *MergedSettingsResponse) GetPayments() *PaymentsSettingsResponse {
	if m == nil {
		return nil
	}
	return m.Payments
}

func (m *MergedSettingsResponse) GetQuoteSignatureRequired() *bool {
	if m == nil {
		return nil
	}
	return m.QuoteSignatureRequired
}

func (m *MergedSettingsResponse) GetReceivable() *ReceivableSettingsResponse {
	if m == nil {
		return nil
	}
	return m.Receivable
}

func (m *MergedSettingsResponse) GetReceivableEditFlow() *ReceivableEditFlow {
	if m == nil {
		return nil
	}
	return m.ReceivableEditFlow
}

func (m *MergedSettingsResponse) GetReminder() *RemindersSettings {
	if m == nil {
		return nil
	}
	return m.Reminder
}

func (m *MergedSettingsResponse) GetUnits() []*Unit {
	if m == nil {
		return nil
	}
	return m.Units
}

func (m *MergedSettingsResponse) GetVatMode() *VatModeEnum {
	if m == nil {
		return nil
	}
	return m.VatMode
}

func (m *MergedSettingsResponse) GetWebsite() *string {
	if m == nil {
		return nil
	}
	return m.Website
}

func (m *MergedSettingsResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MergedSettingsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MergedSettingsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MergedSettingsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MergedSettingsResponse) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type OcrAutoTaggingSettingsRequest struct {
	// Tag identifier that will be assigned to the payable document if one of the words listed in keywords is found during OCR
	TagId string `json:"tag_id" url:"tag_id"`
	// A list of words that will be searched for assigning a tag in the recognized fields of the document after OCR processing. If at least one match is found, the tag will be assigned. Each keyword must be between 2 and 25 characters long
	Keywords []string `json:"keywords" url:"keywords"`
	// A switch to temporarily disable a keyword without removing it from the list
	Enabled bool `json:"enabled" url:"enabled"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrAutoTaggingSettingsRequest) GetTagId() string {
	if o == nil {
		return ""
	}
	return o.TagId
}

func (o *OcrAutoTaggingSettingsRequest) GetKeywords() []string {
	if o == nil {
		return nil
	}
	return o.Keywords
}

func (o *OcrAutoTaggingSettingsRequest) GetEnabled() bool {
	if o == nil {
		return false
	}
	return o.Enabled
}

func (o *OcrAutoTaggingSettingsRequest) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrAutoTaggingSettingsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrAutoTaggingSettingsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrAutoTaggingSettingsRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrAutoTaggingSettingsRequest) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OnboardingRequirementsError struct {
	Code        string `json:"code" url:"code"`
	Reason      string `json:"reason" url:"reason"`
	Requirement string `json:"requirement" url:"requirement"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OnboardingRequirementsError) GetCode() string {
	if o == nil {
		return ""
	}
	return o.Code
}

func (o *OnboardingRequirementsError) GetReason() string {
	if o == nil {
		return ""
	}
	return o.Reason
}

func (o *OnboardingRequirementsError) GetRequirement() string {
	if o == nil {
		return ""
	}
	return o.Requirement
}

func (o *OnboardingRequirementsError) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OnboardingRequirementsError) UnmarshalJSON(data []byte) error {
	type unmarshaler OnboardingRequirementsError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OnboardingRequirementsError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OnboardingRequirementsError) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OnboardingVerificationError struct {
	Code    string `json:"code" url:"code"`
	Details string `json:"details" url:"details"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OnboardingVerificationError) GetCode() string {
	if o == nil {
		return ""
	}
	return o.Code
}

func (o *OnboardingVerificationError) GetDetails() string {
	if o == nil {
		return ""
	}
	return o.Details
}

func (o *OnboardingVerificationError) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OnboardingVerificationError) UnmarshalJSON(data []byte) error {
	type unmarshaler OnboardingVerificationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OnboardingVerificationError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OnboardingVerificationError) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OnboardingVerificationStatusEnum string

const (
	OnboardingVerificationStatusEnumEnabled  OnboardingVerificationStatusEnum = "enabled"
	OnboardingVerificationStatusEnumDisabled OnboardingVerificationStatusEnum = "disabled"
	OnboardingVerificationStatusEnumPending  OnboardingVerificationStatusEnum = "pending"
)

func NewOnboardingVerificationStatusEnumFromString(s string) (OnboardingVerificationStatusEnum, error) {
	switch s {
	case "enabled":
		return OnboardingVerificationStatusEnumEnabled, nil
	case "disabled":
		return OnboardingVerificationStatusEnumDisabled, nil
	case "pending":
		return OnboardingVerificationStatusEnumPending, nil
	}
	var t OnboardingVerificationStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OnboardingVerificationStatusEnum) Ptr() *OnboardingVerificationStatusEnum {
	return &o
}

// A schema contains metadata for an organization
type OrganizationSchema struct {
	// Business structure of the company
	BusinessStructure  *EntityBusinessStructure `json:"business_structure,omitempty" url:"business_structure,omitempty"`
	DirectorsProvided  *bool                    `json:"directors_provided,omitempty" url:"directors_provided,omitempty"`
	ExecutivesProvided *bool                    `json:"executives_provided,omitempty" url:"executives_provided,omitempty"`
	// A code which identifies uniquely a party of a transaction worldwide
	LegalEntityId *string `json:"legal_entity_id,omitempty" url:"legal_entity_id,omitempty"`
	// A legal name of an organization
	LegalName              string `json:"legal_name" url:"legal_name"`
	OwnersProvided         *bool  `json:"owners_provided,omitempty" url:"owners_provided,omitempty"`
	RepresentativeProvided *bool  `json:"representative_provided,omitempty" url:"representative_provided,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrganizationSchema) GetBusinessStructure() *EntityBusinessStructure {
	if o == nil {
		return nil
	}
	return o.BusinessStructure
}

func (o *OrganizationSchema) GetDirectorsProvided() *bool {
	if o == nil {
		return nil
	}
	return o.DirectorsProvided
}

func (o *OrganizationSchema) GetExecutivesProvided() *bool {
	if o == nil {
		return nil
	}
	return o.ExecutivesProvided
}

func (o *OrganizationSchema) GetLegalEntityId() *string {
	if o == nil {
		return nil
	}
	return o.LegalEntityId
}

func (o *OrganizationSchema) GetLegalName() string {
	if o == nil {
		return ""
	}
	return o.LegalName
}

func (o *OrganizationSchema) GetOwnersProvided() *bool {
	if o == nil {
		return nil
	}
	return o.OwnersProvided
}

func (o *OrganizationSchema) GetRepresentativeProvided() *bool {
	if o == nil {
		return nil
	}
	return o.RepresentativeProvided
}

func (o *OrganizationSchema) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationSchema(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrganizationSchema) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PaymentMethodRequirements struct {
	CurrentDeadline     *time.Time `json:"current_deadline,omitempty" url:"current_deadline,omitempty"`
	CurrentlyDue        []string   `json:"currently_due" url:"currently_due"`
	EventuallyDue       []string   `json:"eventually_due" url:"eventually_due"`
	PastDue             []string   `json:"past_due" url:"past_due"`
	PendingVerification []string   `json:"pending_verification" url:"pending_verification"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentMethodRequirements) GetCurrentDeadline() *time.Time {
	if p == nil {
		return nil
	}
	return p.CurrentDeadline
}

func (p *PaymentMethodRequirements) GetCurrentlyDue() []string {
	if p == nil {
		return nil
	}
	return p.CurrentlyDue
}

func (p *PaymentMethodRequirements) GetEventuallyDue() []string {
	if p == nil {
		return nil
	}
	return p.EventuallyDue
}

func (p *PaymentMethodRequirements) GetPastDue() []string {
	if p == nil {
		return nil
	}
	return p.PastDue
}

func (p *PaymentMethodRequirements) GetPendingVerification() []string {
	if p == nil {
		return nil
	}
	return p.PendingVerification
}

func (p *PaymentMethodRequirements) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodRequirements) UnmarshalJSON(data []byte) error {
	type embed PaymentMethodRequirements
	var unmarshaler = struct {
		embed
		CurrentDeadline *internal.DateTime `json:"current_deadline,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentMethodRequirements(unmarshaler.embed)
	p.CurrentDeadline = unmarshaler.CurrentDeadline.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodRequirements) MarshalJSON() ([]byte, error) {
	type embed PaymentMethodRequirements
	var marshaler = struct {
		embed
		CurrentDeadline *internal.DateTime `json:"current_deadline,omitempty"`
	}{
		embed:           embed(*p),
		CurrentDeadline: internal.NewOptionalDateTime(p.CurrentDeadline),
	}
	return json.Marshal(marshaler)
}

func (p *PaymentMethodRequirements) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentPriorityEnum string

const (
	PaymentPriorityEnumWorkingCapital PaymentPriorityEnum = "working_capital"
	PaymentPriorityEnumBalanced       PaymentPriorityEnum = "balanced"
	PaymentPriorityEnumBottomLine     PaymentPriorityEnum = "bottom_line"
)

func NewPaymentPriorityEnumFromString(s string) (PaymentPriorityEnum, error) {
	switch s {
	case "working_capital":
		return PaymentPriorityEnumWorkingCapital, nil
	case "balanced":
		return PaymentPriorityEnumBalanced, nil
	case "bottom_line":
		return PaymentPriorityEnumBottomLine, nil
	}
	var t PaymentPriorityEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentPriorityEnum) Ptr() *PaymentPriorityEnum {
	return &p
}

type ReceivableEditFlow string

const (
	ReceivableEditFlowCompliant          ReceivableEditFlow = "compliant"
	ReceivableEditFlowPartiallyCompliant ReceivableEditFlow = "partially_compliant"
	ReceivableEditFlowNonCompliant       ReceivableEditFlow = "non_compliant"
)

func NewReceivableEditFlowFromString(s string) (ReceivableEditFlow, error) {
	switch s {
	case "compliant":
		return ReceivableEditFlowCompliant, nil
	case "partially_compliant":
		return ReceivableEditFlowPartiallyCompliant, nil
	case "non_compliant":
		return ReceivableEditFlowNonCompliant, nil
	}
	var t ReceivableEditFlow
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ReceivableEditFlow) Ptr() *ReceivableEditFlow {
	return &r
}

type RemindersSettings struct {
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemindersSettings) GetEnabled() *bool {
	if r == nil {
		return nil
	}
	return r.Enabled
}

func (r *RemindersSettings) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemindersSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler RemindersSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemindersSettings(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemindersSettings) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SingleOnboardingRequirementsResponse struct {
	DisabledReason     *string                          `json:"disabled_reason,omitempty" url:"disabled_reason,omitempty"`
	PaymentMethod      string                           `json:"payment_method" url:"payment_method"`
	Requirements       *PaymentMethodRequirements       `json:"requirements" url:"requirements"`
	RequirementsErrors []*OnboardingRequirementsError   `json:"requirements_errors" url:"requirements_errors"`
	VerificationErrors []*OnboardingVerificationError   `json:"verification_errors" url:"verification_errors"`
	VerificationStatus OnboardingVerificationStatusEnum `json:"verification_status" url:"verification_status"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SingleOnboardingRequirementsResponse) GetDisabledReason() *string {
	if s == nil {
		return nil
	}
	return s.DisabledReason
}

func (s *SingleOnboardingRequirementsResponse) GetPaymentMethod() string {
	if s == nil {
		return ""
	}
	return s.PaymentMethod
}

func (s *SingleOnboardingRequirementsResponse) GetRequirements() *PaymentMethodRequirements {
	if s == nil {
		return nil
	}
	return s.Requirements
}

func (s *SingleOnboardingRequirementsResponse) GetRequirementsErrors() []*OnboardingRequirementsError {
	if s == nil {
		return nil
	}
	return s.RequirementsErrors
}

func (s *SingleOnboardingRequirementsResponse) GetVerificationErrors() []*OnboardingVerificationError {
	if s == nil {
		return nil
	}
	return s.VerificationErrors
}

func (s *SingleOnboardingRequirementsResponse) GetVerificationStatus() OnboardingVerificationStatusEnum {
	if s == nil {
		return ""
	}
	return s.VerificationStatus
}

func (s *SingleOnboardingRequirementsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleOnboardingRequirementsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleOnboardingRequirementsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleOnboardingRequirementsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleOnboardingRequirementsResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type PatchSettingsPayload struct {
	Language *LanguageCodeEnum  `json:"language,omitempty" url:"-"`
	Currency *CurrencySettings  `json:"currency,omitempty" url:"-"`
	Reminder *RemindersSettings `json:"reminder,omitempty" url:"-"`
	// Defines whether the prices of products in receivables will already include VAT or not.
	VatMode *VatModeEnum `json:"vat_mode,omitempty" url:"-"`
	// Payment preferences for entity to automate calculating suggested payment date basing on payment terms and entity preferences
	PaymentPriority *PaymentPriorityEnum `json:"payment_priority,omitempty" url:"-"`
	// Automatically attempt to find a corresponding purchase order for all incoming payables.
	AllowPurchaseOrderAutolinking *bool                       `json:"allow_purchase_order_autolinking,omitempty" url:"-"`
	ReceivableEditFlow            *ReceivableEditFlow         `json:"receivable_edit_flow,omitempty" url:"-"`
	DocumentIds                   *DocumentIDsSettingsRequest `json:"document_ids,omitempty" url:"-"`
	// Auto tagging settings for all incoming OCR payable documents.
	PayablesOcrAutoTagging []*OcrAutoTaggingSettingsRequest `json:"payables_ocr_auto_tagging,omitempty" url:"-"`
	// Sets the default behavior of whether a signature is required to accept quotes
	QuoteSignatureRequired *bool `json:"quote_signature_required,omitempty" url:"-"`
	// If enabled, the paid invoice's PDF will be in a new layout set by the user
	GeneratePaidInvoicePdf *bool `json:"generate_paid_invoice_pdf,omitempty" url:"-"`
}

type EntityLogoUploadRequest struct {
	File io.Reader `json:"-" url:"-"`
}

type EntityOnboardingDocumentsPayload struct {
	AdditionalVerificationDocumentBack  *string  `json:"additional_verification_document_back,omitempty" url:"-"`
	AdditionalVerificationDocumentFront *string  `json:"additional_verification_document_front,omitempty" url:"-"`
	BankAccountOwnershipVerification    []string `json:"bank_account_ownership_verification,omitempty" url:"-"`
	CompanyLicense                      []string `json:"company_license,omitempty" url:"-"`
	CompanyMemorandumOfAssociation      []string `json:"company_memorandum_of_association,omitempty" url:"-"`
	CompanyMinisterialDecree            []string `json:"company_ministerial_decree,omitempty" url:"-"`
	CompanyRegistrationVerification     []string `json:"company_registration_verification,omitempty" url:"-"`
	CompanyTaxIdVerification            []string `json:"company_tax_id_verification,omitempty" url:"-"`
	ProofOfRegistration                 []string `json:"proof_of_registration,omitempty" url:"-"`
	VerificationDocumentBack            *string  `json:"verification_document_back,omitempty" url:"-"`
	VerificationDocumentFront           *string  `json:"verification_document_front,omitempty" url:"-"`
}
