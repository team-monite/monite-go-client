// This file was auto-generated by Fern from our API Definition.

package fluidstack

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/team-monite/monite-go-client/internal"
	io "io"
	time "time"
)

type CreateEntityRequest struct {
	// An address description of the entity
	Address *EntityAddressSchema `json:"address,omitempty" url:"-"`
	// An official email address of the entity
	Email string `json:"email" url:"-"`
	// The contact phone number of the entity. Required for US organizations to use payments.
	Phone *string `json:"phone,omitempty" url:"-"`
	// A website of the entity
	Website *string `json:"website,omitempty" url:"-"`
	// A set of meta data describing the organization
	Organization *OrganizationSchema `json:"organization,omitempty" url:"-"`
	// A set of meta data describing the individual
	Individual *IndividualSchema `json:"individual,omitempty" url:"-"`
	// The entity's taxpayer identification number or tax ID. This field is required for entities that are non-VAT registered.
	TaxId *string `json:"tax_id,omitempty" url:"-"`
	// A type for an entity
	Type EntityTypeEnum `json:"type" url:"-"`
}

type EntitiesGetRequest struct {
	// Sort order (ascending by default). Typically used together with the `sort` parameter.
	Order *OrderEnum `json:"-" url:"order,omitempty"`
	// The number of items (0 .. 100) to return in a single page of the response. The response may contain fewer items if it is the last or only page.
	Limit *int `json:"-" url:"limit,omitempty"`
	// A pagination token obtained from a previous call to this endpoint. Use it to get the next or previous page of results for your initial query. If `pagination_token` is specified, all other query parameters are ignored and inferred from the initial query.
	//
	// If not specified, the first page of results will be returned.
	PaginationToken *string `json:"-" url:"pagination_token,omitempty"`
	// The field to sort the results by. Typically used together with the `order` parameter.
	Sort         *EntityCursorFields `json:"-" url:"sort,omitempty"`
	Type         *EntityTypeEnum     `json:"-" url:"type,omitempty"`
	CreatedAtGt  *time.Time          `json:"-" url:"created_at__gt,omitempty"`
	CreatedAtLt  *time.Time          `json:"-" url:"created_at__lt,omitempty"`
	CreatedAtGte *time.Time          `json:"-" url:"created_at__gte,omitempty"`
	CreatedAtLte *time.Time          `json:"-" url:"created_at__lte,omitempty"`
	IdIn         []*string           `json:"-" url:"id__in,omitempty"`
	IdNotIn      []*string           `json:"-" url:"id__not_in,omitempty"`
	Email        *string             `json:"-" url:"email,omitempty"`
	EmailIn      []*string           `json:"-" url:"email__in,omitempty"`
	EmailNotIn   []*string           `json:"-" url:"email__not_in,omitempty"`
}

type AccountingSettings struct {
	// Default ledger accounts that will be used for various objects pushed into an accounting system. Use `GET /ledger_accounts` to get the IDs of these ledger accounts.
	LedgerAccountIds *DefaultLedgerAccountIDs `json:"ledger_account_ids,omitempty" url:"ledger_account_ids,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AccountingSettings) GetLedgerAccountIds() *DefaultLedgerAccountIDs {
	if a == nil {
		return nil
	}
	return a.LedgerAccountIds
}

func (a *AccountingSettings) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccountingSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountingSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountingSettings(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountingSettings) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type DefaultLedgerAccountIDs struct {
	// ID of the ledger account to which all payment records will be pushed. Changing this value affects only future data pushes and does not affect payment records that already exist in the accounting system.
	Payments *string `json:"payments,omitempty" url:"payments,omitempty"`
	// ID of the ledger account to which products without a `ledger_account_id` specified will be pushed. Changing this value affects only future data pushes and does not affect products that already exist in the accounting system.
	Products *string `json:"products,omitempty" url:"products,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DefaultLedgerAccountIDs) GetPayments() *string {
	if d == nil {
		return nil
	}
	return d.Payments
}

func (d *DefaultLedgerAccountIDs) GetProducts() *string {
	if d == nil {
		return nil
	}
	return d.Products
}

func (d *DefaultLedgerAccountIDs) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DefaultLedgerAccountIDs) UnmarshalJSON(data []byte) error {
	type unmarshaler DefaultLedgerAccountIDs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DefaultLedgerAccountIDs(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DefaultLedgerAccountIDs) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DocumentIDsSettings struct {
	// Prefixes for each document_type.
	DocumentTypePrefix *DocumentTypePrefix `json:"document_type_prefix,omitempty" url:"document_type_prefix,omitempty"`
	// Optionally add 4-digit of the current year.
	IncludeDate *bool `json:"include_date,omitempty" url:"include_date,omitempty"`
	// Minimal size of number in document ID Number will be left padded with zeros if less.
	MinDigits *int `json:"min_digits,omitempty" url:"min_digits,omitempty"`
	// Optional prefix. Does not substitute document_type prefix.
	Prefix *string `json:"prefix,omitempty" url:"prefix,omitempty"`
	// Which character should separate each part of the document_id.
	Separator *DocumentIdSeparators `json:"separator,omitempty" url:"separator,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DocumentIDsSettings) GetDocumentTypePrefix() *DocumentTypePrefix {
	if d == nil {
		return nil
	}
	return d.DocumentTypePrefix
}

func (d *DocumentIDsSettings) GetIncludeDate() *bool {
	if d == nil {
		return nil
	}
	return d.IncludeDate
}

func (d *DocumentIDsSettings) GetMinDigits() *int {
	if d == nil {
		return nil
	}
	return d.MinDigits
}

func (d *DocumentIDsSettings) GetPrefix() *string {
	if d == nil {
		return nil
	}
	return d.Prefix
}

func (d *DocumentIDsSettings) GetSeparator() *DocumentIdSeparators {
	if d == nil {
		return nil
	}
	return d.Separator
}

func (d *DocumentIDsSettings) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentIDsSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentIDsSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentIDsSettings(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentIDsSettings) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DocumentIDsSettingsNextNumber struct {
	CreditNote    *int `json:"credit_note,omitempty" url:"credit_note,omitempty"`
	Invoice       *int `json:"invoice,omitempty" url:"invoice,omitempty"`
	PurchaseOrder *int `json:"purchase_order,omitempty" url:"purchase_order,omitempty"`
	Quote         *int `json:"quote,omitempty" url:"quote,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DocumentIDsSettingsNextNumber) GetCreditNote() *int {
	if d == nil {
		return nil
	}
	return d.CreditNote
}

func (d *DocumentIDsSettingsNextNumber) GetInvoice() *int {
	if d == nil {
		return nil
	}
	return d.Invoice
}

func (d *DocumentIDsSettingsNextNumber) GetPurchaseOrder() *int {
	if d == nil {
		return nil
	}
	return d.PurchaseOrder
}

func (d *DocumentIDsSettingsNextNumber) GetQuote() *int {
	if d == nil {
		return nil
	}
	return d.Quote
}

func (d *DocumentIDsSettingsNextNumber) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentIDsSettingsNextNumber) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentIDsSettingsNextNumber
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentIDsSettingsNextNumber(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentIDsSettingsNextNumber) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DocumentIDsSettingsRequest struct {
	// Prefixes for each document_type.
	DocumentTypePrefix *DocumentTypePrefix `json:"document_type_prefix,omitempty" url:"document_type_prefix,omitempty"`
	// Optionally add 4-digit of the current year.
	IncludeDate *bool `json:"include_date,omitempty" url:"include_date,omitempty"`
	// Minimal size of number in document ID Number will be left padded with zeros if less.
	MinDigits *int `json:"min_digits,omitempty" url:"min_digits,omitempty"`
	// Write-only field. Changes which number will be issued next. Can't be less than the last issued document number.
	NextNumber *DocumentIDsSettingsNextNumber `json:"next_number,omitempty" url:"next_number,omitempty"`
	// Optional prefix. Does not substitute document_type prefix.
	Prefix *string `json:"prefix,omitempty" url:"prefix,omitempty"`
	// Which character should separate each part of the document_id.
	Separator *DocumentIdSeparators `json:"separator,omitempty" url:"separator,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DocumentIDsSettingsRequest) GetDocumentTypePrefix() *DocumentTypePrefix {
	if d == nil {
		return nil
	}
	return d.DocumentTypePrefix
}

func (d *DocumentIDsSettingsRequest) GetIncludeDate() *bool {
	if d == nil {
		return nil
	}
	return d.IncludeDate
}

func (d *DocumentIDsSettingsRequest) GetMinDigits() *int {
	if d == nil {
		return nil
	}
	return d.MinDigits
}

func (d *DocumentIDsSettingsRequest) GetNextNumber() *DocumentIDsSettingsNextNumber {
	if d == nil {
		return nil
	}
	return d.NextNumber
}

func (d *DocumentIDsSettingsRequest) GetPrefix() *string {
	if d == nil {
		return nil
	}
	return d.Prefix
}

func (d *DocumentIDsSettingsRequest) GetSeparator() *DocumentIdSeparators {
	if d == nil {
		return nil
	}
	return d.Separator
}

func (d *DocumentIDsSettingsRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentIDsSettingsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentIDsSettingsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentIDsSettingsRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentIDsSettingsRequest) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DocumentIdSeparators string

const (
	DocumentIdSeparatorsSlash  DocumentIdSeparators = "/"
	DocumentIdSeparatorsHyphen DocumentIdSeparators = "-"
	DocumentIdSeparatorsPipe   DocumentIdSeparators = "|"
	DocumentIdSeparatorsDot    DocumentIdSeparators = "."
	DocumentIdSeparatorsEmpty  DocumentIdSeparators = ""
)

func NewDocumentIdSeparatorsFromString(s string) (DocumentIdSeparators, error) {
	switch s {
	case "/":
		return DocumentIdSeparatorsSlash, nil
	case "-":
		return DocumentIdSeparatorsHyphen, nil
	case "|":
		return DocumentIdSeparatorsPipe, nil
	case ".":
		return DocumentIdSeparatorsDot, nil
	case "":
		return DocumentIdSeparatorsEmpty, nil
	}
	var t DocumentIdSeparators
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DocumentIdSeparators) Ptr() *DocumentIdSeparators {
	return &d
}

type DocumentTypePrefix struct {
	CreditNote    *string `json:"credit_note,omitempty" url:"credit_note,omitempty"`
	Invoice       *string `json:"invoice,omitempty" url:"invoice,omitempty"`
	PurchaseOrder *string `json:"purchase_order,omitempty" url:"purchase_order,omitempty"`
	Quote         *string `json:"quote,omitempty" url:"quote,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DocumentTypePrefix) GetCreditNote() *string {
	if d == nil {
		return nil
	}
	return d.CreditNote
}

func (d *DocumentTypePrefix) GetInvoice() *string {
	if d == nil {
		return nil
	}
	return d.Invoice
}

func (d *DocumentTypePrefix) GetPurchaseOrder() *string {
	if d == nil {
		return nil
	}
	return d.PurchaseOrder
}

func (d *DocumentTypePrefix) GetQuote() *string {
	if d == nil {
		return nil
	}
	return d.Quote
}

func (d *DocumentTypePrefix) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentTypePrefix) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentTypePrefix
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentTypePrefix(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentTypePrefix) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// A schema represents address info of the entity
type EntityAddressSchema struct {
	// A city (a full name) where the entity is registered
	City string `json:"city" url:"city"`
	// A country name (as ISO code) where the entity is registered
	Country AllowedCountries `json:"country" url:"country"`
	// A street where the entity is registered
	Line1 string `json:"line1" url:"line1"`
	// An alternative street used by the entity
	Line2 *string `json:"line2,omitempty" url:"line2,omitempty"`
	// A postal code of the address where the entity is registered
	PostalCode string `json:"postal_code" url:"postal_code"`
	// State, county, province, prefecture, region, or similar component of the entity's address. For US entities, `state` is required and must be a two-letter [USPS state abbreviation](https://pe.usps.com/text/pub28/28apb.htm), for example, NY or CA.
	State *string `json:"state,omitempty" url:"state,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityAddressSchema) GetCity() string {
	if e == nil {
		return ""
	}
	return e.City
}

func (e *EntityAddressSchema) GetCountry() AllowedCountries {
	if e == nil {
		return ""
	}
	return e.Country
}

func (e *EntityAddressSchema) GetLine1() string {
	if e == nil {
		return ""
	}
	return e.Line1
}

func (e *EntityAddressSchema) GetLine2() *string {
	if e == nil {
		return nil
	}
	return e.Line2
}

func (e *EntityAddressSchema) GetPostalCode() string {
	if e == nil {
		return ""
	}
	return e.PostalCode
}

func (e *EntityAddressSchema) GetState() *string {
	if e == nil {
		return nil
	}
	return e.State
}

func (e *EntityAddressSchema) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityAddressSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityAddressSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityAddressSchema(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityAddressSchema) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityCursorFields string

const (
	EntityCursorFieldsCreatedAt EntityCursorFields = "created_at"
	EntityCursorFieldsUpdatedAt EntityCursorFields = "updated_at"
)

func NewEntityCursorFieldsFromString(s string) (EntityCursorFields, error) {
	switch s {
	case "created_at":
		return EntityCursorFieldsCreatedAt, nil
	case "updated_at":
		return EntityCursorFieldsUpdatedAt, nil
	}
	var t EntityCursorFields
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EntityCursorFields) Ptr() *EntityCursorFields {
	return &e
}

type EntityPaginationResponse struct {
	// A set of entities of different types returned per page
	Data []*EntityResponse `json:"data" url:"data"`
	// A token that can be sent in the `pagination_token` query parameter to get the previous page of results, or `null` if there is no previous page (i.e. you've reached the first page).
	PrevPaginationToken *string `json:"prev_pagination_token,omitempty" url:"prev_pagination_token,omitempty"`
	// A token that can be sent in the `pagination_token` query parameter to get the next page of results, or `null` if there is no next page (i.e. you've reached the last page).
	NextPaginationToken *string `json:"next_pagination_token,omitempty" url:"next_pagination_token,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityPaginationResponse) GetData() []*EntityResponse {
	if e == nil {
		return nil
	}
	return e.Data
}

func (e *EntityPaginationResponse) GetPrevPaginationToken() *string {
	if e == nil {
		return nil
	}
	return e.PrevPaginationToken
}

func (e *EntityPaginationResponse) GetNextPaginationToken() *string {
	if e == nil {
		return nil
	}
	return e.NextPaginationToken
}

func (e *EntityPaginationResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityPaginationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityPaginationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityPaginationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityPaginationResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityTypeEnum string

const (
	EntityTypeEnumIndividual   EntityTypeEnum = "individual"
	EntityTypeEnumOrganization EntityTypeEnum = "organization"
)

func NewEntityTypeEnumFromString(s string) (EntityTypeEnum, error) {
	switch s {
	case "individual":
		return EntityTypeEnumIndividual, nil
	case "organization":
		return EntityTypeEnumOrganization, nil
	}
	var t EntityTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EntityTypeEnum) Ptr() *EntityTypeEnum {
	return &e
}

type GetOnboardingRequirementsResponse struct {
	Data []*SingleOnboardingRequirementsResponse `json:"data" url:"data"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetOnboardingRequirementsResponse) GetData() []*SingleOnboardingRequirementsResponse {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GetOnboardingRequirementsResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetOnboardingRequirementsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetOnboardingRequirementsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetOnboardingRequirementsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetOnboardingRequirementsResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A schema contains metadata for an individual
type IndividualSchema struct {
	DateOfBirth *string `json:"date_of_birth,omitempty" url:"date_of_birth,omitempty"`
	// A first name of an individual
	FirstName string  `json:"first_name" url:"first_name"`
	IdNumber  *string `json:"id_number,omitempty" url:"id_number,omitempty"`
	// A last name of an individual
	LastName string `json:"last_name" url:"last_name"`
	// The last four digits of the individual's Social Security number
	SsnLast4 *string `json:"ssn_last_4,omitempty" url:"ssn_last_4,omitempty"`
	// A title of an individual
	Title *string `json:"title,omitempty" url:"title,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IndividualSchema) GetDateOfBirth() *string {
	if i == nil {
		return nil
	}
	return i.DateOfBirth
}

func (i *IndividualSchema) GetFirstName() string {
	if i == nil {
		return ""
	}
	return i.FirstName
}

func (i *IndividualSchema) GetIdNumber() *string {
	if i == nil {
		return nil
	}
	return i.IdNumber
}

func (i *IndividualSchema) GetLastName() string {
	if i == nil {
		return ""
	}
	return i.LastName
}

func (i *IndividualSchema) GetSsnLast4() *string {
	if i == nil {
		return nil
	}
	return i.SsnLast4
}

func (i *IndividualSchema) GetTitle() *string {
	if i == nil {
		return nil
	}
	return i.Title
}

func (i *IndividualSchema) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndividualSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualSchema(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualSchema) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type OcrAutoTaggingSettingsRequest struct {
	// A switch to temporarily disable a keyword without removing it from the list.
	Enabled bool `json:"enabled" url:"enabled"`
	// A list of words that will be searched for assigning a tag in the recognized fields of the document after OCR processing. If at least one match is found, the tag will be assigned. Each keyword must be between 2 and 25 characters long.
	Keywords []string `json:"keywords" url:"keywords"`
	// Tag identifier that will be assigned to the payable document if one of the words listed in keywords is found during OCR.
	TagId string `json:"tag_id" url:"tag_id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrAutoTaggingSettingsRequest) GetEnabled() bool {
	if o == nil {
		return false
	}
	return o.Enabled
}

func (o *OcrAutoTaggingSettingsRequest) GetKeywords() []string {
	if o == nil {
		return nil
	}
	return o.Keywords
}

func (o *OcrAutoTaggingSettingsRequest) GetTagId() string {
	if o == nil {
		return ""
	}
	return o.TagId
}

func (o *OcrAutoTaggingSettingsRequest) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrAutoTaggingSettingsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrAutoTaggingSettingsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrAutoTaggingSettingsRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrAutoTaggingSettingsRequest) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OnboardingRequirementsError struct {
	Code        string `json:"code" url:"code"`
	Reason      string `json:"reason" url:"reason"`
	Requirement string `json:"requirement" url:"requirement"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OnboardingRequirementsError) GetCode() string {
	if o == nil {
		return ""
	}
	return o.Code
}

func (o *OnboardingRequirementsError) GetReason() string {
	if o == nil {
		return ""
	}
	return o.Reason
}

func (o *OnboardingRequirementsError) GetRequirement() string {
	if o == nil {
		return ""
	}
	return o.Requirement
}

func (o *OnboardingRequirementsError) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OnboardingRequirementsError) UnmarshalJSON(data []byte) error {
	type unmarshaler OnboardingRequirementsError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OnboardingRequirementsError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OnboardingRequirementsError) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OnboardingVerificationError struct {
	Code    string `json:"code" url:"code"`
	Details string `json:"details" url:"details"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OnboardingVerificationError) GetCode() string {
	if o == nil {
		return ""
	}
	return o.Code
}

func (o *OnboardingVerificationError) GetDetails() string {
	if o == nil {
		return ""
	}
	return o.Details
}

func (o *OnboardingVerificationError) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OnboardingVerificationError) UnmarshalJSON(data []byte) error {
	type unmarshaler OnboardingVerificationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OnboardingVerificationError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OnboardingVerificationError) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OnboardingVerificationStatusEnum string

const (
	OnboardingVerificationStatusEnumEnabled  OnboardingVerificationStatusEnum = "enabled"
	OnboardingVerificationStatusEnumDisabled OnboardingVerificationStatusEnum = "disabled"
	OnboardingVerificationStatusEnumPending  OnboardingVerificationStatusEnum = "pending"
)

func NewOnboardingVerificationStatusEnumFromString(s string) (OnboardingVerificationStatusEnum, error) {
	switch s {
	case "enabled":
		return OnboardingVerificationStatusEnumEnabled, nil
	case "disabled":
		return OnboardingVerificationStatusEnumDisabled, nil
	case "pending":
		return OnboardingVerificationStatusEnumPending, nil
	}
	var t OnboardingVerificationStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OnboardingVerificationStatusEnum) Ptr() *OnboardingVerificationStatusEnum {
	return &o
}

// A schema contains metadata for an organization
type OrganizationSchema struct {
	// Business structure of the company
	BusinessStructure  *EntityBusinessStructure `json:"business_structure,omitempty" url:"business_structure,omitempty"`
	DirectorsProvided  *bool                    `json:"directors_provided,omitempty" url:"directors_provided,omitempty"`
	ExecutivesProvided *bool                    `json:"executives_provided,omitempty" url:"executives_provided,omitempty"`
	// A code which identifies uniquely a party of a transaction worldwide
	LegalEntityId *string `json:"legal_entity_id,omitempty" url:"legal_entity_id,omitempty"`
	// The legal name of the organization. If this organization will use Monite payment rails, this name must be up to 100 characters long, otherwise it can be up to 255 characters long.
	LegalName              string `json:"legal_name" url:"legal_name"`
	OwnersProvided         *bool  `json:"owners_provided,omitempty" url:"owners_provided,omitempty"`
	RepresentativeProvided *bool  `json:"representative_provided,omitempty" url:"representative_provided,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrganizationSchema) GetBusinessStructure() *EntityBusinessStructure {
	if o == nil {
		return nil
	}
	return o.BusinessStructure
}

func (o *OrganizationSchema) GetDirectorsProvided() *bool {
	if o == nil {
		return nil
	}
	return o.DirectorsProvided
}

func (o *OrganizationSchema) GetExecutivesProvided() *bool {
	if o == nil {
		return nil
	}
	return o.ExecutivesProvided
}

func (o *OrganizationSchema) GetLegalEntityId() *string {
	if o == nil {
		return nil
	}
	return o.LegalEntityId
}

func (o *OrganizationSchema) GetLegalName() string {
	if o == nil {
		return ""
	}
	return o.LegalName
}

func (o *OrganizationSchema) GetOwnersProvided() *bool {
	if o == nil {
		return nil
	}
	return o.OwnersProvided
}

func (o *OrganizationSchema) GetRepresentativeProvided() *bool {
	if o == nil {
		return nil
	}
	return o.RepresentativeProvided
}

func (o *OrganizationSchema) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationSchema(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrganizationSchema) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PaymentMethodRequirements struct {
	CurrentDeadline     *time.Time `json:"current_deadline,omitempty" url:"current_deadline,omitempty"`
	CurrentlyDue        []string   `json:"currently_due" url:"currently_due"`
	EventuallyDue       []string   `json:"eventually_due" url:"eventually_due"`
	PastDue             []string   `json:"past_due" url:"past_due"`
	PendingVerification []string   `json:"pending_verification" url:"pending_verification"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentMethodRequirements) GetCurrentDeadline() *time.Time {
	if p == nil {
		return nil
	}
	return p.CurrentDeadline
}

func (p *PaymentMethodRequirements) GetCurrentlyDue() []string {
	if p == nil {
		return nil
	}
	return p.CurrentlyDue
}

func (p *PaymentMethodRequirements) GetEventuallyDue() []string {
	if p == nil {
		return nil
	}
	return p.EventuallyDue
}

func (p *PaymentMethodRequirements) GetPastDue() []string {
	if p == nil {
		return nil
	}
	return p.PastDue
}

func (p *PaymentMethodRequirements) GetPendingVerification() []string {
	if p == nil {
		return nil
	}
	return p.PendingVerification
}

func (p *PaymentMethodRequirements) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodRequirements) UnmarshalJSON(data []byte) error {
	type embed PaymentMethodRequirements
	var unmarshaler = struct {
		embed
		CurrentDeadline *internal.DateTime `json:"current_deadline,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentMethodRequirements(unmarshaler.embed)
	p.CurrentDeadline = unmarshaler.CurrentDeadline.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodRequirements) MarshalJSON() ([]byte, error) {
	type embed PaymentMethodRequirements
	var marshaler = struct {
		embed
		CurrentDeadline *internal.DateTime `json:"current_deadline,omitempty"`
	}{
		embed:           embed(*p),
		CurrentDeadline: internal.NewOptionalDateTime(p.CurrentDeadline),
	}
	return json.Marshal(marshaler)
}

func (p *PaymentMethodRequirements) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentPriorityEnum string

const (
	PaymentPriorityEnumWorkingCapital PaymentPriorityEnum = "working_capital"
	PaymentPriorityEnumBalanced       PaymentPriorityEnum = "balanced"
	PaymentPriorityEnumBottomLine     PaymentPriorityEnum = "bottom_line"
)

func NewPaymentPriorityEnumFromString(s string) (PaymentPriorityEnum, error) {
	switch s {
	case "working_capital":
		return PaymentPriorityEnumWorkingCapital, nil
	case "balanced":
		return PaymentPriorityEnumBalanced, nil
	case "bottom_line":
		return PaymentPriorityEnumBottomLine, nil
	}
	var t PaymentPriorityEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentPriorityEnum) Ptr() *PaymentPriorityEnum {
	return &p
}

type ReceivableEditFlow string

const (
	ReceivableEditFlowCompliant          ReceivableEditFlow = "compliant"
	ReceivableEditFlowPartiallyCompliant ReceivableEditFlow = "partially_compliant"
	ReceivableEditFlowNonCompliant       ReceivableEditFlow = "non_compliant"
)

func NewReceivableEditFlowFromString(s string) (ReceivableEditFlow, error) {
	switch s {
	case "compliant":
		return ReceivableEditFlowCompliant, nil
	case "partially_compliant":
		return ReceivableEditFlowPartiallyCompliant, nil
	case "non_compliant":
		return ReceivableEditFlowNonCompliant, nil
	}
	var t ReceivableEditFlow
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ReceivableEditFlow) Ptr() *ReceivableEditFlow {
	return &r
}

type RemindersSettings struct {
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemindersSettings) GetEnabled() *bool {
	if r == nil {
		return nil
	}
	return r.Enabled
}

func (r *RemindersSettings) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemindersSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler RemindersSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemindersSettings(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemindersSettings) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SettingsResponse struct {
	Language *LanguageCodeEnum       `json:"language,omitempty" url:"language,omitempty"`
	Currency *CurrencySettingsOutput `json:"currency,omitempty" url:"currency,omitempty"`
	Reminder *RemindersSettings      `json:"reminder,omitempty" url:"reminder,omitempty"`
	// Defines whether the prices of products in receivables will already include VAT or not.
	VatMode *VatModeEnum `json:"vat_mode,omitempty" url:"vat_mode,omitempty"`
	// Payment preferences for entity to automate calculating suggested payment date based on payment terms and entity preferences.
	PaymentPriority *PaymentPriorityEnum `json:"payment_priority,omitempty" url:"payment_priority,omitempty"`
	// Automatically attempt to find a corresponding purchase order for all incoming payables.
	AllowPurchaseOrderAutolinking *bool                `json:"allow_purchase_order_autolinking,omitempty" url:"allow_purchase_order_autolinking,omitempty"`
	ReceivableEditFlow            *ReceivableEditFlow  `json:"receivable_edit_flow,omitempty" url:"receivable_edit_flow,omitempty"`
	DocumentIds                   *DocumentIDsSettings `json:"document_ids,omitempty" url:"document_ids,omitempty"`
	// Auto tagging settings for all incoming OCR payable documents.
	PayablesOcrAutoTagging []*OcrAutoTaggingSettingsRequest `json:"payables_ocr_auto_tagging,omitempty" url:"payables_ocr_auto_tagging,omitempty"`
	// Sets the default behavior of whether a signature is required to accept quotes.
	QuoteSignatureRequired *bool `json:"quote_signature_required,omitempty" url:"quote_signature_required,omitempty"`
	// If enabled, the paid invoice's PDF will be in a new layout set by the user.
	GeneratePaidInvoicePdf *bool               `json:"generate_paid_invoice_pdf,omitempty" url:"generate_paid_invoice_pdf,omitempty"`
	Accounting             *AccountingSettings `json:"accounting,omitempty" url:"accounting,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SettingsResponse) GetLanguage() *LanguageCodeEnum {
	if s == nil {
		return nil
	}
	return s.Language
}

func (s *SettingsResponse) GetCurrency() *CurrencySettingsOutput {
	if s == nil {
		return nil
	}
	return s.Currency
}

func (s *SettingsResponse) GetReminder() *RemindersSettings {
	if s == nil {
		return nil
	}
	return s.Reminder
}

func (s *SettingsResponse) GetVatMode() *VatModeEnum {
	if s == nil {
		return nil
	}
	return s.VatMode
}

func (s *SettingsResponse) GetPaymentPriority() *PaymentPriorityEnum {
	if s == nil {
		return nil
	}
	return s.PaymentPriority
}

func (s *SettingsResponse) GetAllowPurchaseOrderAutolinking() *bool {
	if s == nil {
		return nil
	}
	return s.AllowPurchaseOrderAutolinking
}

func (s *SettingsResponse) GetReceivableEditFlow() *ReceivableEditFlow {
	if s == nil {
		return nil
	}
	return s.ReceivableEditFlow
}

func (s *SettingsResponse) GetDocumentIds() *DocumentIDsSettings {
	if s == nil {
		return nil
	}
	return s.DocumentIds
}

func (s *SettingsResponse) GetPayablesOcrAutoTagging() []*OcrAutoTaggingSettingsRequest {
	if s == nil {
		return nil
	}
	return s.PayablesOcrAutoTagging
}

func (s *SettingsResponse) GetQuoteSignatureRequired() *bool {
	if s == nil {
		return nil
	}
	return s.QuoteSignatureRequired
}

func (s *SettingsResponse) GetGeneratePaidInvoicePdf() *bool {
	if s == nil {
		return nil
	}
	return s.GeneratePaidInvoicePdf
}

func (s *SettingsResponse) GetAccounting() *AccountingSettings {
	if s == nil {
		return nil
	}
	return s.Accounting
}

func (s *SettingsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SettingsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SettingsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SettingsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SettingsResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleOnboardingRequirementsResponse struct {
	DisabledReason     *string                          `json:"disabled_reason,omitempty" url:"disabled_reason,omitempty"`
	PaymentMethod      string                           `json:"payment_method" url:"payment_method"`
	Requirements       *PaymentMethodRequirements       `json:"requirements" url:"requirements"`
	RequirementsErrors []*OnboardingRequirementsError   `json:"requirements_errors" url:"requirements_errors"`
	VerificationErrors []*OnboardingVerificationError   `json:"verification_errors" url:"verification_errors"`
	VerificationStatus OnboardingVerificationStatusEnum `json:"verification_status" url:"verification_status"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SingleOnboardingRequirementsResponse) GetDisabledReason() *string {
	if s == nil {
		return nil
	}
	return s.DisabledReason
}

func (s *SingleOnboardingRequirementsResponse) GetPaymentMethod() string {
	if s == nil {
		return ""
	}
	return s.PaymentMethod
}

func (s *SingleOnboardingRequirementsResponse) GetRequirements() *PaymentMethodRequirements {
	if s == nil {
		return nil
	}
	return s.Requirements
}

func (s *SingleOnboardingRequirementsResponse) GetRequirementsErrors() []*OnboardingRequirementsError {
	if s == nil {
		return nil
	}
	return s.RequirementsErrors
}

func (s *SingleOnboardingRequirementsResponse) GetVerificationErrors() []*OnboardingVerificationError {
	if s == nil {
		return nil
	}
	return s.VerificationErrors
}

func (s *SingleOnboardingRequirementsResponse) GetVerificationStatus() OnboardingVerificationStatusEnum {
	if s == nil {
		return ""
	}
	return s.VerificationStatus
}

func (s *SingleOnboardingRequirementsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleOnboardingRequirementsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleOnboardingRequirementsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleOnboardingRequirementsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleOnboardingRequirementsResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type PatchSettingsPayload struct {
	Language *LanguageCodeEnum      `json:"language,omitempty" url:"-"`
	Currency *CurrencySettingsInput `json:"currency,omitempty" url:"-"`
	Reminder *RemindersSettings     `json:"reminder,omitempty" url:"-"`
	// Defines whether the prices of products in receivables will already include VAT or not.
	VatMode *VatModeEnum `json:"vat_mode,omitempty" url:"-"`
	// Payment preferences for entity to automate calculating suggested payment date based on payment terms and entity preferences.
	PaymentPriority *PaymentPriorityEnum `json:"payment_priority,omitempty" url:"-"`
	// Automatically attempt to find a corresponding purchase order for all incoming payables.
	AllowPurchaseOrderAutolinking *bool                       `json:"allow_purchase_order_autolinking,omitempty" url:"-"`
	ReceivableEditFlow            *ReceivableEditFlow         `json:"receivable_edit_flow,omitempty" url:"-"`
	DocumentIds                   *DocumentIDsSettingsRequest `json:"document_ids,omitempty" url:"-"`
	// Auto tagging settings for all incoming OCR payable documents.
	PayablesOcrAutoTagging []*OcrAutoTaggingSettingsRequest `json:"payables_ocr_auto_tagging,omitempty" url:"-"`
	// Sets the default behavior of whether a signature is required to accept quotes.
	QuoteSignatureRequired *bool `json:"quote_signature_required,omitempty" url:"-"`
	// If enabled, the paid invoice's PDF will be in a new layout set by the user.
	GeneratePaidInvoicePdf *bool               `json:"generate_paid_invoice_pdf,omitempty" url:"-"`
	Accounting             *AccountingSettings `json:"accounting,omitempty" url:"-"`
}

type EntityLogoUploadRequest struct {
	File io.Reader `json:"-" url:"-"`
}

type EntityOnboardingDocumentsPayload struct {
	AdditionalVerificationDocumentBack  *string  `json:"additional_verification_document_back,omitempty" url:"-"`
	AdditionalVerificationDocumentFront *string  `json:"additional_verification_document_front,omitempty" url:"-"`
	BankAccountOwnershipVerification    []string `json:"bank_account_ownership_verification,omitempty" url:"-"`
	CompanyLicense                      []string `json:"company_license,omitempty" url:"-"`
	CompanyMemorandumOfAssociation      []string `json:"company_memorandum_of_association,omitempty" url:"-"`
	CompanyMinisterialDecree            []string `json:"company_ministerial_decree,omitempty" url:"-"`
	CompanyRegistrationVerification     []string `json:"company_registration_verification,omitempty" url:"-"`
	CompanyTaxIdVerification            []string `json:"company_tax_id_verification,omitempty" url:"-"`
	ProofOfRegistration                 []string `json:"proof_of_registration,omitempty" url:"-"`
	VerificationDocumentBack            *string  `json:"verification_document_back,omitempty" url:"-"`
	VerificationDocumentFront           *string  `json:"verification_document_front,omitempty" url:"-"`
}
