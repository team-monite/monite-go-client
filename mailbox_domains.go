// This file was auto-generated by Fern from our API Definition.

package fluidstack

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/team-monite/monite-go-client/internal"
	time "time"
)

type DomainRequest struct {
	Domain string `json:"domain" url:"-"`
}

type DnsRecord struct {
	IsActive bool    `json:"is_active" url:"is_active"`
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	// Purpose of specific entry to distinguish between various TXT entries.
	RecordPurpose *DnsRecordPurpose `json:"record_purpose,omitempty" url:"record_purpose,omitempty"`
	RecordType    DnsRecordType     `json:"record_type" url:"record_type"`
	// Field reflecting validation status by Mailgun.
	Valid string `json:"valid" url:"valid"`
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DnsRecord) GetIsActive() bool {
	if d == nil {
		return false
	}
	return d.IsActive
}

func (d *DnsRecord) GetName() *string {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DnsRecord) GetRecordPurpose() *DnsRecordPurpose {
	if d == nil {
		return nil
	}
	return d.RecordPurpose
}

func (d *DnsRecord) GetRecordType() DnsRecordType {
	if d == nil {
		return ""
	}
	return d.RecordType
}

func (d *DnsRecord) GetValid() string {
	if d == nil {
		return ""
	}
	return d.Valid
}

func (d *DnsRecord) GetValue() string {
	if d == nil {
		return ""
	}
	return d.Value
}

func (d *DnsRecord) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DnsRecord) UnmarshalJSON(data []byte) error {
	type unmarshaler DnsRecord
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DnsRecord(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DnsRecord) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DnsRecordPurpose string

const (
	DnsRecordPurposeDkim DnsRecordPurpose = "DKIM"
	DnsRecordPurposeSpf  DnsRecordPurpose = "SPF"
)

func NewDnsRecordPurposeFromString(s string) (DnsRecordPurpose, error) {
	switch s {
	case "DKIM":
		return DnsRecordPurposeDkim, nil
	case "SPF":
		return DnsRecordPurposeSpf, nil
	}
	var t DnsRecordPurpose
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DnsRecordPurpose) Ptr() *DnsRecordPurpose {
	return &d
}

type DnsRecordType string

const (
	DnsRecordTypeTxt   DnsRecordType = "TXT"
	DnsRecordTypeMx    DnsRecordType = "MX"
	DnsRecordTypeCname DnsRecordType = "CNAME"
)

func NewDnsRecordTypeFromString(s string) (DnsRecordType, error) {
	switch s {
	case "TXT":
		return DnsRecordTypeTxt, nil
	case "MX":
		return DnsRecordTypeMx, nil
	case "CNAME":
		return DnsRecordTypeCname, nil
	}
	var t DnsRecordType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DnsRecordType) Ptr() *DnsRecordType {
	return &d
}

type DnsRecords struct {
	// Set of DNS settings required by Mailgun for domain verification before emails receiving is possible.
	ReceivingDnsRecords []*DnsRecord `json:"receiving_dns_records" url:"receiving_dns_records"`
	// Set of DNS settings required by Mailgun for domain verification before emails sending is possible.
	SendingDnsRecords []*DnsRecord `json:"sending_dns_records" url:"sending_dns_records"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DnsRecords) GetReceivingDnsRecords() []*DnsRecord {
	if d == nil {
		return nil
	}
	return d.ReceivingDnsRecords
}

func (d *DnsRecords) GetSendingDnsRecords() []*DnsRecord {
	if d == nil {
		return nil
	}
	return d.SendingDnsRecords
}

func (d *DnsRecords) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DnsRecords) UnmarshalJSON(data []byte) error {
	type unmarshaler DnsRecords
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DnsRecords(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DnsRecords) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DomainListResponse struct {
	Data []*DomainResponse `json:"data" url:"data"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DomainListResponse) GetData() []*DomainResponse {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DomainListResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DomainListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DomainListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DomainListResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DomainListResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DomainResponse struct {
	// Entry UUID
	Id string `json:"id" url:"id"`
	// A dedicated IP address assigned to this mailbox and used to send outgoing email.
	DedicatedIp *string                   `json:"dedicated_ip,omitempty" url:"dedicated_ip,omitempty"`
	DnsRecords  *DomainResponseDnsRecords `json:"dns_records" url:"dns_records"`
	Domain      string                    `json:"domain" url:"domain"`
	// The time the domain was updated for the last time
	LastUpdatedAt *time.Time `json:"last_updated_at,omitempty" url:"last_updated_at,omitempty"`
	Status        string     `json:"status" url:"status"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DomainResponse) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DomainResponse) GetDedicatedIp() *string {
	if d == nil {
		return nil
	}
	return d.DedicatedIp
}

func (d *DomainResponse) GetDnsRecords() *DomainResponseDnsRecords {
	if d == nil {
		return nil
	}
	return d.DnsRecords
}

func (d *DomainResponse) GetDomain() string {
	if d == nil {
		return ""
	}
	return d.Domain
}

func (d *DomainResponse) GetLastUpdatedAt() *time.Time {
	if d == nil {
		return nil
	}
	return d.LastUpdatedAt
}

func (d *DomainResponse) GetStatus() string {
	if d == nil {
		return ""
	}
	return d.Status
}

func (d *DomainResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DomainResponse) UnmarshalJSON(data []byte) error {
	type embed DomainResponse
	var unmarshaler = struct {
		embed
		LastUpdatedAt *internal.DateTime `json:"last_updated_at,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DomainResponse(unmarshaler.embed)
	d.LastUpdatedAt = unmarshaler.LastUpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DomainResponse) MarshalJSON() ([]byte, error) {
	type embed DomainResponse
	var marshaler = struct {
		embed
		LastUpdatedAt *internal.DateTime `json:"last_updated_at,omitempty"`
	}{
		embed:         embed(*d),
		LastUpdatedAt: internal.NewOptionalDateTime(d.LastUpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (d *DomainResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DomainResponseDnsRecords struct {
	DnsRecords       *DnsRecords
	StringUnknownMap map[string]interface{}

	typ string
}

func (d *DomainResponseDnsRecords) GetDnsRecords() *DnsRecords {
	if d == nil {
		return nil
	}
	return d.DnsRecords
}

func (d *DomainResponseDnsRecords) GetStringUnknownMap() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.StringUnknownMap
}

func (d *DomainResponseDnsRecords) UnmarshalJSON(data []byte) error {
	valueDnsRecords := new(DnsRecords)
	if err := json.Unmarshal(data, &valueDnsRecords); err == nil {
		d.typ = "DnsRecords"
		d.DnsRecords = valueDnsRecords
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		d.typ = "StringUnknownMap"
		d.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DomainResponseDnsRecords) MarshalJSON() ([]byte, error) {
	if d.typ == "DnsRecords" || d.DnsRecords != nil {
		return json.Marshal(d.DnsRecords)
	}
	if d.typ == "StringUnknownMap" || d.StringUnknownMap != nil {
		return json.Marshal(d.StringUnknownMap)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DomainResponseDnsRecordsVisitor interface {
	VisitDnsRecords(*DnsRecords) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (d *DomainResponseDnsRecords) Accept(visitor DomainResponseDnsRecordsVisitor) error {
	if d.typ == "DnsRecords" || d.DnsRecords != nil {
		return visitor.VisitDnsRecords(d.DnsRecords)
	}
	if d.typ == "StringUnknownMap" || d.StringUnknownMap != nil {
		return visitor.VisitStringUnknownMap(d.StringUnknownMap)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type VerifyResponse struct {
	// Entry UUID
	Id     string `json:"id" url:"id"`
	Domain string `json:"domain" url:"domain"`
	Status string `json:"status" url:"status"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VerifyResponse) GetId() string {
	if v == nil {
		return ""
	}
	return v.Id
}

func (v *VerifyResponse) GetDomain() string {
	if v == nil {
		return ""
	}
	return v.Domain
}

func (v *VerifyResponse) GetStatus() string {
	if v == nil {
		return ""
	}
	return v.Status
}

func (v *VerifyResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VerifyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VerifyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerifyResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VerifyResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}
