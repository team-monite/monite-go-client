// This file was auto-generated by Fern from our API Definition.

package fluidstack

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/team-monite/monite-go-client/internal"
	io "io"
	time "time"
)

type PayableAttachFile struct {
	File io.Reader `json:"-" url:"-"`
}

type PayableUploadWithDataSchema struct {
	// Base64-encoded contents of the original issued payable. The file is provided for reference purposes as the original source of the data.
	//
	//	Any file formats are allowed. The most common formats are PDF, PNG, JPEG, TIFF.
	Base64EncodedFile *string `json:"base64_encoded_file,omitempty" url:"-"`
	// The ID of counterpart address object stored in counterparts service
	CounterpartAddressId *string `json:"counterpart_address_id,omitempty" url:"-"`
	// The ID of counterpart bank account object stored in counterparts service
	CounterpartBankAccountId *string `json:"counterpart_bank_account_id,omitempty" url:"-"`
	// The ID of the counterpart object that represents the vendor or supplier.
	CounterpartId *string `json:"counterpart_id,omitempty" url:"-"`
	// The ID of counterpart VAT ID object stored in counterparts service
	CounterpartVatIdId *string `json:"counterpart_vat_id_id,omitempty" url:"-"`
	// The [currency code](https://docs.monite.com/references/currencies) of the currency used in the payable.
	Currency *CurrencyEnum `json:"currency,omitempty" url:"-"`
	// An arbitrary description of this payable.
	Description *string `json:"description,omitempty" url:"-"`
	// The value of the additional discount that will be applied to the total amount. in [minor units](https://docs.monite.com/references/currencies#minor-units). For example, $12.50 is represented as 1250.
	Discount *int `json:"discount,omitempty" url:"-"`
	// A unique invoice number assigned by the invoice issuer for payment tracking purposes.
	DocumentId *string `json:"document_id,omitempty" url:"-"`
	// The date by which the payable must be paid, in the YYYY-MM-DD format. If the payable specifies payment terms with early payment discounts, this is the final payment date.
	DueDate *string `json:"due_date,omitempty" url:"-"`
	// The original file name.
	FileName *string `json:"file_name,omitempty" url:"-"`
	// The date when the payable was issued, in the YYYY-MM-DD format.
	IssuedAt *string `json:"issued_at,omitempty" url:"-"`
	// Metadata for partner needs
	PartnerMetadata map[string]interface{} `json:"partner_metadata,omitempty" url:"-"`
	// The number of days to pay with potential discount for options shorter than due_date
	PaymentTerms *PayablePaymentTermsCreatePayload `json:"payment_terms,omitempty" url:"-"`
	// The ID of a project
	ProjectId *string `json:"project_id,omitempty" url:"-"`
	// The identifier of the purchase order to which this payable belongs.
	PurchaseOrderId *string `json:"purchase_order_id,omitempty" url:"-"`
	// The email address from which the invoice was sent to the entity.
	Sender *string `json:"sender,omitempty" url:"-"`
	// The subtotal amount to be paid, in [minor units](https://docs.monite.com/references/currencies#minor-units). For example, $12.50 is represented as 1250.
	Subtotal *int `json:"subtotal,omitempty" url:"-"`
	// The suggested date and corresponding discount in which payable could be paid. The date is in the YYYY-MM-DD format. The discount is calculated as X * (10^-4) - for example, 100 is 1%, 25 is 0,25%, 10000 is 100 %. Date varies depending on the payment terms and may even be equal to the due date with discount 0.
	SuggestedPaymentTerm *SuggestedPaymentTerm `json:"suggested_payment_term,omitempty" url:"-"`
	// A list of IDs of user-defined tags (labels) assigned to this payable. Tags can be used to trigger a specific approval policy for this payable.
	TagIds []string `json:"tag_ids,omitempty" url:"-"`
	// Registered tax percentage applied for a service price in minor units, e.g. 200 means 2%. 1050 means 10.5%.
	Tax *int `json:"tax,omitempty" url:"-"`
	// Tax amount in [minor units](https://docs.monite.com/references/currencies#minor-units). For example, $12.50 is represented as 1250.
	TaxAmount *int `json:"tax_amount,omitempty" url:"-"`
	// The total amount to be paid, in [minor units](https://docs.monite.com/references/currencies#minor-units). For example, $12.50 is represented as 1250.
	TotalAmount *int `json:"total_amount,omitempty" url:"-"`
}

type PayablesGetRequest struct {
	// Sort order (ascending by default). Typically used together with the `sort` parameter.
	Order *OrderEnum `json:"-" url:"order,omitempty"`
	// The number of items (0 .. 100) to return in a single page of the response. The response may contain fewer items if it is the last or only page.
	Limit *int `json:"-" url:"limit,omitempty"`
	// A pagination token obtained from a previous call to this endpoint. Use it to get the next or previous page of results for your initial query. If `pagination_token` is specified, all other query parameters are ignored and inferred from the initial query.
	//
	// If not specified, the first page of results will be returned.
	PaginationToken *string `json:"-" url:"pagination_token,omitempty"`
	// The field to sort the results by. Typically used together with the `order` parameter.
	Sort *PayableCursorFields `json:"-" url:"sort,omitempty"`
	// Return only payables created in Monite after the specified date and time. The value must be in the ISO 8601 format YYYY-MM-DDThh:mm[:ss[.ffffff]][Z|±hh:mm].
	CreatedAtGt *time.Time `json:"-" url:"created_at__gt,omitempty"`
	// Return only payables created in Monite before the specified date and time.
	CreatedAtLt *time.Time `json:"-" url:"created_at__lt,omitempty"`
	// Return only payables created in Monite on or after the specified date and time.
	CreatedAtGte *time.Time `json:"-" url:"created_at__gte,omitempty"`
	// Return only payables created in Monite before or on the specified date and time.
	CreatedAtLte *time.Time `json:"-" url:"created_at__lte,omitempty"`
	// Return only payables that have the specified [status](https://docs.monite.com/accounts-payable/payables/index).
	//
	// To query multiple statuses at once, use the `status__in` parameter instead.
	Status *PayableStateEnum `json:"-" url:"status,omitempty"`
	// Return only payables that have the specified [statuses](https://docs.monite.com/accounts-payable/payables/index).
	//
	// To specify multiple statuses, repeat this parameter for each value: `status__in=draft&status__in=new`
	StatusIn []*PayableStateEnum `json:"-" url:"status__in,omitempty"`
	// Return only payables with specified IDs. Valid but nonexistent IDs do not raise errors but produce no results.
	//
	// To specify multiple IDs, repeat this parameter for each value: `id__in=<id1>&id__in=<id2>`
	IdIn []*string `json:"-" url:"id__in,omitempty"`
	// Return only payables with the exact specified total amount. The amount must be specified in the minor units of currency. For example, $12.5 is represented as 1250.
	TotalAmount *int `json:"-" url:"total_amount,omitempty"`
	// Return only payables whose total amount (in minor units) exceeds the specified value.
	TotalAmountGt *int `json:"-" url:"total_amount__gt,omitempty"`
	// Return only payables whose total amount (in minor units) is less than the specified value.
	TotalAmountLt *int `json:"-" url:"total_amount__lt,omitempty"`
	// Return only payables whose total amount (in minor units) is greater than or equal to the specified value.
	TotalAmountGte *int `json:"-" url:"total_amount__gte,omitempty"`
	// Return only payables whose total amount (in minor units) is less than or equal to the specified value.
	TotalAmountLte *int `json:"-" url:"total_amount__lte,omitempty"`
	// Return only payables with the specified amount.
	Amount *int `json:"-" url:"amount,omitempty"`
	// Return only payables whose amount (in minor units) exceeds the specified value.
	AmountGt *int `json:"-" url:"amount__gt,omitempty"`
	// Return only payables whose amount (in minor units) is less than the specified value.
	AmountLt *int `json:"-" url:"amount__lt,omitempty"`
	// Return only payables whose amount (in minor units) is greater than or equal to the specified value.
	AmountGte *int `json:"-" url:"amount__gte,omitempty"`
	// Return only payables whose amount (in minor units) is less than or equal to the specified value.
	AmountLte *int `json:"-" url:"amount__lte,omitempty"`
	// Return only payables that use the specified currency.
	Currency *CurrencyEnum `json:"-" url:"currency,omitempty"`
	// Return only payables received from counterparts with the specified name (exact match, case-sensitive).
	//
	// For counterparts of `type = individual`, the full name is formatted as `first_name last_name`.
	CounterpartName *string `json:"-" url:"counterpart_name,omitempty"`
	// Return only payables received from counterparts whose name contains the specified string (case-sensitive).
	CounterpartNameContains *string `json:"-" url:"counterpart_name__contains,omitempty"`
	// Return only payables received from counterparts whose name contains the specified string (case-insensitive).
	CounterpartNameIcontains *string `json:"-" url:"counterpart_name__icontains,omitempty"`
	// Apply the `icontains` condition to search for the specified text in the `document_id` and `counterpart_name` fields in the payables.
	SearchText *string `json:"-" url:"search_text,omitempty"`
	// Return payables that are due on the specified date (YYYY-MM-DD)
	DueDate *string `json:"-" url:"due_date,omitempty"`
	// Return payables that are due after the specified date (exclusive, YYYY-MM-DD).
	DueDateGt *string `json:"-" url:"due_date__gt,omitempty"`
	// Return payables that are due before the specified date (exclusive, YYYY-MM-DD).
	DueDateLt *string `json:"-" url:"due_date__lt,omitempty"`
	// Return payables that are due on or after the specified date (YYYY-MM-DD).
	DueDateGte *string `json:"-" url:"due_date__gte,omitempty"`
	// Return payables that are due before or on the specified date (YYYY-MM-DD).
	DueDateLte *string `json:"-" url:"due_date__lte,omitempty"`
	// Return a payable with the exact specified document number (case-sensitive).
	//
	// The `document_id` is the user-facing document number such as INV-00042, not to be confused with Monite resource IDs (`id`).
	DocumentId *string `json:"-" url:"document_id,omitempty"`
	// Return only payables whose document number (`document_id`) contains the specified string (case-sensitive).
	DocumentIdContains *string `json:"-" url:"document_id__contains,omitempty"`
	// Return only payables whose document number (`document_id`) contains the specified string (case-insensitive).
	DocumentIdIcontains *string `json:"-" url:"document_id__icontains,omitempty"`
	// Return only payables created in Monite by the entity user with the specified ID.
	WasCreatedByUserId *string `json:"-" url:"was_created_by_user_id,omitempty"`
	// Return only payables received from the counterpart with the specified ID.
	//
	// Counterparts that have been deleted but have associated payables will still return results here because the payables contain a frozen copy of the counterpart data.
	//
	// If the specified counterpart ID does not exist and never existed, no results are returned.
	CounterpartId *string `json:"-" url:"counterpart_id,omitempty"`
	// Return only payables coming from the specified source.
	SourceOfPayableData *SourceOfPayableDataEnum `json:"-" url:"source_of_payable_data,omitempty"`
	// Return only payables with specific OCR statuses.
	OcrStatus *OcrStatusEnum `json:"-" url:"ocr_status,omitempty"`
	// Search for a payable by the identifier of the line item associated with it.
	LineItemId *string `json:"-" url:"line_item_id,omitempty"`
	// Search for a payable by the identifier of the purchase order associated with it.
	PurchaseOrderId *string `json:"-" url:"purchase_order_id,omitempty"`
	// Return only payables assigned to the project with the specified ID.
	//
	// Valid but nonexistent project IDs do not raise errors but return no results.
	ProjectId *string `json:"-" url:"project_id,omitempty"`
	// Return only payables whose `tags` include at least one of the tags with the specified IDs. Valid but nonexistent tag IDs do not raise errors but produce no results.
	TagIds []*string `json:"-" url:"tag_ids,omitempty"`
}

type PayablesGetAnalyticsRequest struct {
	// Return only payables created in Monite after the specified date and time. The value must be in the ISO 8601 format YYYY-MM-DDThh:mm[:ss[.ffffff]][Z|±hh:mm].
	CreatedAtGt *time.Time `json:"-" url:"created_at__gt,omitempty"`
	// Return only payables created in Monite before the specified date and time.
	CreatedAtLt *time.Time `json:"-" url:"created_at__lt,omitempty"`
	// Return only payables created in Monite on or after the specified date and time.
	CreatedAtGte *time.Time `json:"-" url:"created_at__gte,omitempty"`
	// Return only payables created in Monite before or on the specified date and time.
	CreatedAtLte *time.Time `json:"-" url:"created_at__lte,omitempty"`
	// Return only payables that have the specified [status](https://docs.monite.com/accounts-payable/payables/index).
	//
	// To query multiple statuses at once, use the `status__in` parameter instead.
	Status *PayableStateEnum `json:"-" url:"status,omitempty"`
	// Return only payables that have the specified [statuses](https://docs.monite.com/accounts-payable/payables/index).
	//
	// To specify multiple statuses, repeat this parameter for each value: `status__in=draft&status__in=new`
	StatusIn []*PayableStateEnum `json:"-" url:"status__in,omitempty"`
	// Return only payables with specified IDs. Valid but nonexistent IDs do not raise errors but produce no results.
	//
	// To specify multiple IDs, repeat this parameter for each value: `id__in=<id1>&id__in=<id2>`
	IdIn []*string `json:"-" url:"id__in,omitempty"`
	// Return only payables with the exact specified total amount. The amount must be specified in the minor units of currency. For example, $12.5 is represented as 1250.
	TotalAmount *int `json:"-" url:"total_amount,omitempty"`
	// Return only payables whose total amount (in minor units) exceeds the specified value.
	TotalAmountGt *int `json:"-" url:"total_amount__gt,omitempty"`
	// Return only payables whose total amount (in minor units) is less than the specified value.
	TotalAmountLt *int `json:"-" url:"total_amount__lt,omitempty"`
	// Return only payables whose total amount (in minor units) is greater than or equal to the specified value.
	TotalAmountGte *int `json:"-" url:"total_amount__gte,omitempty"`
	// Return only payables whose total amount (in minor units) is less than or equal to the specified value.
	TotalAmountLte *int `json:"-" url:"total_amount__lte,omitempty"`
	// Return only payables with the specified amount.
	Amount *int `json:"-" url:"amount,omitempty"`
	// Return only payables whose amount (in minor units) exceeds the specified value.
	AmountGt *int `json:"-" url:"amount__gt,omitempty"`
	// Return only payables whose amount (in minor units) is less than the specified value.
	AmountLt *int `json:"-" url:"amount__lt,omitempty"`
	// Return only payables whose amount (in minor units) is greater than or equal to the specified value.
	AmountGte *int `json:"-" url:"amount__gte,omitempty"`
	// Return only payables whose amount (in minor units) is less than or equal to the specified value.
	AmountLte *int `json:"-" url:"amount__lte,omitempty"`
	// Return only payables that use the specified currency.
	Currency *CurrencyEnum `json:"-" url:"currency,omitempty"`
	// Return only payables received from counterparts with the specified name (exact match, case-sensitive).
	//
	// For counterparts of `type = individual`, the full name is formatted as `first_name last_name`.
	CounterpartName *string `json:"-" url:"counterpart_name,omitempty"`
	// Return only payables received from counterparts whose name contains the specified string (case-sensitive).
	CounterpartNameContains *string `json:"-" url:"counterpart_name__contains,omitempty"`
	// Return only payables received from counterparts whose name contains the specified string (case-insensitive).
	CounterpartNameIcontains *string `json:"-" url:"counterpart_name__icontains,omitempty"`
	// Apply the `icontains` condition to search for the specified text in the `document_id` and `counterpart_name` fields in the payables.
	SearchText *string `json:"-" url:"search_text,omitempty"`
	// Return payables that are due on the specified date (YYYY-MM-DD)
	DueDate *string `json:"-" url:"due_date,omitempty"`
	// Return payables that are due after the specified date (exclusive, YYYY-MM-DD).
	DueDateGt *string `json:"-" url:"due_date__gt,omitempty"`
	// Return payables that are due before the specified date (exclusive, YYYY-MM-DD).
	DueDateLt *string `json:"-" url:"due_date__lt,omitempty"`
	// Return payables that are due on or after the specified date (YYYY-MM-DD).
	DueDateGte *string `json:"-" url:"due_date__gte,omitempty"`
	// Return payables that are due before or on the specified date (YYYY-MM-DD).
	DueDateLte *string `json:"-" url:"due_date__lte,omitempty"`
	// Return a payable with the exact specified document number (case-sensitive).
	//
	// The `document_id` is the user-facing document number such as INV-00042, not to be confused with Monite resource IDs (`id`).
	DocumentId *string `json:"-" url:"document_id,omitempty"`
	// Return only payables whose document number (`document_id`) contains the specified string (case-sensitive).
	DocumentIdContains *string `json:"-" url:"document_id__contains,omitempty"`
	// Return only payables whose document number (`document_id`) contains the specified string (case-insensitive).
	DocumentIdIcontains *string `json:"-" url:"document_id__icontains,omitempty"`
	// Return only payables created in Monite by the entity user with the specified ID.
	WasCreatedByUserId *string `json:"-" url:"was_created_by_user_id,omitempty"`
	// Return only payables received from the counterpart with the specified ID.
	//
	// Counterparts that have been deleted but have associated payables will still return results here because the payables contain a frozen copy of the counterpart data.
	//
	// If the specified counterpart ID does not exist and never existed, no results are returned.
	CounterpartId *string `json:"-" url:"counterpart_id,omitempty"`
	// Return only payables coming from the specified source.
	SourceOfPayableData *SourceOfPayableDataEnum `json:"-" url:"source_of_payable_data,omitempty"`
	// Return only payables with specific OCR statuses.
	OcrStatus *OcrStatusEnum `json:"-" url:"ocr_status,omitempty"`
	// Search for a payable by the identifier of the line item associated with it.
	LineItemId *string `json:"-" url:"line_item_id,omitempty"`
	// Search for a payable by the identifier of the purchase order associated with it.
	PurchaseOrderId *string `json:"-" url:"purchase_order_id,omitempty"`
	// Return only payables assigned to the project with the specified ID.
	//
	// Valid but nonexistent project IDs do not raise errors but return no results.
	ProjectId *string `json:"-" url:"project_id,omitempty"`
	// Return only payables whose `tags` include at least one of the tags with the specified IDs. Valid but nonexistent tag IDs do not raise errors but produce no results.
	TagIds []*string `json:"-" url:"tag_ids,omitempty"`
}

type CommentPayload struct {
	// An arbitrary comment that describes how and when this payable was paid.
	Comment *string `json:"comment,omitempty" url:"-"`
}

type PartiallyPaidPayload struct {
	// How much was paid on the invoice (in minor units).
	AmountPaid int `json:"amount_paid" url:"-"`
}

// Address information.
type CounterpartRawAddress struct {
	// City name.
	City *string `json:"city,omitempty" url:"city,omitempty"`
	// Two-letter ISO country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
	Country *AllowedCountries `json:"country,omitempty" url:"country,omitempty"`
	// Street address.
	Line1 *string `json:"line1,omitempty" url:"line1,omitempty"`
	// Additional address information (if any).
	Line2 *string `json:"line2,omitempty" url:"line2,omitempty"`
	// ZIP or postal code.
	PostalCode *string `json:"postal_code,omitempty" url:"postal_code,omitempty"`
	// State, region, province, or county.
	State *string `json:"state,omitempty" url:"state,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartRawAddress) GetCity() *string {
	if c == nil {
		return nil
	}
	return c.City
}

func (c *CounterpartRawAddress) GetCountry() *AllowedCountries {
	if c == nil {
		return nil
	}
	return c.Country
}

func (c *CounterpartRawAddress) GetLine1() *string {
	if c == nil {
		return nil
	}
	return c.Line1
}

func (c *CounterpartRawAddress) GetLine2() *string {
	if c == nil {
		return nil
	}
	return c.Line2
}

func (c *CounterpartRawAddress) GetPostalCode() *string {
	if c == nil {
		return nil
	}
	return c.PostalCode
}

func (c *CounterpartRawAddress) GetState() *string {
	if c == nil {
		return nil
	}
	return c.State
}

func (c *CounterpartRawAddress) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartRawAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartRawAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartRawAddress(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartRawAddress) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Address information.
type CounterpartRawAddressUpdateRequest struct {
	// City name.
	City *string `json:"city,omitempty" url:"city,omitempty"`
	// Two-letter ISO country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
	Country *AllowedCountries `json:"country,omitempty" url:"country,omitempty"`
	// Street address.
	Line1 *string `json:"line1,omitempty" url:"line1,omitempty"`
	// Additional address information (if any).
	Line2 *string `json:"line2,omitempty" url:"line2,omitempty"`
	// ZIP or postal code.
	PostalCode *string `json:"postal_code,omitempty" url:"postal_code,omitempty"`
	// State, region, province, or county.
	State *string `json:"state,omitempty" url:"state,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartRawAddressUpdateRequest) GetCity() *string {
	if c == nil {
		return nil
	}
	return c.City
}

func (c *CounterpartRawAddressUpdateRequest) GetCountry() *AllowedCountries {
	if c == nil {
		return nil
	}
	return c.Country
}

func (c *CounterpartRawAddressUpdateRequest) GetLine1() *string {
	if c == nil {
		return nil
	}
	return c.Line1
}

func (c *CounterpartRawAddressUpdateRequest) GetLine2() *string {
	if c == nil {
		return nil
	}
	return c.Line2
}

func (c *CounterpartRawAddressUpdateRequest) GetPostalCode() *string {
	if c == nil {
		return nil
	}
	return c.PostalCode
}

func (c *CounterpartRawAddressUpdateRequest) GetState() *string {
	if c == nil {
		return nil
	}
	return c.State
}

func (c *CounterpartRawAddressUpdateRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartRawAddressUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartRawAddressUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartRawAddressUpdateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartRawAddressUpdateRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartRawBankAccount struct {
	// Vendor's bank account name.
	AccountHolderName *string `json:"account_holder_name,omitempty" url:"account_holder_name,omitempty"`
	// Vendor's bank account number, IBAN, or similar (if specified in the payable document).
	AccountNumber *string `json:"account_number,omitempty" url:"account_number,omitempty"`
	// SWIFT code (BIC) of the vendor's bank.
	Bic *string `json:"bic,omitempty" url:"bic,omitempty"`
	// required for non-GB bank accounts
	Iban *string `json:"iban,omitempty" url:"iban,omitempty"`
	// required for GB bank accounts
	SortCode *string `json:"sort_code,omitempty" url:"sort_code,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartRawBankAccount) GetAccountHolderName() *string {
	if c == nil {
		return nil
	}
	return c.AccountHolderName
}

func (c *CounterpartRawBankAccount) GetAccountNumber() *string {
	if c == nil {
		return nil
	}
	return c.AccountNumber
}

func (c *CounterpartRawBankAccount) GetBic() *string {
	if c == nil {
		return nil
	}
	return c.Bic
}

func (c *CounterpartRawBankAccount) GetIban() *string {
	if c == nil {
		return nil
	}
	return c.Iban
}

func (c *CounterpartRawBankAccount) GetSortCode() *string {
	if c == nil {
		return nil
	}
	return c.SortCode
}

func (c *CounterpartRawBankAccount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartRawBankAccount) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartRawBankAccount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartRawBankAccount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartRawBankAccount) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartRawBankAccountUpdateRequest struct {
	// Vendor's bank account name.
	AccountHolderName *string `json:"account_holder_name,omitempty" url:"account_holder_name,omitempty"`
	// Vendor's bank account number, IBAN, or similar (if specified in the payable document).
	AccountNumber *string `json:"account_number,omitempty" url:"account_number,omitempty"`
	// SWIFT code (BIC) of the vendor's bank.
	Bic *string `json:"bic,omitempty" url:"bic,omitempty"`
	// required for non-GB bank accounts
	Iban *string `json:"iban,omitempty" url:"iban,omitempty"`
	// required for GB bank accounts
	SortCode *string `json:"sort_code,omitempty" url:"sort_code,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartRawBankAccountUpdateRequest) GetAccountHolderName() *string {
	if c == nil {
		return nil
	}
	return c.AccountHolderName
}

func (c *CounterpartRawBankAccountUpdateRequest) GetAccountNumber() *string {
	if c == nil {
		return nil
	}
	return c.AccountNumber
}

func (c *CounterpartRawBankAccountUpdateRequest) GetBic() *string {
	if c == nil {
		return nil
	}
	return c.Bic
}

func (c *CounterpartRawBankAccountUpdateRequest) GetIban() *string {
	if c == nil {
		return nil
	}
	return c.Iban
}

func (c *CounterpartRawBankAccountUpdateRequest) GetSortCode() *string {
	if c == nil {
		return nil
	}
	return c.SortCode
}

func (c *CounterpartRawBankAccountUpdateRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartRawBankAccountUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartRawBankAccountUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartRawBankAccountUpdateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartRawBankAccountUpdateRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartRawData struct {
	// The address of the vendor or supplier.
	Address *CounterpartRawAddress `json:"address,omitempty" url:"address,omitempty"`
	// Object representing counterpart bank account.
	BankAccount *CounterpartRawBankAccount `json:"bank_account,omitempty" url:"bank_account,omitempty"`
	// The email address of the organization
	Email *string `json:"email,omitempty" url:"email,omitempty"`
	// Vendor or supplier name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The phone number of the organization
	Phone *string `json:"phone,omitempty" url:"phone,omitempty"`
	// The tax id of the counterpart.
	TaxId *string `json:"tax_id,omitempty" url:"tax_id,omitempty"`
	// VAT ID of the vendor or supplier which was used in the invoice.
	VatId *CounterpartRawVatId `json:"vat_id,omitempty" url:"vat_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartRawData) GetAddress() *CounterpartRawAddress {
	if c == nil {
		return nil
	}
	return c.Address
}

func (c *CounterpartRawData) GetBankAccount() *CounterpartRawBankAccount {
	if c == nil {
		return nil
	}
	return c.BankAccount
}

func (c *CounterpartRawData) GetEmail() *string {
	if c == nil {
		return nil
	}
	return c.Email
}

func (c *CounterpartRawData) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CounterpartRawData) GetPhone() *string {
	if c == nil {
		return nil
	}
	return c.Phone
}

func (c *CounterpartRawData) GetTaxId() *string {
	if c == nil {
		return nil
	}
	return c.TaxId
}

func (c *CounterpartRawData) GetVatId() *CounterpartRawVatId {
	if c == nil {
		return nil
	}
	return c.VatId
}

func (c *CounterpartRawData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartRawData) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartRawData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartRawData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartRawData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartRawDataUpdateRequest struct {
	// The address of the vendor or supplier.
	Address *CounterpartRawAddressUpdateRequest `json:"address,omitempty" url:"address,omitempty"`
	// Object representing counterpart bank account.
	BankAccount *CounterpartRawBankAccountUpdateRequest `json:"bank_account,omitempty" url:"bank_account,omitempty"`
	// The email address of the organization
	Email *string `json:"email,omitempty" url:"email,omitempty"`
	// Vendor or supplier name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The phone number of the organization
	Phone *string `json:"phone,omitempty" url:"phone,omitempty"`
	// The tax id of the counterpart.
	TaxId *string `json:"tax_id,omitempty" url:"tax_id,omitempty"`
	// VAT ID of the vendor or supplier which was used in the invoice.
	VatId *CounterpartRawVatIdUpdateRequest `json:"vat_id,omitempty" url:"vat_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartRawDataUpdateRequest) GetAddress() *CounterpartRawAddressUpdateRequest {
	if c == nil {
		return nil
	}
	return c.Address
}

func (c *CounterpartRawDataUpdateRequest) GetBankAccount() *CounterpartRawBankAccountUpdateRequest {
	if c == nil {
		return nil
	}
	return c.BankAccount
}

func (c *CounterpartRawDataUpdateRequest) GetEmail() *string {
	if c == nil {
		return nil
	}
	return c.Email
}

func (c *CounterpartRawDataUpdateRequest) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CounterpartRawDataUpdateRequest) GetPhone() *string {
	if c == nil {
		return nil
	}
	return c.Phone
}

func (c *CounterpartRawDataUpdateRequest) GetTaxId() *string {
	if c == nil {
		return nil
	}
	return c.TaxId
}

func (c *CounterpartRawDataUpdateRequest) GetVatId() *CounterpartRawVatIdUpdateRequest {
	if c == nil {
		return nil
	}
	return c.VatId
}

func (c *CounterpartRawDataUpdateRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartRawDataUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartRawDataUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartRawDataUpdateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartRawDataUpdateRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartRawVatId struct {
	Country *AllowedCountries `json:"country,omitempty" url:"country,omitempty"`
	Type    *string           `json:"type,omitempty" url:"type,omitempty"`
	Value   *string           `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartRawVatId) GetCountry() *AllowedCountries {
	if c == nil {
		return nil
	}
	return c.Country
}

func (c *CounterpartRawVatId) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CounterpartRawVatId) GetValue() *string {
	if c == nil {
		return nil
	}
	return c.Value
}

func (c *CounterpartRawVatId) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartRawVatId) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartRawVatId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartRawVatId(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartRawVatId) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartRawVatIdUpdateRequest struct {
	Country *AllowedCountries `json:"country,omitempty" url:"country,omitempty"`
	Type    *string           `json:"type,omitempty" url:"type,omitempty"`
	Value   *string           `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartRawVatIdUpdateRequest) GetCountry() *AllowedCountries {
	if c == nil {
		return nil
	}
	return c.Country
}

func (c *CounterpartRawVatIdUpdateRequest) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CounterpartRawVatIdUpdateRequest) GetValue() *string {
	if c == nil {
		return nil
	}
	return c.Value
}

func (c *CounterpartRawVatIdUpdateRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartRawVatIdUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartRawVatIdUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartRawVatIdUpdateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartRawVatIdUpdateRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CurrencyExchangeSchema2 struct {
	DefaultCurrencyCode string  `json:"default_currency_code" url:"default_currency_code"`
	Rate                float64 `json:"rate" url:"rate"`
	Total               float64 `json:"total" url:"total"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CurrencyExchangeSchema2) GetDefaultCurrencyCode() string {
	if c == nil {
		return ""
	}
	return c.DefaultCurrencyCode
}

func (c *CurrencyExchangeSchema2) GetRate() float64 {
	if c == nil {
		return 0
	}
	return c.Rate
}

func (c *CurrencyExchangeSchema2) GetTotal() float64 {
	if c == nil {
		return 0
	}
	return c.Total
}

func (c *CurrencyExchangeSchema2) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CurrencyExchangeSchema2) UnmarshalJSON(data []byte) error {
	type unmarshaler CurrencyExchangeSchema2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CurrencyExchangeSchema2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CurrencyExchangeSchema2) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a file (such as a PDF invoice) that was uploaded to Monite.
type FileSchema2 struct {
	// A unique ID of this file.
	Id string `json:"id" url:"id"`
	// UTC date and time when this file was uploaded to Monite. Timestamps follow the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// The type of the business object associated with this file.
	FileType string `json:"file_type" url:"file_type"`
	// The original file name (if available).
	Name string `json:"name" url:"name"`
	// Geographical region of the data center where the file is stored.
	Region string `json:"region" url:"region"`
	// The MD5 hash of the file.
	Md5 string `json:"md5" url:"md5"`
	// The file's [media type](https://developer.mozilla.org/en-US/docs/Web/HTTP/MIME_types).
	Mimetype string `json:"mimetype" url:"mimetype"`
	// The URL to download the file.
	Url string `json:"url" url:"url"`
	// The file size in bytes.
	Size int `json:"size" url:"size"`
	// Preview images generated for this file. There can be multiple images with different sizes.
	Previews []*PreviewSchema2 `json:"previews,omitempty" url:"previews,omitempty"`
	// If the file is a PDF document, this property contains individual pages extracted from the file. Otherwise, an empty array.
	Pages []*PageSchema2 `json:"pages,omitempty" url:"pages,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileSchema2) GetId() string {
	if f == nil {
		return ""
	}
	return f.Id
}

func (f *FileSchema2) GetCreatedAt() time.Time {
	if f == nil {
		return time.Time{}
	}
	return f.CreatedAt
}

func (f *FileSchema2) GetFileType() string {
	if f == nil {
		return ""
	}
	return f.FileType
}

func (f *FileSchema2) GetName() string {
	if f == nil {
		return ""
	}
	return f.Name
}

func (f *FileSchema2) GetRegion() string {
	if f == nil {
		return ""
	}
	return f.Region
}

func (f *FileSchema2) GetMd5() string {
	if f == nil {
		return ""
	}
	return f.Md5
}

func (f *FileSchema2) GetMimetype() string {
	if f == nil {
		return ""
	}
	return f.Mimetype
}

func (f *FileSchema2) GetUrl() string {
	if f == nil {
		return ""
	}
	return f.Url
}

func (f *FileSchema2) GetSize() int {
	if f == nil {
		return 0
	}
	return f.Size
}

func (f *FileSchema2) GetPreviews() []*PreviewSchema2 {
	if f == nil {
		return nil
	}
	return f.Previews
}

func (f *FileSchema2) GetPages() []*PageSchema2 {
	if f == nil {
		return nil
	}
	return f.Pages
}

func (f *FileSchema2) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileSchema2) UnmarshalJSON(data []byte) error {
	type embed FileSchema2
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FileSchema2(unmarshaler.embed)
	f.CreatedAt = unmarshaler.CreatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileSchema2) MarshalJSON() ([]byte, error) {
	type embed FileSchema2
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at"`
	}{
		embed:     embed(*f),
		CreatedAt: internal.NewDateTime(f.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (f *FileSchema2) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Contains information about a text block or line extracted from an uploaded document by OCR.
type Item struct {
	// The text as recognized by OCR.
	Text string `json:"text" url:"text"`
	// OCR confidence score - the estimated accuracy percentage of character recognition of the extracted text, from 0 to 100%.
	Confidence    float64     `json:"confidence" url:"confidence"`
	ProcessedText interface{} `json:"processed_text,omitempty" url:"processed_text,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *Item) GetText() string {
	if i == nil {
		return ""
	}
	return i.Text
}

func (i *Item) GetConfidence() float64 {
	if i == nil {
		return 0
	}
	return i.Confidence
}

func (i *Item) GetProcessedText() interface{} {
	if i == nil {
		return nil
	}
	return i.ProcessedText
}

func (i *Item) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Item) UnmarshalJSON(data []byte) error {
	type unmarshaler Item
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Item(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *Item) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// A label-value pair extracted from an uploaded document by OCR.
// For example, the label could be "Total" and the value could be a currency amount.
type LabelNValue struct {
	// Text label.
	Label *Item `json:"label" url:"label"`
	// The value (if any).
	Value *Item `json:"value" url:"value"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LabelNValue) GetLabel() *Item {
	if l == nil {
		return nil
	}
	return l.Label
}

func (l *LabelNValue) GetValue() *Item {
	if l == nil {
		return nil
	}
	return l.Value
}

func (l *LabelNValue) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LabelNValue) UnmarshalJSON(data []byte) error {
	type unmarshaler LabelNValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabelNValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabelNValue) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// In general it's compatible with CounterpartAddress model but
// * All fields are optional
// * There is an additional field original_country_name
type OcrAddress struct {
	// Two-letter ISO country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
	Country *string `json:"country,omitempty" url:"country,omitempty"`
	// Country name as it is stated in the document.
	OriginalCountryName *string `json:"original_country_name,omitempty" url:"original_country_name,omitempty"`
	// City name.
	City *string `json:"city,omitempty" url:"city,omitempty"`
	// ZIP or postal code.
	PostalCode *string `json:"postal_code,omitempty" url:"postal_code,omitempty"`
	// State, region, province, or county.
	State *string `json:"state,omitempty" url:"state,omitempty"`
	// Street address.
	Line1 *string `json:"line1,omitempty" url:"line1,omitempty"`
	// Additional address information (if any).
	Line2 *string `json:"line2,omitempty" url:"line2,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrAddress) GetCountry() *string {
	if o == nil {
		return nil
	}
	return o.Country
}

func (o *OcrAddress) GetOriginalCountryName() *string {
	if o == nil {
		return nil
	}
	return o.OriginalCountryName
}

func (o *OcrAddress) GetCity() *string {
	if o == nil {
		return nil
	}
	return o.City
}

func (o *OcrAddress) GetPostalCode() *string {
	if o == nil {
		return nil
	}
	return o.PostalCode
}

func (o *OcrAddress) GetState() *string {
	if o == nil {
		return nil
	}
	return o.State
}

func (o *OcrAddress) GetLine1() *string {
	if o == nil {
		return nil
	}
	return o.Line1
}

func (o *OcrAddress) GetLine2() *string {
	if o == nil {
		return nil
	}
	return o.Line2
}

func (o *OcrAddress) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrAddress(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrAddress) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Contains information about all text blocks extracted from an uploaded invoice by OCR.
// The text blocks are grouped into `line_items` (invoice line items) and `summary` (all other information).
// Legacy schema used for AWS textract recognition.
type OcrRecognitionResponse struct {
	// Invoice text content other than the line items. Such as the invoice issue and due dates, vendor name and address, and other general information.
	Summary []*LabelNValue `json:"summary,omitempty" url:"summary,omitempty"`
	// Text content of the invoice line items as recognized by OCR.
	LineItems []*LabelNValue `json:"line_items,omitempty" url:"line_items,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrRecognitionResponse) GetSummary() []*LabelNValue {
	if o == nil {
		return nil
	}
	return o.Summary
}

func (o *OcrRecognitionResponse) GetLineItems() []*LabelNValue {
	if o == nil {
		return nil
	}
	return o.LineItems
}

func (o *OcrRecognitionResponse) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrRecognitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrRecognitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrRecognitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrRecognitionResponse) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OcrResponseInvoiceReceiptData struct {
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Total in cents/eurocents. Outdated, actual conversion happens in payables.
	Total *int `json:"total,omitempty" url:"total,omitempty"`
	// Total paid amount
	TotalPaidAmountRaw *float64 `json:"total_paid_amount_raw,omitempty" url:"total_paid_amount_raw,omitempty"`
	// Total, without minor units
	TotalRaw *float64 `json:"total_raw,omitempty" url:"total_raw,omitempty"`
	// Subtotal cents/eurocents. Outdated, actual conversion happens in payables.
	TotalExclVat *int `json:"total_excl_vat,omitempty" url:"total_excl_vat,omitempty"`
	// Subtotal, without minor units
	TotalExclVatRaw *float64 `json:"total_excl_vat_raw,omitempty" url:"total_excl_vat_raw,omitempty"`
	// VAT amount in cents. Outdated, actual conversion happens in payables.
	TotalVatAmount *int `json:"total_vat_amount,omitempty" url:"total_vat_amount,omitempty"`
	// VAT amount, without minor units
	TotalVatAmountRaw *float64 `json:"total_vat_amount_raw,omitempty" url:"total_vat_amount_raw,omitempty"`
	// VAT Percent minor units. Example: 12.5% is 1250. Outdated, actual conversion happens in payables.
	TotalVatRate *int `json:"total_vat_rate,omitempty" url:"total_vat_rate,omitempty"`
	// VAT Percent raw, without minor units.
	TotalVatRateRaw *float64 `json:"total_vat_rate_raw,omitempty" url:"total_vat_rate_raw,omitempty"`
	// ISO 4217 currency code
	Currency *string `json:"currency,omitempty" url:"currency,omitempty"`
	// Purchase Order Number
	PurchaseOrderNumber *string `json:"purchase_order_number,omitempty" url:"purchase_order_number,omitempty"`
	// Counterpart name
	CounterpartName *string `json:"counterpart_name,omitempty" url:"counterpart_name,omitempty"`
	// Counterpart address
	CounterpartAddress *string `json:"counterpart_address,omitempty" url:"counterpart_address,omitempty"`
	// Counterpart bank ID
	CounterpartAccountId *string `json:"counterpart_account_id,omitempty" url:"counterpart_account_id,omitempty"`
	// Invoice/receipt ID
	DocumentId *string `json:"document_id,omitempty" url:"document_id,omitempty"`
	// Raw payment terms parsed but not calculated.
	PaymentTermsRaw []string `json:"payment_terms_raw,omitempty" url:"payment_terms_raw,omitempty"`
	// Tax payer ID
	TaxPayerId *string `json:"tax_payer_id,omitempty" url:"tax_payer_id,omitempty"`
	// Counterpart VAT ID
	CounterpartVatId *string `json:"counterpart_vat_id,omitempty" url:"counterpart_vat_id,omitempty"`
	// Document issuance date in ISO format
	DocumentIssuedAtDate *string `json:"document_issued_at_date,omitempty" url:"document_issued_at_date,omitempty"`
	// Document due date in ISO format
	DocumentDueDate *string `json:"document_due_date,omitempty" url:"document_due_date,omitempty"`
	// Counterpart address as a json object compatible with counterparts service
	CounterpartAddressObject *OcrAddress `json:"counterpart_address_object,omitempty" url:"counterpart_address_object,omitempty"`
	// The bank account number
	CounterpartAccountNumber *string `json:"counterpart_account_number,omitempty" url:"counterpart_account_number,omitempty"`
	// The bank routing number
	CounterpartRoutingNumber *string `json:"counterpart_routing_number,omitempty" url:"counterpart_routing_number,omitempty"`
	// List of line items from document. Outdated, actual conversion happens in payables.
	LineItems []*OcrResponseInvoiceReceiptLineItem `json:"line_items,omitempty" url:"line_items,omitempty"`
	// List of line items from document raw, without minor units conversion.
	LineItemsRaw []*OcrResponseInvoiceReceiptLineItemRaw `json:"line_items_raw,omitempty" url:"line_items_raw,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrResponseInvoiceReceiptData) GetTotal() *int {
	if o == nil {
		return nil
	}
	return o.Total
}

func (o *OcrResponseInvoiceReceiptData) GetTotalPaidAmountRaw() *float64 {
	if o == nil {
		return nil
	}
	return o.TotalPaidAmountRaw
}

func (o *OcrResponseInvoiceReceiptData) GetTotalRaw() *float64 {
	if o == nil {
		return nil
	}
	return o.TotalRaw
}

func (o *OcrResponseInvoiceReceiptData) GetTotalExclVat() *int {
	if o == nil {
		return nil
	}
	return o.TotalExclVat
}

func (o *OcrResponseInvoiceReceiptData) GetTotalExclVatRaw() *float64 {
	if o == nil {
		return nil
	}
	return o.TotalExclVatRaw
}

func (o *OcrResponseInvoiceReceiptData) GetTotalVatAmount() *int {
	if o == nil {
		return nil
	}
	return o.TotalVatAmount
}

func (o *OcrResponseInvoiceReceiptData) GetTotalVatAmountRaw() *float64 {
	if o == nil {
		return nil
	}
	return o.TotalVatAmountRaw
}

func (o *OcrResponseInvoiceReceiptData) GetTotalVatRate() *int {
	if o == nil {
		return nil
	}
	return o.TotalVatRate
}

func (o *OcrResponseInvoiceReceiptData) GetTotalVatRateRaw() *float64 {
	if o == nil {
		return nil
	}
	return o.TotalVatRateRaw
}

func (o *OcrResponseInvoiceReceiptData) GetCurrency() *string {
	if o == nil {
		return nil
	}
	return o.Currency
}

func (o *OcrResponseInvoiceReceiptData) GetPurchaseOrderNumber() *string {
	if o == nil {
		return nil
	}
	return o.PurchaseOrderNumber
}

func (o *OcrResponseInvoiceReceiptData) GetCounterpartName() *string {
	if o == nil {
		return nil
	}
	return o.CounterpartName
}

func (o *OcrResponseInvoiceReceiptData) GetCounterpartAddress() *string {
	if o == nil {
		return nil
	}
	return o.CounterpartAddress
}

func (o *OcrResponseInvoiceReceiptData) GetCounterpartAccountId() *string {
	if o == nil {
		return nil
	}
	return o.CounterpartAccountId
}

func (o *OcrResponseInvoiceReceiptData) GetDocumentId() *string {
	if o == nil {
		return nil
	}
	return o.DocumentId
}

func (o *OcrResponseInvoiceReceiptData) GetPaymentTermsRaw() []string {
	if o == nil {
		return nil
	}
	return o.PaymentTermsRaw
}

func (o *OcrResponseInvoiceReceiptData) GetTaxPayerId() *string {
	if o == nil {
		return nil
	}
	return o.TaxPayerId
}

func (o *OcrResponseInvoiceReceiptData) GetCounterpartVatId() *string {
	if o == nil {
		return nil
	}
	return o.CounterpartVatId
}

func (o *OcrResponseInvoiceReceiptData) GetDocumentIssuedAtDate() *string {
	if o == nil {
		return nil
	}
	return o.DocumentIssuedAtDate
}

func (o *OcrResponseInvoiceReceiptData) GetDocumentDueDate() *string {
	if o == nil {
		return nil
	}
	return o.DocumentDueDate
}

func (o *OcrResponseInvoiceReceiptData) GetCounterpartAddressObject() *OcrAddress {
	if o == nil {
		return nil
	}
	return o.CounterpartAddressObject
}

func (o *OcrResponseInvoiceReceiptData) GetCounterpartAccountNumber() *string {
	if o == nil {
		return nil
	}
	return o.CounterpartAccountNumber
}

func (o *OcrResponseInvoiceReceiptData) GetCounterpartRoutingNumber() *string {
	if o == nil {
		return nil
	}
	return o.CounterpartRoutingNumber
}

func (o *OcrResponseInvoiceReceiptData) GetLineItems() []*OcrResponseInvoiceReceiptLineItem {
	if o == nil {
		return nil
	}
	return o.LineItems
}

func (o *OcrResponseInvoiceReceiptData) GetLineItemsRaw() []*OcrResponseInvoiceReceiptLineItemRaw {
	if o == nil {
		return nil
	}
	return o.LineItemsRaw
}

func (o *OcrResponseInvoiceReceiptData) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrResponseInvoiceReceiptData) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrResponseInvoiceReceiptData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrResponseInvoiceReceiptData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrResponseInvoiceReceiptData) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OcrResponseInvoiceReceiptLineItem struct {
	// OCR Id of line item
	LineItemOcrId *string `json:"line_item_ocr_id,omitempty" url:"line_item_ocr_id,omitempty"`
	// Human-readable line item description
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Quanity
	Quantity *float64 `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Price in  cents/eurocents
	UnitPrice *int `json:"unit_price,omitempty" url:"unit_price,omitempty"`
	// Unit
	Unit *string `json:"unit,omitempty" url:"unit,omitempty"`
	// VAT Percent minor units. Example: 12.5% is 1250.
	VatPercentage *int `json:"vat_percentage,omitempty" url:"vat_percentage,omitempty"`
	// VAT Amount minor units.
	VatAmount *int `json:"vat_amount,omitempty" url:"vat_amount,omitempty"`
	// Total excl VAT
	TotalExclVat *int `json:"total_excl_vat,omitempty" url:"total_excl_vat,omitempty"`
	// Total included VAT
	TotalInclVat *int `json:"total_incl_vat,omitempty" url:"total_incl_vat,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrResponseInvoiceReceiptLineItem) GetLineItemOcrId() *string {
	if o == nil {
		return nil
	}
	return o.LineItemOcrId
}

func (o *OcrResponseInvoiceReceiptLineItem) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OcrResponseInvoiceReceiptLineItem) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *OcrResponseInvoiceReceiptLineItem) GetUnitPrice() *int {
	if o == nil {
		return nil
	}
	return o.UnitPrice
}

func (o *OcrResponseInvoiceReceiptLineItem) GetUnit() *string {
	if o == nil {
		return nil
	}
	return o.Unit
}

func (o *OcrResponseInvoiceReceiptLineItem) GetVatPercentage() *int {
	if o == nil {
		return nil
	}
	return o.VatPercentage
}

func (o *OcrResponseInvoiceReceiptLineItem) GetVatAmount() *int {
	if o == nil {
		return nil
	}
	return o.VatAmount
}

func (o *OcrResponseInvoiceReceiptLineItem) GetTotalExclVat() *int {
	if o == nil {
		return nil
	}
	return o.TotalExclVat
}

func (o *OcrResponseInvoiceReceiptLineItem) GetTotalInclVat() *int {
	if o == nil {
		return nil
	}
	return o.TotalInclVat
}

func (o *OcrResponseInvoiceReceiptLineItem) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrResponseInvoiceReceiptLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrResponseInvoiceReceiptLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrResponseInvoiceReceiptLineItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrResponseInvoiceReceiptLineItem) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OcrResponseInvoiceReceiptLineItemRaw struct {
	// OCR Id of line item
	LineItemOcrId *string `json:"line_item_ocr_id,omitempty" url:"line_item_ocr_id,omitempty"`
	// Human-readable line item description
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Quanity
	Quantity *float64 `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Price as parsed
	UnitPrice *float64 `json:"unit_price,omitempty" url:"unit_price,omitempty"`
	// Unit
	Unit *string `json:"unit,omitempty" url:"unit,omitempty"`
	// VAT Percent as parsed.
	VatPercentage *float64 `json:"vat_percentage,omitempty" url:"vat_percentage,omitempty"`
	// VAT Amount as parsed.
	VatAmount *float64 `json:"vat_amount,omitempty" url:"vat_amount,omitempty"`
	// Total excluded VAT as parsed.
	TotalExclVat *float64 `json:"total_excl_vat,omitempty" url:"total_excl_vat,omitempty"`
	// Total included VAT as parsed.
	TotalInclVat *float64 `json:"total_incl_vat,omitempty" url:"total_incl_vat,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetLineItemOcrId() *string {
	if o == nil {
		return nil
	}
	return o.LineItemOcrId
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetUnitPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.UnitPrice
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetUnit() *string {
	if o == nil {
		return nil
	}
	return o.Unit
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetVatPercentage() *float64 {
	if o == nil {
		return nil
	}
	return o.VatPercentage
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetVatAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.VatAmount
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetTotalExclVat() *float64 {
	if o == nil {
		return nil
	}
	return o.TotalExclVat
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetTotalInclVat() *float64 {
	if o == nil {
		return nil
	}
	return o.TotalInclVat
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrResponseInvoiceReceiptLineItemRaw
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrResponseInvoiceReceiptLineItemRaw(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// When a PDF document is uploaded to Monite, it extracts individual pages from the document
// and saves them as PNG images. This object contains the image and metadata of a single page.
type PageSchema2 struct {
	// A unique ID of the image.
	Id string `json:"id" url:"id"`
	// The [media type](https://developer.mozilla.org/en-US/docs/Web/HTTP/MIME_types) of the image.
	Mimetype string `json:"mimetype" url:"mimetype"`
	// Image file size, in bytes.
	Size int `json:"size" url:"size"`
	// The page number in the PDF document, from 0.
	Number int `json:"number" url:"number"`
	// The URL to download the image.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PageSchema2) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PageSchema2) GetMimetype() string {
	if p == nil {
		return ""
	}
	return p.Mimetype
}

func (p *PageSchema2) GetSize() int {
	if p == nil {
		return 0
	}
	return p.Size
}

func (p *PageSchema2) GetNumber() int {
	if p == nil {
		return 0
	}
	return p.Number
}

func (p *PageSchema2) GetUrl() string {
	if p == nil {
		return ""
	}
	return p.Url
}

func (p *PageSchema2) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PageSchema2) UnmarshalJSON(data []byte) error {
	type unmarshaler PageSchema2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PageSchema2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PageSchema2) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayableAggregatedDataResponse struct {
	// The total count of payables across all statuses.
	Count int `json:"count" url:"count"`
	// A list of aggregated items, each representing a status with its associated sum of the amount field and count.
	Data []*PayableAggregatedItem `json:"data" url:"data"`
	// The total sum of the amount field for all payables across all statuses.
	SumTotalAmount int `json:"sum_total_amount" url:"sum_total_amount"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableAggregatedDataResponse) GetCount() int {
	if p == nil {
		return 0
	}
	return p.Count
}

func (p *PayableAggregatedDataResponse) GetData() []*PayableAggregatedItem {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PayableAggregatedDataResponse) GetSumTotalAmount() int {
	if p == nil {
		return 0
	}
	return p.SumTotalAmount
}

func (p *PayableAggregatedDataResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableAggregatedDataResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PayableAggregatedDataResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayableAggregatedDataResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableAggregatedDataResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayableAggregatedItem struct {
	// The total count of payables with this specific status.
	Count int `json:"count" url:"count"`
	// The status of the payable (e.g., paid, draft, etc.).
	Status PayableStateEnum `json:"status" url:"status"`
	// The total sum of the amount field for all payables with this specific status.
	SumTotalAmount int `json:"sum_total_amount" url:"sum_total_amount"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableAggregatedItem) GetCount() int {
	if p == nil {
		return 0
	}
	return p.Count
}

func (p *PayableAggregatedItem) GetStatus() PayableStateEnum {
	if p == nil {
		return ""
	}
	return p.Status
}

func (p *PayableAggregatedItem) GetSumTotalAmount() int {
	if p == nil {
		return 0
	}
	return p.SumTotalAmount
}

func (p *PayableAggregatedItem) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableAggregatedItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PayableAggregatedItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayableAggregatedItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableAggregatedItem) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayableCreditNoteData struct {
	// The unique identifier of the credit note.
	Id string `json:"id" url:"id"`
	// The credit note's unique document number.
	DocumentId *string `json:"document_id,omitempty" url:"document_id,omitempty"`
	// The date when the credit note was issued, in the YYYY-MM-DD format
	IssuedAt *string `json:"issued_at,omitempty" url:"issued_at,omitempty"`
	// The current status of the credit note in its lifecycle
	Status string `json:"status" url:"status"`
	// Credit note total amount.
	TotalAmount *int `json:"total_amount,omitempty" url:"total_amount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableCreditNoteData) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PayableCreditNoteData) GetDocumentId() *string {
	if p == nil {
		return nil
	}
	return p.DocumentId
}

func (p *PayableCreditNoteData) GetIssuedAt() *string {
	if p == nil {
		return nil
	}
	return p.IssuedAt
}

func (p *PayableCreditNoteData) GetStatus() string {
	if p == nil {
		return ""
	}
	return p.Status
}

func (p *PayableCreditNoteData) GetTotalAmount() *int {
	if p == nil {
		return nil
	}
	return p.TotalAmount
}

func (p *PayableCreditNoteData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableCreditNoteData) UnmarshalJSON(data []byte) error {
	type unmarshaler PayableCreditNoteData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayableCreditNoteData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableCreditNoteData) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayableCursorFields string

const (
	PayableCursorFieldsId        PayableCursorFields = "id"
	PayableCursorFieldsCreatedAt PayableCursorFields = "created_at"
)

func NewPayableCursorFieldsFromString(s string) (PayableCursorFields, error) {
	switch s {
	case "id":
		return PayableCursorFieldsId, nil
	case "created_at":
		return PayableCursorFieldsCreatedAt, nil
	}
	var t PayableCursorFields
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayableCursorFields) Ptr() *PayableCursorFields {
	return &p
}

type PayableOriginEnum string

const (
	PayableOriginEnumUpload     PayableOriginEnum = "upload"
	PayableOriginEnumEmail      PayableOriginEnum = "email"
	PayableOriginEnumEinvoicing PayableOriginEnum = "einvoicing"
)

func NewPayableOriginEnumFromString(s string) (PayableOriginEnum, error) {
	switch s {
	case "upload":
		return PayableOriginEnumUpload, nil
	case "email":
		return PayableOriginEnumEmail, nil
	case "einvoicing":
		return PayableOriginEnumEinvoicing, nil
	}
	var t PayableOriginEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayableOriginEnum) Ptr() *PayableOriginEnum {
	return &p
}

// A paginated list of payables.
type PayablePaginationResponse struct {
	Data []*PayableResponseSchema `json:"data" url:"data"`
	// A token that can be sent in the `pagination_token` query parameter to get the next page of results, or `null` if there is no next page (i.e. you've reached the last page).
	NextPaginationToken *string `json:"next_pagination_token,omitempty" url:"next_pagination_token,omitempty"`
	// A token that can be sent in the `pagination_token` query parameter to get the previous page of results, or `null` if there is no previous page (i.e. you've reached the first page).
	PrevPaginationToken *string `json:"prev_pagination_token,omitempty" url:"prev_pagination_token,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayablePaginationResponse) GetData() []*PayableResponseSchema {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PayablePaginationResponse) GetNextPaginationToken() *string {
	if p == nil {
		return nil
	}
	return p.NextPaginationToken
}

func (p *PayablePaginationResponse) GetPrevPaginationToken() *string {
	if p == nil {
		return nil
	}
	return p.PrevPaginationToken
}

func (p *PayablePaginationResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayablePaginationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PayablePaginationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayablePaginationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayablePaginationResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayablePaymentTermDiscount struct {
	// The discount percentage in minor units. E.g., 200 means 2%, 1050 means 10.5%.
	Discount int `json:"discount" url:"discount"`
	// The amount of days after the invoice issue date.
	NumberOfDays int `json:"number_of_days" url:"number_of_days"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayablePaymentTermDiscount) GetDiscount() int {
	if p == nil {
		return 0
	}
	return p.Discount
}

func (p *PayablePaymentTermDiscount) GetNumberOfDays() int {
	if p == nil {
		return 0
	}
	return p.NumberOfDays
}

func (p *PayablePaymentTermDiscount) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayablePaymentTermDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler PayablePaymentTermDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayablePaymentTermDiscount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayablePaymentTermDiscount) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayablePaymentTermFinal struct {
	// The amount of days after the invoice issue date.
	NumberOfDays int `json:"number_of_days" url:"number_of_days"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayablePaymentTermFinal) GetNumberOfDays() int {
	if p == nil {
		return 0
	}
	return p.NumberOfDays
}

func (p *PayablePaymentTermFinal) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayablePaymentTermFinal) UnmarshalJSON(data []byte) error {
	type unmarshaler PayablePaymentTermFinal
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayablePaymentTermFinal(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayablePaymentTermFinal) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayablePaymentTermsCreatePayload struct {
	Description *string                     `json:"description,omitempty" url:"description,omitempty"`
	Name        string                      `json:"name" url:"name"`
	Term1       *PayablePaymentTermDiscount `json:"term_1,omitempty" url:"term_1,omitempty"`
	Term2       *PayablePaymentTermDiscount `json:"term_2,omitempty" url:"term_2,omitempty"`
	TermFinal   *PayablePaymentTermFinal    `json:"term_final" url:"term_final"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayablePaymentTermsCreatePayload) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PayablePaymentTermsCreatePayload) GetName() string {
	if p == nil {
		return ""
	}
	return p.Name
}

func (p *PayablePaymentTermsCreatePayload) GetTerm1() *PayablePaymentTermDiscount {
	if p == nil {
		return nil
	}
	return p.Term1
}

func (p *PayablePaymentTermsCreatePayload) GetTerm2() *PayablePaymentTermDiscount {
	if p == nil {
		return nil
	}
	return p.Term2
}

func (p *PayablePaymentTermsCreatePayload) GetTermFinal() *PayablePaymentTermFinal {
	if p == nil {
		return nil
	}
	return p.TermFinal
}

func (p *PayablePaymentTermsCreatePayload) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayablePaymentTermsCreatePayload) UnmarshalJSON(data []byte) error {
	type unmarshaler PayablePaymentTermsCreatePayload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayablePaymentTermsCreatePayload(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayablePaymentTermsCreatePayload) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents an Accounts Payable document received from a vendor or supplier.
type PayableResponseSchema struct {
	// A unique ID assigned to this payable.
	Id string `json:"id" url:"id"`
	// UTC date and time when this payable was created. Timestamps follow the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// UTC date and time when this payable was last updated. Timestamps follow the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	// How much is left to be paid on the invoice (in minor units).
	AmountDue *int `json:"amount_due,omitempty" url:"amount_due,omitempty"`
	// How much was paid on the invoice (in minor units).
	AmountPaid *int `json:"amount_paid,omitempty" url:"amount_paid,omitempty"`
	// How much is left to be paid on the invoice (in minor units) with discounts from payment terms.
	AmountToPay *int `json:"amount_to_pay,omitempty" url:"amount_to_pay,omitempty"`
	// Id of existing approval policy that applies to this payable, if any. A policy is applied if the payable matches the policy trigger conditions.
	ApprovalPolicyId *string `json:"approval_policy_id,omitempty" url:"approval_policy_id,omitempty"`
	// Object representing de-normalized counterpart data. Filled at the moment of invoice submitting for approval or payment.
	Counterpart *CounterpartRawData `json:"counterpart,omitempty" url:"counterpart,omitempty"`
	// The ID of counterpart address object stored in counterparts service
	CounterpartAddressId *string `json:"counterpart_address_id,omitempty" url:"counterpart_address_id,omitempty"`
	// The ID of counterpart bank account object stored in counterparts service
	CounterpartBankAccountId *string `json:"counterpart_bank_account_id,omitempty" url:"counterpart_bank_account_id,omitempty"`
	// The ID of the counterpart object that represents the vendor or supplier.
	CounterpartId *string `json:"counterpart_id,omitempty" url:"counterpart_id,omitempty"`
	// Object representing counterpart data which was extracted by OCR. Used for informational purposes.
	CounterpartRawData *CounterpartRawData `json:"counterpart_raw_data,omitempty" url:"counterpart_raw_data,omitempty"`
	// The ID of counterpart VAT ID object stored in counterparts service
	CounterpartVatIdId *string `json:"counterpart_vat_id_id,omitempty" url:"counterpart_vat_id_id,omitempty"`
	// The ID of the role that the entity user who created this payable had at that time. If the payable was created using a partner access token, the value is `null`.
	CreatedByRoleId *string `json:"created_by_role_id,omitempty" url:"created_by_role_id,omitempty"`
	// The list of linked credit notes of the payable.
	CreditNotes []*PayableCreditNoteData `json:"credit_notes" url:"credit_notes"`
	// The [currency code](https://docs.monite.com/references/currencies) of the currency used in the payable.
	Currency         *CurrencyEnum            `json:"currency,omitempty" url:"currency,omitempty"`
	CurrencyExchange *CurrencyExchangeSchema2 `json:"currency_exchange,omitempty" url:"currency_exchange,omitempty"`
	// An arbitrary description of this payable.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The value of the additional discount that will be applied to the total amount. in [minor units](https://docs.monite.com/references/currencies#minor-units). For example, $12.50 is represented as 1250.
	Discount *int `json:"discount,omitempty" url:"discount,omitempty"`
	// A unique invoice number assigned by the invoice issuer for payment tracking purposes. This is different from `id` which is an internal ID created automatically by Monite.
	DocumentId *string `json:"document_id,omitempty" url:"document_id,omitempty"`
	// The date by which the payable must be paid, in the YYYY-MM-DD format. If the payable specifies payment terms with early payment discounts, this is the final payment date.
	DueDate *string `json:"due_date,omitempty" url:"due_date,omitempty"`
	// The ID of the entity to which the payable was issued.
	EntityId string `json:"entity_id" url:"entity_id"`
	// The original file from which this payable was created.
	File *FileSchema2 `json:"file,omitempty" url:"file,omitempty"`
	// File id to retrieve file info from file saver.
	FileId *string `json:"file_id,omitempty" url:"file_id,omitempty"`
	// The date when the payable was issued, in the YYYY-MM-DD format.
	IssuedAt *string `json:"issued_at,omitempty" url:"issued_at,omitempty"`
	// The ID of the entity user who marked this document as paid.
	MarkedAsPaidByEntityUserId *string `json:"marked_as_paid_by_entity_user_id,omitempty" url:"marked_as_paid_by_entity_user_id,omitempty"`
	// An arbitrary comment that describes how and when this payable was paid.
	MarkedAsPaidWithComment *string `json:"marked_as_paid_with_comment,omitempty" url:"marked_as_paid_with_comment,omitempty"`
	// Id of OCR request to match asynchronous result of processing payable.
	OcrRequestId *string `json:"ocr_request_id,omitempty" url:"ocr_request_id,omitempty"`
	// The status of the data recognition process using OCR. The 'processing' status means that the data recognition is in progress and the user needs to wait for the data enrichment. The 'error' status indicates that some error occurred on the OCR side and the user can fill in the data manually. The 'success' status means the data recognition has been successfully completed, after which the user can check the data if desired and enrich or correct it.
	OcrStatus *OcrStatusEnum `json:"ocr_status,omitempty" url:"ocr_status,omitempty"`
	// Data extracted from the uploaded payable by OCR.
	OtherExtractedData *PayableResponseSchemaOtherExtractedData `json:"other_extracted_data,omitempty" url:"other_extracted_data,omitempty"`
	// The date by which the payable was paid
	PaidAt *time.Time `json:"paid_at,omitempty" url:"paid_at,omitempty"`
	// Metadata for partner needs
	PartnerMetadata map[string]interface{} `json:"partner_metadata,omitempty" url:"partner_metadata,omitempty"`
	// Specifies how this payable was created in Monite: `upload` - created via an API call, `email` - sent via email to the entity's mailbox.
	PayableOrigin PayableOriginEnum `json:"payable_origin" url:"payable_origin"`
	// The number of days to pay with potential discount for options shorter than due_date
	PaymentTerms *PayablePaymentTermsCreatePayload `json:"payment_terms,omitempty" url:"payment_terms,omitempty"`
	// Project ID of a payable.
	ProjectId *string `json:"project_id,omitempty" url:"project_id,omitempty"`
	// The identifier of the purchase order to which this payable belongs.
	PurchaseOrderId *string `json:"purchase_order_id,omitempty" url:"purchase_order_id,omitempty"`
	// The email address from which the invoice was sent to the entity.
	Sender *string `json:"sender,omitempty" url:"sender,omitempty"`
	// Specifies how the property values of this payable were provided: `ocr` - Monite OCR service extracted the values from the provided PDF or image file, `user_specified` - values were added or updated via an API call.
	SourceOfPayableData SourceOfPayableDataEnum `json:"source_of_payable_data" url:"source_of_payable_data"`
	// The [status](https://docs.monite.com/accounts-payable/payables/index) of the payable.
	Status PayableStateEnum `json:"status" url:"status"`
	// The subtotal amount to be paid, in [minor units](https://docs.monite.com/references/currencies#minor-units). For example, $12.50 is represented as 1250.
	Subtotal *int `json:"subtotal,omitempty" url:"subtotal,omitempty"`
	// The suggested date and corresponding discount in which payable could be paid. The date is in the YYYY-MM-DD format. The discount is calculated as X * (10^-4) - for example, 100 is 1%, 25 is 0,25%, 10000 is 100 %. Date varies depending on the payment terms and may even be equal to the due date with discount 0.
	SuggestedPaymentTerm *SuggestedPaymentTerm `json:"suggested_payment_term,omitempty" url:"suggested_payment_term,omitempty"`
	// A list of user-defined tags (labels) assigned to this payable. Tags can be used to trigger a specific approval policy for this payable.
	Tags []*TagReadSchema `json:"tags,omitempty" url:"tags,omitempty"`
	// Registered tax percentage applied for a service price in minor units, e.g. 200 means 2%, 1050 means 10.5%.
	Tax *int `json:"tax,omitempty" url:"tax,omitempty"`
	// Tax amount in [minor units](https://docs.monite.com/references/currencies#minor-units). For example, $12.50 is represented as 1250.
	TaxAmount *int `json:"tax_amount,omitempty" url:"tax_amount,omitempty"`
	// The total amount to be paid, in [minor units](https://docs.monite.com/references/currencies#minor-units). For example, $12.50 is represented as 1250.
	TotalAmount *int `json:"total_amount,omitempty" url:"total_amount,omitempty"`
	// The total price of the payable in [minor units](https://docs.monite.com/references/currencies#minor-units), excluding all issued credit notes.
	TotalAmountWithCreditNotes *int    `json:"total_amount_with_credit_notes,omitempty" url:"total_amount_with_credit_notes,omitempty"`
	WasCreatedByUserId         *string `json:"was_created_by_user_id,omitempty" url:"was_created_by_user_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableResponseSchema) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PayableResponseSchema) GetCreatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.CreatedAt
}

func (p *PayableResponseSchema) GetUpdatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.UpdatedAt
}

func (p *PayableResponseSchema) GetAmountDue() *int {
	if p == nil {
		return nil
	}
	return p.AmountDue
}

func (p *PayableResponseSchema) GetAmountPaid() *int {
	if p == nil {
		return nil
	}
	return p.AmountPaid
}

func (p *PayableResponseSchema) GetAmountToPay() *int {
	if p == nil {
		return nil
	}
	return p.AmountToPay
}

func (p *PayableResponseSchema) GetApprovalPolicyId() *string {
	if p == nil {
		return nil
	}
	return p.ApprovalPolicyId
}

func (p *PayableResponseSchema) GetCounterpart() *CounterpartRawData {
	if p == nil {
		return nil
	}
	return p.Counterpart
}

func (p *PayableResponseSchema) GetCounterpartAddressId() *string {
	if p == nil {
		return nil
	}
	return p.CounterpartAddressId
}

func (p *PayableResponseSchema) GetCounterpartBankAccountId() *string {
	if p == nil {
		return nil
	}
	return p.CounterpartBankAccountId
}

func (p *PayableResponseSchema) GetCounterpartId() *string {
	if p == nil {
		return nil
	}
	return p.CounterpartId
}

func (p *PayableResponseSchema) GetCounterpartRawData() *CounterpartRawData {
	if p == nil {
		return nil
	}
	return p.CounterpartRawData
}

func (p *PayableResponseSchema) GetCounterpartVatIdId() *string {
	if p == nil {
		return nil
	}
	return p.CounterpartVatIdId
}

func (p *PayableResponseSchema) GetCreatedByRoleId() *string {
	if p == nil {
		return nil
	}
	return p.CreatedByRoleId
}

func (p *PayableResponseSchema) GetCreditNotes() []*PayableCreditNoteData {
	if p == nil {
		return nil
	}
	return p.CreditNotes
}

func (p *PayableResponseSchema) GetCurrency() *CurrencyEnum {
	if p == nil {
		return nil
	}
	return p.Currency
}

func (p *PayableResponseSchema) GetCurrencyExchange() *CurrencyExchangeSchema2 {
	if p == nil {
		return nil
	}
	return p.CurrencyExchange
}

func (p *PayableResponseSchema) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PayableResponseSchema) GetDiscount() *int {
	if p == nil {
		return nil
	}
	return p.Discount
}

func (p *PayableResponseSchema) GetDocumentId() *string {
	if p == nil {
		return nil
	}
	return p.DocumentId
}

func (p *PayableResponseSchema) GetDueDate() *string {
	if p == nil {
		return nil
	}
	return p.DueDate
}

func (p *PayableResponseSchema) GetEntityId() string {
	if p == nil {
		return ""
	}
	return p.EntityId
}

func (p *PayableResponseSchema) GetFile() *FileSchema2 {
	if p == nil {
		return nil
	}
	return p.File
}

func (p *PayableResponseSchema) GetFileId() *string {
	if p == nil {
		return nil
	}
	return p.FileId
}

func (p *PayableResponseSchema) GetIssuedAt() *string {
	if p == nil {
		return nil
	}
	return p.IssuedAt
}

func (p *PayableResponseSchema) GetMarkedAsPaidByEntityUserId() *string {
	if p == nil {
		return nil
	}
	return p.MarkedAsPaidByEntityUserId
}

func (p *PayableResponseSchema) GetMarkedAsPaidWithComment() *string {
	if p == nil {
		return nil
	}
	return p.MarkedAsPaidWithComment
}

func (p *PayableResponseSchema) GetOcrRequestId() *string {
	if p == nil {
		return nil
	}
	return p.OcrRequestId
}

func (p *PayableResponseSchema) GetOcrStatus() *OcrStatusEnum {
	if p == nil {
		return nil
	}
	return p.OcrStatus
}

func (p *PayableResponseSchema) GetOtherExtractedData() *PayableResponseSchemaOtherExtractedData {
	if p == nil {
		return nil
	}
	return p.OtherExtractedData
}

func (p *PayableResponseSchema) GetPaidAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.PaidAt
}

func (p *PayableResponseSchema) GetPartnerMetadata() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.PartnerMetadata
}

func (p *PayableResponseSchema) GetPayableOrigin() PayableOriginEnum {
	if p == nil {
		return ""
	}
	return p.PayableOrigin
}

func (p *PayableResponseSchema) GetPaymentTerms() *PayablePaymentTermsCreatePayload {
	if p == nil {
		return nil
	}
	return p.PaymentTerms
}

func (p *PayableResponseSchema) GetProjectId() *string {
	if p == nil {
		return nil
	}
	return p.ProjectId
}

func (p *PayableResponseSchema) GetPurchaseOrderId() *string {
	if p == nil {
		return nil
	}
	return p.PurchaseOrderId
}

func (p *PayableResponseSchema) GetSender() *string {
	if p == nil {
		return nil
	}
	return p.Sender
}

func (p *PayableResponseSchema) GetSourceOfPayableData() SourceOfPayableDataEnum {
	if p == nil {
		return ""
	}
	return p.SourceOfPayableData
}

func (p *PayableResponseSchema) GetStatus() PayableStateEnum {
	if p == nil {
		return ""
	}
	return p.Status
}

func (p *PayableResponseSchema) GetSubtotal() *int {
	if p == nil {
		return nil
	}
	return p.Subtotal
}

func (p *PayableResponseSchema) GetSuggestedPaymentTerm() *SuggestedPaymentTerm {
	if p == nil {
		return nil
	}
	return p.SuggestedPaymentTerm
}

func (p *PayableResponseSchema) GetTags() []*TagReadSchema {
	if p == nil {
		return nil
	}
	return p.Tags
}

func (p *PayableResponseSchema) GetTax() *int {
	if p == nil {
		return nil
	}
	return p.Tax
}

func (p *PayableResponseSchema) GetTaxAmount() *int {
	if p == nil {
		return nil
	}
	return p.TaxAmount
}

func (p *PayableResponseSchema) GetTotalAmount() *int {
	if p == nil {
		return nil
	}
	return p.TotalAmount
}

func (p *PayableResponseSchema) GetTotalAmountWithCreditNotes() *int {
	if p == nil {
		return nil
	}
	return p.TotalAmountWithCreditNotes
}

func (p *PayableResponseSchema) GetWasCreatedByUserId() *string {
	if p == nil {
		return nil
	}
	return p.WasCreatedByUserId
}

func (p *PayableResponseSchema) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableResponseSchema) UnmarshalJSON(data []byte) error {
	type embed PayableResponseSchema
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at"`
		UpdatedAt *internal.DateTime `json:"updated_at"`
		PaidAt    *internal.DateTime `json:"paid_at,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PayableResponseSchema(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.Time()
	p.UpdatedAt = unmarshaler.UpdatedAt.Time()
	p.PaidAt = unmarshaler.PaidAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableResponseSchema) MarshalJSON() ([]byte, error) {
	type embed PayableResponseSchema
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at"`
		UpdatedAt *internal.DateTime `json:"updated_at"`
		PaidAt    *internal.DateTime `json:"paid_at,omitempty"`
	}{
		embed:     embed(*p),
		CreatedAt: internal.NewDateTime(p.CreatedAt),
		UpdatedAt: internal.NewDateTime(p.UpdatedAt),
		PaidAt:    internal.NewOptionalDateTime(p.PaidAt),
	}
	return json.Marshal(marshaler)
}

func (p *PayableResponseSchema) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Data extracted from the uploaded payable by OCR.
type PayableResponseSchemaOtherExtractedData struct {
	OcrResponseInvoiceReceiptData *OcrResponseInvoiceReceiptData
	OcrRecognitionResponse        *OcrRecognitionResponse

	typ string
}

func (p *PayableResponseSchemaOtherExtractedData) GetOcrResponseInvoiceReceiptData() *OcrResponseInvoiceReceiptData {
	if p == nil {
		return nil
	}
	return p.OcrResponseInvoiceReceiptData
}

func (p *PayableResponseSchemaOtherExtractedData) GetOcrRecognitionResponse() *OcrRecognitionResponse {
	if p == nil {
		return nil
	}
	return p.OcrRecognitionResponse
}

func (p *PayableResponseSchemaOtherExtractedData) UnmarshalJSON(data []byte) error {
	valueOcrResponseInvoiceReceiptData := new(OcrResponseInvoiceReceiptData)
	if err := json.Unmarshal(data, &valueOcrResponseInvoiceReceiptData); err == nil {
		p.typ = "OcrResponseInvoiceReceiptData"
		p.OcrResponseInvoiceReceiptData = valueOcrResponseInvoiceReceiptData
		return nil
	}
	valueOcrRecognitionResponse := new(OcrRecognitionResponse)
	if err := json.Unmarshal(data, &valueOcrRecognitionResponse); err == nil {
		p.typ = "OcrRecognitionResponse"
		p.OcrRecognitionResponse = valueOcrRecognitionResponse
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PayableResponseSchemaOtherExtractedData) MarshalJSON() ([]byte, error) {
	if p.typ == "OcrResponseInvoiceReceiptData" || p.OcrResponseInvoiceReceiptData != nil {
		return json.Marshal(p.OcrResponseInvoiceReceiptData)
	}
	if p.typ == "OcrRecognitionResponse" || p.OcrRecognitionResponse != nil {
		return json.Marshal(p.OcrRecognitionResponse)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PayableResponseSchemaOtherExtractedDataVisitor interface {
	VisitOcrResponseInvoiceReceiptData(*OcrResponseInvoiceReceiptData) error
	VisitOcrRecognitionResponse(*OcrRecognitionResponse) error
}

func (p *PayableResponseSchemaOtherExtractedData) Accept(visitor PayableResponseSchemaOtherExtractedDataVisitor) error {
	if p.typ == "OcrResponseInvoiceReceiptData" || p.OcrResponseInvoiceReceiptData != nil {
		return visitor.VisitOcrResponseInvoiceReceiptData(p.OcrResponseInvoiceReceiptData)
	}
	if p.typ == "OcrRecognitionResponse" || p.OcrRecognitionResponse != nil {
		return visitor.VisitOcrRecognitionResponse(p.OcrRecognitionResponse)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PayableTemplatesVariable struct {
	Description string `json:"description" url:"description"`
	Name        string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableTemplatesVariable) GetDescription() string {
	if p == nil {
		return ""
	}
	return p.Description
}

func (p *PayableTemplatesVariable) GetName() string {
	if p == nil {
		return ""
	}
	return p.Name
}

func (p *PayableTemplatesVariable) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableTemplatesVariable) UnmarshalJSON(data []byte) error {
	type unmarshaler PayableTemplatesVariable
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayableTemplatesVariable(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableTemplatesVariable) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayableTemplatesVariablesObject struct {
	ObjectSubtype PayablesVariableType        `json:"object_subtype" url:"object_subtype"`
	ObjectType    ObjectType                  `json:"object_type" url:"object_type"`
	Variables     []*PayableTemplatesVariable `json:"variables" url:"variables"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableTemplatesVariablesObject) GetObjectSubtype() PayablesVariableType {
	if p == nil {
		return ""
	}
	return p.ObjectSubtype
}

func (p *PayableTemplatesVariablesObject) GetObjectType() ObjectType {
	if p == nil {
		return ""
	}
	return p.ObjectType
}

func (p *PayableTemplatesVariablesObject) GetVariables() []*PayableTemplatesVariable {
	if p == nil {
		return nil
	}
	return p.Variables
}

func (p *PayableTemplatesVariablesObject) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableTemplatesVariablesObject) UnmarshalJSON(data []byte) error {
	type unmarshaler PayableTemplatesVariablesObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayableTemplatesVariablesObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableTemplatesVariablesObject) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayableTemplatesVariablesObjectList struct {
	Data []*PayableTemplatesVariablesObject `json:"data" url:"data"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableTemplatesVariablesObjectList) GetData() []*PayableTemplatesVariablesObject {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PayableTemplatesVariablesObjectList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableTemplatesVariablesObjectList) UnmarshalJSON(data []byte) error {
	type unmarshaler PayableTemplatesVariablesObjectList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayableTemplatesVariablesObjectList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableTemplatesVariablesObjectList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayableValidationResponse struct {
	// A unique ID assigned to this payable.
	Id               string                   `json:"id" url:"id"`
	ValidationErrors []map[string]interface{} `json:"validation_errors,omitempty" url:"validation_errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableValidationResponse) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PayableValidationResponse) GetValidationErrors() []map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.ValidationErrors
}

func (p *PayableValidationResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableValidationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PayableValidationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayableValidationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableValidationResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayableValidationsResource struct {
	RequiredFields []PayablesFieldsAllowedForValidate `json:"required_fields" url:"required_fields"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableValidationsResource) GetRequiredFields() []PayablesFieldsAllowedForValidate {
	if p == nil {
		return nil
	}
	return p.RequiredFields
}

func (p *PayableValidationsResource) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableValidationsResource) UnmarshalJSON(data []byte) error {
	type unmarshaler PayableValidationsResource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayableValidationsResource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableValidationsResource) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayablesFieldsAllowedForValidate string

const (
	PayablesFieldsAllowedForValidateCurrency                     PayablesFieldsAllowedForValidate = "currency"
	PayablesFieldsAllowedForValidateDocumentId                   PayablesFieldsAllowedForValidate = "document_id"
	PayablesFieldsAllowedForValidateDueDate                      PayablesFieldsAllowedForValidate = "due_date"
	PayablesFieldsAllowedForValidateIssuedAt                     PayablesFieldsAllowedForValidate = "issued_at"
	PayablesFieldsAllowedForValidateTaxAmount                    PayablesFieldsAllowedForValidate = "tax_amount"
	PayablesFieldsAllowedForValidateTotalAmount                  PayablesFieldsAllowedForValidate = "total_amount"
	PayablesFieldsAllowedForValidateSubtotal                     PayablesFieldsAllowedForValidate = "subtotal"
	PayablesFieldsAllowedForValidateDescription                  PayablesFieldsAllowedForValidate = "description"
	PayablesFieldsAllowedForValidateSuggestedPaymentTerm         PayablesFieldsAllowedForValidate = "suggested_payment_term"
	PayablesFieldsAllowedForValidatePaymentTerms                 PayablesFieldsAllowedForValidate = "payment_terms"
	PayablesFieldsAllowedForValidateTax                          PayablesFieldsAllowedForValidate = "tax"
	PayablesFieldsAllowedForValidateSender                       PayablesFieldsAllowedForValidate = "sender"
	PayablesFieldsAllowedForValidateFileId                       PayablesFieldsAllowedForValidate = "file_id"
	PayablesFieldsAllowedForValidateCounterpartId                PayablesFieldsAllowedForValidate = "counterpart_id"
	PayablesFieldsAllowedForValidateCounterpartBankAccountId     PayablesFieldsAllowedForValidate = "counterpart_bank_account_id"
	PayablesFieldsAllowedForValidateCounterpartAddressId         PayablesFieldsAllowedForValidate = "counterpart_address_id"
	PayablesFieldsAllowedForValidateCounterpartVatIdId           PayablesFieldsAllowedForValidate = "counterpart_vat_id_id"
	PayablesFieldsAllowedForValidateLineItems                    PayablesFieldsAllowedForValidate = "line_items"
	PayablesFieldsAllowedForValidateLineItemsQuantity            PayablesFieldsAllowedForValidate = "line_items.quantity"
	PayablesFieldsAllowedForValidateLineItemsUnitPrice           PayablesFieldsAllowedForValidate = "line_items.unit_price"
	PayablesFieldsAllowedForValidateLineItemsTax                 PayablesFieldsAllowedForValidate = "line_items.tax"
	PayablesFieldsAllowedForValidateLineItemsLedgerAccountId     PayablesFieldsAllowedForValidate = "line_items.ledger_account_id"
	PayablesFieldsAllowedForValidateLineItemsAccountingTaxRateId PayablesFieldsAllowedForValidate = "line_items.accounting_tax_rate_id"
	PayablesFieldsAllowedForValidateLineItemsUnit                PayablesFieldsAllowedForValidate = "line_items.unit"
	PayablesFieldsAllowedForValidateLineItemsName                PayablesFieldsAllowedForValidate = "line_items.name"
	PayablesFieldsAllowedForValidateLineItemsDescription         PayablesFieldsAllowedForValidate = "line_items.description"
	PayablesFieldsAllowedForValidateLineItemsSubtotal            PayablesFieldsAllowedForValidate = "line_items.subtotal"
	PayablesFieldsAllowedForValidateLineItemsTotal               PayablesFieldsAllowedForValidate = "line_items.total"
	PayablesFieldsAllowedForValidateLineItemsTaxAmount           PayablesFieldsAllowedForValidate = "line_items.tax_amount"
)

func NewPayablesFieldsAllowedForValidateFromString(s string) (PayablesFieldsAllowedForValidate, error) {
	switch s {
	case "currency":
		return PayablesFieldsAllowedForValidateCurrency, nil
	case "document_id":
		return PayablesFieldsAllowedForValidateDocumentId, nil
	case "due_date":
		return PayablesFieldsAllowedForValidateDueDate, nil
	case "issued_at":
		return PayablesFieldsAllowedForValidateIssuedAt, nil
	case "tax_amount":
		return PayablesFieldsAllowedForValidateTaxAmount, nil
	case "total_amount":
		return PayablesFieldsAllowedForValidateTotalAmount, nil
	case "subtotal":
		return PayablesFieldsAllowedForValidateSubtotal, nil
	case "description":
		return PayablesFieldsAllowedForValidateDescription, nil
	case "suggested_payment_term":
		return PayablesFieldsAllowedForValidateSuggestedPaymentTerm, nil
	case "payment_terms":
		return PayablesFieldsAllowedForValidatePaymentTerms, nil
	case "tax":
		return PayablesFieldsAllowedForValidateTax, nil
	case "sender":
		return PayablesFieldsAllowedForValidateSender, nil
	case "file_id":
		return PayablesFieldsAllowedForValidateFileId, nil
	case "counterpart_id":
		return PayablesFieldsAllowedForValidateCounterpartId, nil
	case "counterpart_bank_account_id":
		return PayablesFieldsAllowedForValidateCounterpartBankAccountId, nil
	case "counterpart_address_id":
		return PayablesFieldsAllowedForValidateCounterpartAddressId, nil
	case "counterpart_vat_id_id":
		return PayablesFieldsAllowedForValidateCounterpartVatIdId, nil
	case "line_items":
		return PayablesFieldsAllowedForValidateLineItems, nil
	case "line_items.quantity":
		return PayablesFieldsAllowedForValidateLineItemsQuantity, nil
	case "line_items.unit_price":
		return PayablesFieldsAllowedForValidateLineItemsUnitPrice, nil
	case "line_items.tax":
		return PayablesFieldsAllowedForValidateLineItemsTax, nil
	case "line_items.ledger_account_id":
		return PayablesFieldsAllowedForValidateLineItemsLedgerAccountId, nil
	case "line_items.accounting_tax_rate_id":
		return PayablesFieldsAllowedForValidateLineItemsAccountingTaxRateId, nil
	case "line_items.unit":
		return PayablesFieldsAllowedForValidateLineItemsUnit, nil
	case "line_items.name":
		return PayablesFieldsAllowedForValidateLineItemsName, nil
	case "line_items.description":
		return PayablesFieldsAllowedForValidateLineItemsDescription, nil
	case "line_items.subtotal":
		return PayablesFieldsAllowedForValidateLineItemsSubtotal, nil
	case "line_items.total":
		return PayablesFieldsAllowedForValidateLineItemsTotal, nil
	case "line_items.tax_amount":
		return PayablesFieldsAllowedForValidateLineItemsTaxAmount, nil
	}
	var t PayablesFieldsAllowedForValidate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayablesFieldsAllowedForValidate) Ptr() *PayablesFieldsAllowedForValidate {
	return &p
}

type PayablesVariableType string

const (
	PayablesVariableTypePayablesPurchaseOrder  PayablesVariableType = "payables_purchase_order"
	PayablesVariableTypePayablesNotifyApprover PayablesVariableType = "payables_notify_approver"
)

func NewPayablesVariableTypeFromString(s string) (PayablesVariableType, error) {
	switch s {
	case "payables_purchase_order":
		return PayablesVariableTypePayablesPurchaseOrder, nil
	case "payables_notify_approver":
		return PayablesVariableTypePayablesNotifyApprover, nil
	}
	var t PayablesVariableType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayablesVariableType) Ptr() *PayablesVariableType {
	return &p
}

// A preview image generated for a file.
type PreviewSchema2 struct {
	// The image URL.
	Url string `json:"url" url:"url"`
	// The image width in pixels.
	Width int `json:"width" url:"width"`
	// The image height in pixels.
	Height int `json:"height" url:"height"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PreviewSchema2) GetUrl() string {
	if p == nil {
		return ""
	}
	return p.Url
}

func (p *PreviewSchema2) GetWidth() int {
	if p == nil {
		return 0
	}
	return p.Width
}

func (p *PreviewSchema2) GetHeight() int {
	if p == nil {
		return 0
	}
	return p.Height
}

func (p *PreviewSchema2) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PreviewSchema2) UnmarshalJSON(data []byte) error {
	type unmarshaler PreviewSchema2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PreviewSchema2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PreviewSchema2) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Suggested payment date and corresponding discount
type SuggestedPaymentTerm struct {
	Date     string `json:"date" url:"date"`
	Discount *int   `json:"discount,omitempty" url:"discount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SuggestedPaymentTerm) GetDate() string {
	if s == nil {
		return ""
	}
	return s.Date
}

func (s *SuggestedPaymentTerm) GetDiscount() *int {
	if s == nil {
		return nil
	}
	return s.Discount
}

func (s *SuggestedPaymentTerm) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SuggestedPaymentTerm) UnmarshalJSON(data []byte) error {
	type unmarshaler SuggestedPaymentTerm
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SuggestedPaymentTerm(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SuggestedPaymentTerm) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type PayableUpdateSchema struct {
	// The ID of counterpart address object stored in counterparts service
	CounterpartAddressId *string `json:"counterpart_address_id,omitempty" url:"-"`
	// The ID of counterpart bank account object stored in counterparts service
	CounterpartBankAccountId *string `json:"counterpart_bank_account_id,omitempty" url:"-"`
	// The ID of the counterpart object that represents the vendor or supplier.
	CounterpartId *string `json:"counterpart_id,omitempty" url:"-"`
	// Allows to fix some data in counterpart recognised fields to correct them in order to make autolinking happen.
	CounterpartRawData *CounterpartRawDataUpdateRequest `json:"counterpart_raw_data,omitempty" url:"-"`
	// The ID of counterpart VAT ID object stored in counterparts service
	CounterpartVatIdId *string `json:"counterpart_vat_id_id,omitempty" url:"-"`
	// The [currency code](https://docs.monite.com/references/currencies) of the currency used in the payable.
	Currency *CurrencyEnum `json:"currency,omitempty" url:"-"`
	// An arbitrary description of this payable.
	Description *string `json:"description,omitempty" url:"-"`
	// The value of the additional discount that will be applied to the total amount. in [minor units](https://docs.monite.com/references/currencies#minor-units). For example, $12.50 is represented as 1250.
	Discount *int `json:"discount,omitempty" url:"-"`
	// A unique invoice number assigned by the invoice issuer for payment tracking purposes.
	DocumentId *string `json:"document_id,omitempty" url:"-"`
	// The date by which the payable must be paid, in the YYYY-MM-DD format. If the payable specifies payment terms with early payment discounts, this is the final payment date.
	DueDate *string `json:"due_date,omitempty" url:"-"`
	// The date when the payable was issued, in the YYYY-MM-DD format.
	IssuedAt *string `json:"issued_at,omitempty" url:"-"`
	// Metadata for partner needs
	PartnerMetadata map[string]interface{} `json:"partner_metadata,omitempty" url:"-"`
	// The number of days to pay with potential discount for options shorter than due_date
	PaymentTerms *PayablePaymentTermsCreatePayload `json:"payment_terms,omitempty" url:"-"`
	// The project ID of the payable.
	ProjectId *string `json:"project_id,omitempty" url:"-"`
	// The identifier of the purchase order to which this payable belongs.
	PurchaseOrderId *string `json:"purchase_order_id,omitempty" url:"-"`
	// The email address from which the invoice was sent to the entity.
	Sender *string `json:"sender,omitempty" url:"-"`
	// The subtotal amount to be paid, in [minor units](https://docs.monite.com/references/currencies#minor-units). For example, $12.50 is represented as 1250.
	Subtotal *int `json:"subtotal,omitempty" url:"-"`
	// The suggested date and corresponding discount in which payable could be paid. The date is in the YYYY-MM-DD format. The discount is calculated as X * (10^-4) - for example, 100 is 1%, 25 is 0,25%, 10000 is 100 %. Date varies depending on the payment terms and may even be equal to the due date with discount 0.
	SuggestedPaymentTerm *SuggestedPaymentTerm `json:"suggested_payment_term,omitempty" url:"-"`
	// A list of IDs of user-defined tags (labels) assigned to this payable. Tags can be used to trigger a specific approval policy for this payable.
	TagIds []string `json:"tag_ids,omitempty" url:"-"`
	// Registered tax percentage applied for a service price in minor units, e.g. 200 means 2%, 1050 means 10.5%.
	Tax *int `json:"tax,omitempty" url:"-"`
	// Tax amount in [minor units](https://docs.monite.com/references/currencies#minor-units). For example, $12.50 is represented as 1250.
	TaxAmount *int `json:"tax_amount,omitempty" url:"-"`
	// The total amount to be paid, in [minor units](https://docs.monite.com/references/currencies#minor-units). For example, $12.50 is represented as 1250.
	TotalAmount *int `json:"total_amount,omitempty" url:"-"`
}

type PayableValidationsUpdateRequest struct {
	RequiredFields []PayablesFieldsAllowedForValidate `json:"required_fields,omitempty" url:"-"`
}

type PayableUploadFile struct {
	File io.Reader `json:"-" url:"-"`
}
