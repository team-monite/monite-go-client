// This file was auto-generated by Fern from our API Definition.

package fluidstack

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/team-monite/monite-go-client/internal"
	io "io"
	time "time"
)

type PayableAttachFile struct {
	File io.Reader `json:"-" url:"-"`
}

type PayableUploadWithDataSchema struct {
	// Base64-encoded contents of the original issued payable. The file is provided for reference purposes as the original source of the data.
	//
	//	Any file formats are allowed. The most common formats are PDF, PNG, JPEG, TIFF.
	Base64EncodedFile *string `json:"base64_encoded_file,omitempty" url:"-"`
	// The ID of counterpart address object stored in counterparts service
	CounterpartAddressId *string `json:"counterpart_address_id,omitempty" url:"-"`
	// The ID of counterpart bank account object stored in counterparts service
	CounterpartBankAccountId *string `json:"counterpart_bank_account_id,omitempty" url:"-"`
	// The ID of the counterpart object that represents the vendor or supplier.
	CounterpartId *string `json:"counterpart_id,omitempty" url:"-"`
	// The ID of counterpart VAT ID object stored in counterparts service
	CounterpartVatIdId *string `json:"counterpart_vat_id_id,omitempty" url:"-"`
	// The [currency code](https://docs.monite.com/docs/currencies) of the currency used in the payable.
	Currency *CurrencyEnum `json:"currency,omitempty" url:"-"`
	// An arbitrary description of this payable.
	Description *string `json:"description,omitempty" url:"-"`
	// A unique invoice number assigned by the invoice issuer for payment tracking purposes.
	DocumentId *string `json:"document_id,omitempty" url:"-"`
	// The date by which the payable must be paid, in the YYYY-MM-DD format. If the payable specifies payment terms with early payment discounts, this is the final payment date.
	DueDate *string `json:"due_date,omitempty" url:"-"`
	// The original file name.
	FileName *string `json:"file_name,omitempty" url:"-"`
	// The date when the payable was issued, in the YYYY-MM-DD format.
	IssuedAt *string `json:"issued_at,omitempty" url:"-"`
	// Metadata for partner needs
	PartnerMetadata map[string]interface{} `json:"partner_metadata,omitempty" url:"-"`
	// The number of days to pay with potential discount for options shorter than due_date
	PaymentTerms *PayablePaymentTermsCreatePayload `json:"payment_terms,omitempty" url:"-"`
	// The ID of a project
	ProjectId *string `json:"project_id,omitempty" url:"-"`
	// The identifier of the purchase order to which this payable belongs.
	PurchaseOrderId *string `json:"purchase_order_id,omitempty" url:"-"`
	// The email address from which the invoice was sent to the entity.
	Sender *string `json:"sender,omitempty" url:"-"`
	// The subtotal amount to be paid, in [minor units](https://docs.monite.com/docs/currencies#minor-units). For example, $12.50 is represented as 1250.
	Subtotal *int `json:"subtotal,omitempty" url:"-"`
	// The suggested date and corresponding discount in which payable could be paid. The date is in the YYYY-MM-DD format. The discount is calculated as X * (10^-4) - for example, 100 is 1%, 25 is 0,25%, 10000 is 100 %. Date varies depending on the payment terms and may even be equal to the due date with discount 0.
	SuggestedPaymentTerm *SuggestedPaymentTerm `json:"suggested_payment_term,omitempty" url:"-"`
	// A list of IDs of user-defined tags (labels) assigned to this payable. Tags can be used to trigger a specific approval policy for this payable.
	TagIds []string `json:"tag_ids,omitempty" url:"-"`
	// Registered tax percentage applied for a service price in minor units, e.g. 200 means 2%. 1050 means 10.5%.
	Tax *int `json:"tax,omitempty" url:"-"`
	// Tax amount in [minor units](https://docs.monite.com/docs/currencies#minor-units). For example, $12.50 is represented as 1250.
	TaxAmount *int `json:"tax_amount,omitempty" url:"-"`
	// The total amount to be paid, in [minor units](https://docs.monite.com/docs/currencies#minor-units). For example, $12.50 is represented as 1250.
	TotalAmount *int `json:"total_amount,omitempty" url:"-"`
}

type PayablesGetRequest struct {
	// Order by
	Order *OrderEnum `json:"-" url:"order,omitempty"`
	// Max is 100
	Limit *int `json:"-" url:"limit,omitempty"`
	// A token, obtained from previous page. Prior over other filters
	PaginationToken *string `json:"-" url:"pagination_token,omitempty"`
	// Allowed sort fields
	Sort                     *PayableCursorFields     `json:"-" url:"sort,omitempty"`
	CreatedAtGt              *time.Time               `json:"-" url:"created_at__gt,omitempty"`
	CreatedAtLt              *time.Time               `json:"-" url:"created_at__lt,omitempty"`
	CreatedAtGte             *time.Time               `json:"-" url:"created_at__gte,omitempty"`
	CreatedAtLte             *time.Time               `json:"-" url:"created_at__lte,omitempty"`
	Status                   *PayableStateEnum        `json:"-" url:"status,omitempty"`
	StatusIn                 []*PayableStateEnum      `json:"-" url:"status__in,omitempty"`
	IdIn                     []*string                `json:"-" url:"id__in,omitempty"`
	TotalAmount              *int                     `json:"-" url:"total_amount,omitempty"`
	TotalAmountGt            *int                     `json:"-" url:"total_amount__gt,omitempty"`
	TotalAmountLt            *int                     `json:"-" url:"total_amount__lt,omitempty"`
	TotalAmountGte           *int                     `json:"-" url:"total_amount__gte,omitempty"`
	TotalAmountLte           *int                     `json:"-" url:"total_amount__lte,omitempty"`
	Amount                   *int                     `json:"-" url:"amount,omitempty"`
	AmountGt                 *int                     `json:"-" url:"amount__gt,omitempty"`
	AmountLt                 *int                     `json:"-" url:"amount__lt,omitempty"`
	AmountGte                *int                     `json:"-" url:"amount__gte,omitempty"`
	AmountLte                *int                     `json:"-" url:"amount__lte,omitempty"`
	Currency                 *CurrencyEnum            `json:"-" url:"currency,omitempty"`
	CounterpartName          *string                  `json:"-" url:"counterpart_name,omitempty"`
	CounterpartNameContains  *string                  `json:"-" url:"counterpart_name__contains,omitempty"`
	CounterpartNameIcontains *string                  `json:"-" url:"counterpart_name__icontains,omitempty"`
	SearchText               *string                  `json:"-" url:"search_text,omitempty"`
	DueDate                  *string                  `json:"-" url:"due_date,omitempty"`
	DueDateGt                *string                  `json:"-" url:"due_date__gt,omitempty"`
	DueDateLt                *string                  `json:"-" url:"due_date__lt,omitempty"`
	DueDateGte               *string                  `json:"-" url:"due_date__gte,omitempty"`
	DueDateLte               *string                  `json:"-" url:"due_date__lte,omitempty"`
	DocumentId               *string                  `json:"-" url:"document_id,omitempty"`
	DocumentIdContains       *string                  `json:"-" url:"document_id__contains,omitempty"`
	DocumentIdIcontains      *string                  `json:"-" url:"document_id__icontains,omitempty"`
	WasCreatedByUserId       *string                  `json:"-" url:"was_created_by_user_id,omitempty"`
	CounterpartId            *string                  `json:"-" url:"counterpart_id,omitempty"`
	SourceOfPayableData      *SourceOfPayableDataEnum `json:"-" url:"source_of_payable_data,omitempty"`
	OcrStatus                *OcrStatusEnum           `json:"-" url:"ocr_status,omitempty"`
	// Search for a payable by the identifier of the line item associated with it.
	LineItemId *string `json:"-" url:"line_item_id,omitempty"`
	// Search for a payable by the identifier of the purchase order associated with it.
	PurchaseOrderId *string `json:"-" url:"purchase_order_id,omitempty"`
	// Search for a payable by the identifier of the project associated with it.
	ProjectId *string `json:"-" url:"project_id,omitempty"`
	// Search for a payable by the identifiers of the tags associated with it.
	TagIds []*string `json:"-" url:"tag_ids,omitempty"`
}

type PayablesGetAnalyticsRequest struct {
	CreatedAtGt              *time.Time               `json:"-" url:"created_at__gt,omitempty"`
	CreatedAtLt              *time.Time               `json:"-" url:"created_at__lt,omitempty"`
	CreatedAtGte             *time.Time               `json:"-" url:"created_at__gte,omitempty"`
	CreatedAtLte             *time.Time               `json:"-" url:"created_at__lte,omitempty"`
	Status                   *PayableStateEnum        `json:"-" url:"status,omitempty"`
	StatusIn                 []*PayableStateEnum      `json:"-" url:"status__in,omitempty"`
	IdIn                     []*string                `json:"-" url:"id__in,omitempty"`
	TotalAmount              *int                     `json:"-" url:"total_amount,omitempty"`
	TotalAmountGt            *int                     `json:"-" url:"total_amount__gt,omitempty"`
	TotalAmountLt            *int                     `json:"-" url:"total_amount__lt,omitempty"`
	TotalAmountGte           *int                     `json:"-" url:"total_amount__gte,omitempty"`
	TotalAmountLte           *int                     `json:"-" url:"total_amount__lte,omitempty"`
	Amount                   *int                     `json:"-" url:"amount,omitempty"`
	AmountGt                 *int                     `json:"-" url:"amount__gt,omitempty"`
	AmountLt                 *int                     `json:"-" url:"amount__lt,omitempty"`
	AmountGte                *int                     `json:"-" url:"amount__gte,omitempty"`
	AmountLte                *int                     `json:"-" url:"amount__lte,omitempty"`
	Currency                 *CurrencyEnum            `json:"-" url:"currency,omitempty"`
	CounterpartName          *string                  `json:"-" url:"counterpart_name,omitempty"`
	CounterpartNameContains  *string                  `json:"-" url:"counterpart_name__contains,omitempty"`
	CounterpartNameIcontains *string                  `json:"-" url:"counterpart_name__icontains,omitempty"`
	SearchText               *string                  `json:"-" url:"search_text,omitempty"`
	DueDate                  *string                  `json:"-" url:"due_date,omitempty"`
	DueDateGt                *string                  `json:"-" url:"due_date__gt,omitempty"`
	DueDateLt                *string                  `json:"-" url:"due_date__lt,omitempty"`
	DueDateGte               *string                  `json:"-" url:"due_date__gte,omitempty"`
	DueDateLte               *string                  `json:"-" url:"due_date__lte,omitempty"`
	DocumentId               *string                  `json:"-" url:"document_id,omitempty"`
	DocumentIdContains       *string                  `json:"-" url:"document_id__contains,omitempty"`
	DocumentIdIcontains      *string                  `json:"-" url:"document_id__icontains,omitempty"`
	WasCreatedByUserId       *string                  `json:"-" url:"was_created_by_user_id,omitempty"`
	CounterpartId            *string                  `json:"-" url:"counterpart_id,omitempty"`
	SourceOfPayableData      *SourceOfPayableDataEnum `json:"-" url:"source_of_payable_data,omitempty"`
	OcrStatus                *OcrStatusEnum           `json:"-" url:"ocr_status,omitempty"`
	// Search for a payable by the identifier of the line item associated with it.
	LineItemId *string `json:"-" url:"line_item_id,omitempty"`
	// Search for a payable by the identifier of the purchase order associated with it.
	PurchaseOrderId *string `json:"-" url:"purchase_order_id,omitempty"`
	// Search for a payable by the identifier of the project associated with it.
	ProjectId *string `json:"-" url:"project_id,omitempty"`
	// Search for a payable by the identifiers of the tags associated with it.
	TagIds []*string `json:"-" url:"tag_ids,omitempty"`
}

type CommentPayload struct {
	// An arbitrary comment that describes how and when this payable was paid.
	Comment *string `json:"comment,omitempty" url:"-"`
}

type PartiallyPaidPayload struct {
	// How much was paid on the invoice (in minor units).
	AmountPaid int `json:"amount_paid" url:"-"`
}

// Address information.
type CounterpartRawAddress struct {
	// City name.
	City *string `json:"city,omitempty" url:"city,omitempty"`
	// Two-letter ISO country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
	Country *AllowedCountries `json:"country,omitempty" url:"country,omitempty"`
	// Street address.
	Line1 *string `json:"line1,omitempty" url:"line1,omitempty"`
	// Additional address information (if any).
	Line2 *string `json:"line2,omitempty" url:"line2,omitempty"`
	// ZIP or postal code.
	PostalCode *string `json:"postal_code,omitempty" url:"postal_code,omitempty"`
	// State, region, province, or county.
	State *string `json:"state,omitempty" url:"state,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartRawAddress) GetCity() *string {
	if c == nil {
		return nil
	}
	return c.City
}

func (c *CounterpartRawAddress) GetCountry() *AllowedCountries {
	if c == nil {
		return nil
	}
	return c.Country
}

func (c *CounterpartRawAddress) GetLine1() *string {
	if c == nil {
		return nil
	}
	return c.Line1
}

func (c *CounterpartRawAddress) GetLine2() *string {
	if c == nil {
		return nil
	}
	return c.Line2
}

func (c *CounterpartRawAddress) GetPostalCode() *string {
	if c == nil {
		return nil
	}
	return c.PostalCode
}

func (c *CounterpartRawAddress) GetState() *string {
	if c == nil {
		return nil
	}
	return c.State
}

func (c *CounterpartRawAddress) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartRawAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartRawAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartRawAddress(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartRawAddress) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Address information.
type CounterpartRawAddressUpdateRequest struct {
	// City name.
	City *string `json:"city,omitempty" url:"city,omitempty"`
	// Two-letter ISO country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
	Country *AllowedCountries `json:"country,omitempty" url:"country,omitempty"`
	// Street address.
	Line1 *string `json:"line1,omitempty" url:"line1,omitempty"`
	// Additional address information (if any).
	Line2 *string `json:"line2,omitempty" url:"line2,omitempty"`
	// ZIP or postal code.
	PostalCode *string `json:"postal_code,omitempty" url:"postal_code,omitempty"`
	// State, region, province, or county.
	State *string `json:"state,omitempty" url:"state,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartRawAddressUpdateRequest) GetCity() *string {
	if c == nil {
		return nil
	}
	return c.City
}

func (c *CounterpartRawAddressUpdateRequest) GetCountry() *AllowedCountries {
	if c == nil {
		return nil
	}
	return c.Country
}

func (c *CounterpartRawAddressUpdateRequest) GetLine1() *string {
	if c == nil {
		return nil
	}
	return c.Line1
}

func (c *CounterpartRawAddressUpdateRequest) GetLine2() *string {
	if c == nil {
		return nil
	}
	return c.Line2
}

func (c *CounterpartRawAddressUpdateRequest) GetPostalCode() *string {
	if c == nil {
		return nil
	}
	return c.PostalCode
}

func (c *CounterpartRawAddressUpdateRequest) GetState() *string {
	if c == nil {
		return nil
	}
	return c.State
}

func (c *CounterpartRawAddressUpdateRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartRawAddressUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartRawAddressUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartRawAddressUpdateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartRawAddressUpdateRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartRawBankAccount struct {
	// Vendor's bank account name.
	AccountHolderName *string `json:"account_holder_name,omitempty" url:"account_holder_name,omitempty"`
	// Vendor's bank account number, IBAN, or similar (if specified in the payable document).
	AccountNumber *string `json:"account_number,omitempty" url:"account_number,omitempty"`
	// SWIFT code (BIC) of the vendor's bank.
	Bic *string `json:"bic,omitempty" url:"bic,omitempty"`
	// required for non-GB bank accounts
	Iban *string `json:"iban,omitempty" url:"iban,omitempty"`
	// required for GB bank accounts
	SortCode *string `json:"sort_code,omitempty" url:"sort_code,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartRawBankAccount) GetAccountHolderName() *string {
	if c == nil {
		return nil
	}
	return c.AccountHolderName
}

func (c *CounterpartRawBankAccount) GetAccountNumber() *string {
	if c == nil {
		return nil
	}
	return c.AccountNumber
}

func (c *CounterpartRawBankAccount) GetBic() *string {
	if c == nil {
		return nil
	}
	return c.Bic
}

func (c *CounterpartRawBankAccount) GetIban() *string {
	if c == nil {
		return nil
	}
	return c.Iban
}

func (c *CounterpartRawBankAccount) GetSortCode() *string {
	if c == nil {
		return nil
	}
	return c.SortCode
}

func (c *CounterpartRawBankAccount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartRawBankAccount) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartRawBankAccount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartRawBankAccount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartRawBankAccount) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartRawBankAccountUpdateRequest struct {
	// Vendor's bank account name.
	AccountHolderName *string `json:"account_holder_name,omitempty" url:"account_holder_name,omitempty"`
	// Vendor's bank account number, IBAN, or similar (if specified in the payable document).
	AccountNumber *string `json:"account_number,omitempty" url:"account_number,omitempty"`
	// SWIFT code (BIC) of the vendor's bank.
	Bic *string `json:"bic,omitempty" url:"bic,omitempty"`
	// required for non-GB bank accounts
	Iban *string `json:"iban,omitempty" url:"iban,omitempty"`
	// required for GB bank accounts
	SortCode *string `json:"sort_code,omitempty" url:"sort_code,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartRawBankAccountUpdateRequest) GetAccountHolderName() *string {
	if c == nil {
		return nil
	}
	return c.AccountHolderName
}

func (c *CounterpartRawBankAccountUpdateRequest) GetAccountNumber() *string {
	if c == nil {
		return nil
	}
	return c.AccountNumber
}

func (c *CounterpartRawBankAccountUpdateRequest) GetBic() *string {
	if c == nil {
		return nil
	}
	return c.Bic
}

func (c *CounterpartRawBankAccountUpdateRequest) GetIban() *string {
	if c == nil {
		return nil
	}
	return c.Iban
}

func (c *CounterpartRawBankAccountUpdateRequest) GetSortCode() *string {
	if c == nil {
		return nil
	}
	return c.SortCode
}

func (c *CounterpartRawBankAccountUpdateRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartRawBankAccountUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartRawBankAccountUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartRawBankAccountUpdateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartRawBankAccountUpdateRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartRawData struct {
	// The address of the vendor or supplier.
	Address *CounterpartRawAddress `json:"address,omitempty" url:"address,omitempty"`
	// Object representing counterpart bank account.
	BankAccount *CounterpartRawBankAccount `json:"bank_account,omitempty" url:"bank_account,omitempty"`
	// The email address of the organization
	Email *string `json:"email,omitempty" url:"email,omitempty"`
	// Vendor or supplier name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The phone number of the organization
	Phone *string `json:"phone,omitempty" url:"phone,omitempty"`
	// The tax id of the counterpart.
	TaxId *string `json:"tax_id,omitempty" url:"tax_id,omitempty"`
	// VAT ID of the vendor or supplier which was used in the invoice.
	VatId *CounterpartRawVatId `json:"vat_id,omitempty" url:"vat_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartRawData) GetAddress() *CounterpartRawAddress {
	if c == nil {
		return nil
	}
	return c.Address
}

func (c *CounterpartRawData) GetBankAccount() *CounterpartRawBankAccount {
	if c == nil {
		return nil
	}
	return c.BankAccount
}

func (c *CounterpartRawData) GetEmail() *string {
	if c == nil {
		return nil
	}
	return c.Email
}

func (c *CounterpartRawData) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CounterpartRawData) GetPhone() *string {
	if c == nil {
		return nil
	}
	return c.Phone
}

func (c *CounterpartRawData) GetTaxId() *string {
	if c == nil {
		return nil
	}
	return c.TaxId
}

func (c *CounterpartRawData) GetVatId() *CounterpartRawVatId {
	if c == nil {
		return nil
	}
	return c.VatId
}

func (c *CounterpartRawData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartRawData) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartRawData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartRawData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartRawData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartRawDataUpdateRequest struct {
	// The address of the vendor or supplier.
	Address *CounterpartRawAddressUpdateRequest `json:"address,omitempty" url:"address,omitempty"`
	// Object representing counterpart bank account.
	BankAccount *CounterpartRawBankAccountUpdateRequest `json:"bank_account,omitempty" url:"bank_account,omitempty"`
	// The email address of the organization
	Email *string `json:"email,omitempty" url:"email,omitempty"`
	// Vendor or supplier name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The phone number of the organization
	Phone *string `json:"phone,omitempty" url:"phone,omitempty"`
	// The tax id of the counterpart.
	TaxId *string `json:"tax_id,omitempty" url:"tax_id,omitempty"`
	// VAT ID of the vendor or supplier which was used in the invoice.
	VatId *CounterpartRawVatIdUpdateRequest `json:"vat_id,omitempty" url:"vat_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartRawDataUpdateRequest) GetAddress() *CounterpartRawAddressUpdateRequest {
	if c == nil {
		return nil
	}
	return c.Address
}

func (c *CounterpartRawDataUpdateRequest) GetBankAccount() *CounterpartRawBankAccountUpdateRequest {
	if c == nil {
		return nil
	}
	return c.BankAccount
}

func (c *CounterpartRawDataUpdateRequest) GetEmail() *string {
	if c == nil {
		return nil
	}
	return c.Email
}

func (c *CounterpartRawDataUpdateRequest) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CounterpartRawDataUpdateRequest) GetPhone() *string {
	if c == nil {
		return nil
	}
	return c.Phone
}

func (c *CounterpartRawDataUpdateRequest) GetTaxId() *string {
	if c == nil {
		return nil
	}
	return c.TaxId
}

func (c *CounterpartRawDataUpdateRequest) GetVatId() *CounterpartRawVatIdUpdateRequest {
	if c == nil {
		return nil
	}
	return c.VatId
}

func (c *CounterpartRawDataUpdateRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartRawDataUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartRawDataUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartRawDataUpdateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartRawDataUpdateRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartRawVatId struct {
	Country *AllowedCountries `json:"country,omitempty" url:"country,omitempty"`
	Type    *string           `json:"type,omitempty" url:"type,omitempty"`
	Value   *string           `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartRawVatId) GetCountry() *AllowedCountries {
	if c == nil {
		return nil
	}
	return c.Country
}

func (c *CounterpartRawVatId) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CounterpartRawVatId) GetValue() *string {
	if c == nil {
		return nil
	}
	return c.Value
}

func (c *CounterpartRawVatId) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartRawVatId) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartRawVatId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartRawVatId(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartRawVatId) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartRawVatIdUpdateRequest struct {
	Country *AllowedCountries `json:"country,omitempty" url:"country,omitempty"`
	Type    *string           `json:"type,omitempty" url:"type,omitempty"`
	Value   *string           `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartRawVatIdUpdateRequest) GetCountry() *AllowedCountries {
	if c == nil {
		return nil
	}
	return c.Country
}

func (c *CounterpartRawVatIdUpdateRequest) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CounterpartRawVatIdUpdateRequest) GetValue() *string {
	if c == nil {
		return nil
	}
	return c.Value
}

func (c *CounterpartRawVatIdUpdateRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartRawVatIdUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartRawVatIdUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartRawVatIdUpdateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartRawVatIdUpdateRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CurrencyExchangeSchema struct {
	DefaultCurrencyCode string  `json:"default_currency_code" url:"default_currency_code"`
	Rate                float64 `json:"rate" url:"rate"`
	Total               float64 `json:"total" url:"total"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CurrencyExchangeSchema) GetDefaultCurrencyCode() string {
	if c == nil {
		return ""
	}
	return c.DefaultCurrencyCode
}

func (c *CurrencyExchangeSchema) GetRate() float64 {
	if c == nil {
		return 0
	}
	return c.Rate
}

func (c *CurrencyExchangeSchema) GetTotal() float64 {
	if c == nil {
		return 0
	}
	return c.Total
}

func (c *CurrencyExchangeSchema) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CurrencyExchangeSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler CurrencyExchangeSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CurrencyExchangeSchema(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CurrencyExchangeSchema) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Contains information about a text block or line extracted from an uploaded document by OCR.
type Item struct {
	// The text as recognized by OCR.
	Text string `json:"text" url:"text"`
	// OCR confidence score - the estimated accuracy percentage of character recognition of the extracted text, from 0 to 100%.
	Confidence    float64     `json:"confidence" url:"confidence"`
	ProcessedText interface{} `json:"processed_text,omitempty" url:"processed_text,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *Item) GetText() string {
	if i == nil {
		return ""
	}
	return i.Text
}

func (i *Item) GetConfidence() float64 {
	if i == nil {
		return 0
	}
	return i.Confidence
}

func (i *Item) GetProcessedText() interface{} {
	if i == nil {
		return nil
	}
	return i.ProcessedText
}

func (i *Item) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Item) UnmarshalJSON(data []byte) error {
	type unmarshaler Item
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Item(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *Item) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// A label-value pair extracted from an uploaded document by OCR.
// For example, the label could be "Total" and the value could be a currency amount.
type LabelNValue struct {
	// Text label.
	Label *Item `json:"label" url:"label"`
	// The value (if any).
	Value *Item `json:"value" url:"value"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LabelNValue) GetLabel() *Item {
	if l == nil {
		return nil
	}
	return l.Label
}

func (l *LabelNValue) GetValue() *Item {
	if l == nil {
		return nil
	}
	return l.Value
}

func (l *LabelNValue) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LabelNValue) UnmarshalJSON(data []byte) error {
	type unmarshaler LabelNValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabelNValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabelNValue) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// In general it's compatible with CounterpartAddress model but
// * All fields are optional
// * There is an additional field original_country_name
type OcrAddress struct {
	// Two-letter ISO country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
	Country *string `json:"country,omitempty" url:"country,omitempty"`
	// Country name as it is stated in the document.
	OriginalCountryName *string `json:"original_country_name,omitempty" url:"original_country_name,omitempty"`
	// City name.
	City *string `json:"city,omitempty" url:"city,omitempty"`
	// ZIP or postal code.
	PostalCode *string `json:"postal_code,omitempty" url:"postal_code,omitempty"`
	// State, region, province, or county.
	State *string `json:"state,omitempty" url:"state,omitempty"`
	// Street address.
	Line1 *string `json:"line1,omitempty" url:"line1,omitempty"`
	// Additional address information (if any).
	Line2 *string `json:"line2,omitempty" url:"line2,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrAddress) GetCountry() *string {
	if o == nil {
		return nil
	}
	return o.Country
}

func (o *OcrAddress) GetOriginalCountryName() *string {
	if o == nil {
		return nil
	}
	return o.OriginalCountryName
}

func (o *OcrAddress) GetCity() *string {
	if o == nil {
		return nil
	}
	return o.City
}

func (o *OcrAddress) GetPostalCode() *string {
	if o == nil {
		return nil
	}
	return o.PostalCode
}

func (o *OcrAddress) GetState() *string {
	if o == nil {
		return nil
	}
	return o.State
}

func (o *OcrAddress) GetLine1() *string {
	if o == nil {
		return nil
	}
	return o.Line1
}

func (o *OcrAddress) GetLine2() *string {
	if o == nil {
		return nil
	}
	return o.Line2
}

func (o *OcrAddress) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrAddress(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrAddress) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Contains information about all text blocks extracted from an uploaded invoice by OCR.
// The text blocks are grouped into `line_items` (invoice line items) and `summary` (all other information).
// Legacy schema used for AWS textract recognition.
type OcrRecognitionResponse struct {
	// Invoice text content other than the line items. Such as the invoice issue and due dates, vendor name and address, and other general information.
	Summary []*LabelNValue `json:"summary,omitempty" url:"summary,omitempty"`
	// Text content of the invoice line items as recognized by OCR.
	LineItems []*LabelNValue `json:"line_items,omitempty" url:"line_items,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrRecognitionResponse) GetSummary() []*LabelNValue {
	if o == nil {
		return nil
	}
	return o.Summary
}

func (o *OcrRecognitionResponse) GetLineItems() []*LabelNValue {
	if o == nil {
		return nil
	}
	return o.LineItems
}

func (o *OcrRecognitionResponse) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrRecognitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrRecognitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrRecognitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrRecognitionResponse) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OcrResponseInvoiceReceiptData struct {
	// Total in cents/eurocents. Outdated, actual conversion happens in payables.
	Total *int `json:"total,omitempty" url:"total,omitempty"`
	// Total, without minor units
	TotalRaw *float64 `json:"total_raw,omitempty" url:"total_raw,omitempty"`
	// Subtotal cents/eurocents. Outdated, actual conversion happens in payables.
	TotalExclVat *int `json:"total_excl_vat,omitempty" url:"total_excl_vat,omitempty"`
	// Subtotal, without minor units
	TotalExclVatRaw *float64 `json:"total_excl_vat_raw,omitempty" url:"total_excl_vat_raw,omitempty"`
	// VAT amount in cents. Outdated, actual conversion happens in payables.
	TotalVatAmount *int `json:"total_vat_amount,omitempty" url:"total_vat_amount,omitempty"`
	// VAT amount, without minor units
	TotalVatAmountRaw *float64 `json:"total_vat_amount_raw,omitempty" url:"total_vat_amount_raw,omitempty"`
	// VAT Percent minor units. Example: 12.5% is 1250. Outdated, actual conversion happens in payables.
	TotalVatRate *int `json:"total_vat_rate,omitempty" url:"total_vat_rate,omitempty"`
	// VAT Percent raw, without minor units.
	TotalVatRateRaw *float64 `json:"total_vat_rate_raw,omitempty" url:"total_vat_rate_raw,omitempty"`
	// ISO 4217 currency code
	Currency *string `json:"currency,omitempty" url:"currency,omitempty"`
	// Purchase Order Number
	PurchaseOrderNumber *string `json:"purchase_order_number,omitempty" url:"purchase_order_number,omitempty"`
	// Counterpart name
	CounterpartName *string `json:"counterpart_name,omitempty" url:"counterpart_name,omitempty"`
	// Counterpart address
	CounterpartAddress *string `json:"counterpart_address,omitempty" url:"counterpart_address,omitempty"`
	// Counterpart bank ID
	CounterpartAccountId *string `json:"counterpart_account_id,omitempty" url:"counterpart_account_id,omitempty"`
	// Invoice/receipt ID
	DocumentId *string `json:"document_id,omitempty" url:"document_id,omitempty"`
	// Raw payment terms parsed but not calculated.
	PaymentTermsRaw []string `json:"payment_terms_raw,omitempty" url:"payment_terms_raw,omitempty"`
	// Tax payer ID
	TaxPayerId *string `json:"tax_payer_id,omitempty" url:"tax_payer_id,omitempty"`
	// Counterpart VAT ID
	CounterpartVatId *string `json:"counterpart_vat_id,omitempty" url:"counterpart_vat_id,omitempty"`
	// Document issuance date in ISO format
	DocumentIssuedAtDate *string `json:"document_issued_at_date,omitempty" url:"document_issued_at_date,omitempty"`
	// Document due date in ISO format
	DocumentDueDate *string `json:"document_due_date,omitempty" url:"document_due_date,omitempty"`
	// Counterpart address as a json object compatible with counterparts service
	CounterpartAddressObject *OcrAddress `json:"counterpart_address_object,omitempty" url:"counterpart_address_object,omitempty"`
	// The bank account number
	CounterpartAccountNumber *string `json:"counterpart_account_number,omitempty" url:"counterpart_account_number,omitempty"`
	// The bank routing number
	CounterpartRoutingNumber *string `json:"counterpart_routing_number,omitempty" url:"counterpart_routing_number,omitempty"`
	// List of line items from document. Outdated, actual conversion happens in payables.
	LineItems []*OcrResponseInvoiceReceiptLineItem `json:"line_items,omitempty" url:"line_items,omitempty"`
	// List of line items from document raw, without minor units conversion.
	LineItemsRaw []*OcrResponseInvoiceReceiptLineItemRaw `json:"line_items_raw,omitempty" url:"line_items_raw,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrResponseInvoiceReceiptData) GetTotal() *int {
	if o == nil {
		return nil
	}
	return o.Total
}

func (o *OcrResponseInvoiceReceiptData) GetTotalRaw() *float64 {
	if o == nil {
		return nil
	}
	return o.TotalRaw
}

func (o *OcrResponseInvoiceReceiptData) GetTotalExclVat() *int {
	if o == nil {
		return nil
	}
	return o.TotalExclVat
}

func (o *OcrResponseInvoiceReceiptData) GetTotalExclVatRaw() *float64 {
	if o == nil {
		return nil
	}
	return o.TotalExclVatRaw
}

func (o *OcrResponseInvoiceReceiptData) GetTotalVatAmount() *int {
	if o == nil {
		return nil
	}
	return o.TotalVatAmount
}

func (o *OcrResponseInvoiceReceiptData) GetTotalVatAmountRaw() *float64 {
	if o == nil {
		return nil
	}
	return o.TotalVatAmountRaw
}

func (o *OcrResponseInvoiceReceiptData) GetTotalVatRate() *int {
	if o == nil {
		return nil
	}
	return o.TotalVatRate
}

func (o *OcrResponseInvoiceReceiptData) GetTotalVatRateRaw() *float64 {
	if o == nil {
		return nil
	}
	return o.TotalVatRateRaw
}

func (o *OcrResponseInvoiceReceiptData) GetCurrency() *string {
	if o == nil {
		return nil
	}
	return o.Currency
}

func (o *OcrResponseInvoiceReceiptData) GetPurchaseOrderNumber() *string {
	if o == nil {
		return nil
	}
	return o.PurchaseOrderNumber
}

func (o *OcrResponseInvoiceReceiptData) GetCounterpartName() *string {
	if o == nil {
		return nil
	}
	return o.CounterpartName
}

func (o *OcrResponseInvoiceReceiptData) GetCounterpartAddress() *string {
	if o == nil {
		return nil
	}
	return o.CounterpartAddress
}

func (o *OcrResponseInvoiceReceiptData) GetCounterpartAccountId() *string {
	if o == nil {
		return nil
	}
	return o.CounterpartAccountId
}

func (o *OcrResponseInvoiceReceiptData) GetDocumentId() *string {
	if o == nil {
		return nil
	}
	return o.DocumentId
}

func (o *OcrResponseInvoiceReceiptData) GetPaymentTermsRaw() []string {
	if o == nil {
		return nil
	}
	return o.PaymentTermsRaw
}

func (o *OcrResponseInvoiceReceiptData) GetTaxPayerId() *string {
	if o == nil {
		return nil
	}
	return o.TaxPayerId
}

func (o *OcrResponseInvoiceReceiptData) GetCounterpartVatId() *string {
	if o == nil {
		return nil
	}
	return o.CounterpartVatId
}

func (o *OcrResponseInvoiceReceiptData) GetDocumentIssuedAtDate() *string {
	if o == nil {
		return nil
	}
	return o.DocumentIssuedAtDate
}

func (o *OcrResponseInvoiceReceiptData) GetDocumentDueDate() *string {
	if o == nil {
		return nil
	}
	return o.DocumentDueDate
}

func (o *OcrResponseInvoiceReceiptData) GetCounterpartAddressObject() *OcrAddress {
	if o == nil {
		return nil
	}
	return o.CounterpartAddressObject
}

func (o *OcrResponseInvoiceReceiptData) GetCounterpartAccountNumber() *string {
	if o == nil {
		return nil
	}
	return o.CounterpartAccountNumber
}

func (o *OcrResponseInvoiceReceiptData) GetCounterpartRoutingNumber() *string {
	if o == nil {
		return nil
	}
	return o.CounterpartRoutingNumber
}

func (o *OcrResponseInvoiceReceiptData) GetLineItems() []*OcrResponseInvoiceReceiptLineItem {
	if o == nil {
		return nil
	}
	return o.LineItems
}

func (o *OcrResponseInvoiceReceiptData) GetLineItemsRaw() []*OcrResponseInvoiceReceiptLineItemRaw {
	if o == nil {
		return nil
	}
	return o.LineItemsRaw
}

func (o *OcrResponseInvoiceReceiptData) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrResponseInvoiceReceiptData) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrResponseInvoiceReceiptData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrResponseInvoiceReceiptData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrResponseInvoiceReceiptData) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OcrResponseInvoiceReceiptLineItem struct {
	// OCR Id of line item
	LineItemOcrId *string `json:"line_item_ocr_id,omitempty" url:"line_item_ocr_id,omitempty"`
	// Human-readable line item description
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Quanity
	Quantity *float64 `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Price in  cents/eurocents
	UnitPrice *int `json:"unit_price,omitempty" url:"unit_price,omitempty"`
	// Unit
	Unit *string `json:"unit,omitempty" url:"unit,omitempty"`
	// VAT Percent minor units. Example: 12.5% is 1250.
	VatPercentage *int `json:"vat_percentage,omitempty" url:"vat_percentage,omitempty"`
	// VAT Amount minor units.
	VatAmount *int `json:"vat_amount,omitempty" url:"vat_amount,omitempty"`
	// Total excl VAT
	TotalExclVat *int `json:"total_excl_vat,omitempty" url:"total_excl_vat,omitempty"`
	// Total included VAT
	TotalInclVat *int `json:"total_incl_vat,omitempty" url:"total_incl_vat,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrResponseInvoiceReceiptLineItem) GetLineItemOcrId() *string {
	if o == nil {
		return nil
	}
	return o.LineItemOcrId
}

func (o *OcrResponseInvoiceReceiptLineItem) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OcrResponseInvoiceReceiptLineItem) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *OcrResponseInvoiceReceiptLineItem) GetUnitPrice() *int {
	if o == nil {
		return nil
	}
	return o.UnitPrice
}

func (o *OcrResponseInvoiceReceiptLineItem) GetUnit() *string {
	if o == nil {
		return nil
	}
	return o.Unit
}

func (o *OcrResponseInvoiceReceiptLineItem) GetVatPercentage() *int {
	if o == nil {
		return nil
	}
	return o.VatPercentage
}

func (o *OcrResponseInvoiceReceiptLineItem) GetVatAmount() *int {
	if o == nil {
		return nil
	}
	return o.VatAmount
}

func (o *OcrResponseInvoiceReceiptLineItem) GetTotalExclVat() *int {
	if o == nil {
		return nil
	}
	return o.TotalExclVat
}

func (o *OcrResponseInvoiceReceiptLineItem) GetTotalInclVat() *int {
	if o == nil {
		return nil
	}
	return o.TotalInclVat
}

func (o *OcrResponseInvoiceReceiptLineItem) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrResponseInvoiceReceiptLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrResponseInvoiceReceiptLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrResponseInvoiceReceiptLineItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrResponseInvoiceReceiptLineItem) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OcrResponseInvoiceReceiptLineItemRaw struct {
	// OCR Id of line item
	LineItemOcrId *string `json:"line_item_ocr_id,omitempty" url:"line_item_ocr_id,omitempty"`
	// Human-readable line item description
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Quanity
	Quantity *float64 `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Price as parsed
	UnitPrice *float64 `json:"unit_price,omitempty" url:"unit_price,omitempty"`
	// Unit
	Unit *string `json:"unit,omitempty" url:"unit,omitempty"`
	// VAT Percent as parsed.
	VatPercentage *float64 `json:"vat_percentage,omitempty" url:"vat_percentage,omitempty"`
	// VAT Amount as parsed.
	VatAmount *float64 `json:"vat_amount,omitempty" url:"vat_amount,omitempty"`
	// Total excluded VAT as parsed.
	TotalExclVat *float64 `json:"total_excl_vat,omitempty" url:"total_excl_vat,omitempty"`
	// Total included VAT as parsed.
	TotalInclVat *float64 `json:"total_incl_vat,omitempty" url:"total_incl_vat,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetLineItemOcrId() *string {
	if o == nil {
		return nil
	}
	return o.LineItemOcrId
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetUnitPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.UnitPrice
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetUnit() *string {
	if o == nil {
		return nil
	}
	return o.Unit
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetVatPercentage() *float64 {
	if o == nil {
		return nil
	}
	return o.VatPercentage
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetVatAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.VatAmount
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetTotalExclVat() *float64 {
	if o == nil {
		return nil
	}
	return o.TotalExclVat
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetTotalInclVat() *float64 {
	if o == nil {
		return nil
	}
	return o.TotalInclVat
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrResponseInvoiceReceiptLineItemRaw
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrResponseInvoiceReceiptLineItemRaw(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrResponseInvoiceReceiptLineItemRaw) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OcrStatusEnum string

const (
	OcrStatusEnumProcessing OcrStatusEnum = "processing"
	OcrStatusEnumError      OcrStatusEnum = "error"
	OcrStatusEnumSuccess    OcrStatusEnum = "success"
)

func NewOcrStatusEnumFromString(s string) (OcrStatusEnum, error) {
	switch s {
	case "processing":
		return OcrStatusEnumProcessing, nil
	case "error":
		return OcrStatusEnumError, nil
	case "success":
		return OcrStatusEnumSuccess, nil
	}
	var t OcrStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OcrStatusEnum) Ptr() *OcrStatusEnum {
	return &o
}

type PayableAggregatedDataResponse struct {
	// The total count of payables across all statuses.
	Count int `json:"count" url:"count"`
	// A list of aggregated items, each representing a status with its associated sum of the amount field and count.
	Data []*PayableAggregatedItem `json:"data" url:"data"`
	// The total sum of the amount field for all payables across all statuses.
	SumTotalAmount int `json:"sum_total_amount" url:"sum_total_amount"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableAggregatedDataResponse) GetCount() int {
	if p == nil {
		return 0
	}
	return p.Count
}

func (p *PayableAggregatedDataResponse) GetData() []*PayableAggregatedItem {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PayableAggregatedDataResponse) GetSumTotalAmount() int {
	if p == nil {
		return 0
	}
	return p.SumTotalAmount
}

func (p *PayableAggregatedDataResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableAggregatedDataResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PayableAggregatedDataResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayableAggregatedDataResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableAggregatedDataResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayableAggregatedItem struct {
	// The total count of payables with this specific status.
	Count int `json:"count" url:"count"`
	// The status of the payable (e.g., paid, draft, etc.).
	Status PayableStateEnum `json:"status" url:"status"`
	// The total sum of the amount field for all payables with this specific status.
	SumTotalAmount int `json:"sum_total_amount" url:"sum_total_amount"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableAggregatedItem) GetCount() int {
	if p == nil {
		return 0
	}
	return p.Count
}

func (p *PayableAggregatedItem) GetStatus() PayableStateEnum {
	if p == nil {
		return ""
	}
	return p.Status
}

func (p *PayableAggregatedItem) GetSumTotalAmount() int {
	if p == nil {
		return 0
	}
	return p.SumTotalAmount
}

func (p *PayableAggregatedItem) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableAggregatedItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PayableAggregatedItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayableAggregatedItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableAggregatedItem) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayableCursorFields string

const (
	PayableCursorFieldsId        PayableCursorFields = "id"
	PayableCursorFieldsCreatedAt PayableCursorFields = "created_at"
)

func NewPayableCursorFieldsFromString(s string) (PayableCursorFields, error) {
	switch s {
	case "id":
		return PayableCursorFieldsId, nil
	case "created_at":
		return PayableCursorFieldsCreatedAt, nil
	}
	var t PayableCursorFields
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayableCursorFields) Ptr() *PayableCursorFields {
	return &p
}

type PayableOriginEnum string

const (
	PayableOriginEnumUpload PayableOriginEnum = "upload"
	PayableOriginEnumEmail  PayableOriginEnum = "email"
)

func NewPayableOriginEnumFromString(s string) (PayableOriginEnum, error) {
	switch s {
	case "upload":
		return PayableOriginEnumUpload, nil
	case "email":
		return PayableOriginEnumEmail, nil
	}
	var t PayableOriginEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayableOriginEnum) Ptr() *PayableOriginEnum {
	return &p
}

// A paginated list of payables.
type PayablePaginationResponse struct {
	Data []*PayableResponseSchema `json:"data" url:"data"`
	// A token that can be sent in the `pagination_token` query parameter to get the next page of results, or `null` if there is no next page (i.e. you've reached the last page).
	NextPaginationToken *string `json:"next_pagination_token,omitempty" url:"next_pagination_token,omitempty"`
	// A token that can be sent in the `pagination_token` query parameter to get the previous page of results, or `null` if there is no previous page (i.e. you've reached the first page).
	PrevPaginationToken *string `json:"prev_pagination_token,omitempty" url:"prev_pagination_token,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayablePaginationResponse) GetData() []*PayableResponseSchema {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PayablePaginationResponse) GetNextPaginationToken() *string {
	if p == nil {
		return nil
	}
	return p.NextPaginationToken
}

func (p *PayablePaginationResponse) GetPrevPaginationToken() *string {
	if p == nil {
		return nil
	}
	return p.PrevPaginationToken
}

func (p *PayablePaginationResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayablePaginationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PayablePaginationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayablePaginationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayablePaginationResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayablePaymentTermDiscount struct {
	// The discount percentage in minor units. E.g., 200 means 2%, 1050 means 10.5%.
	Discount int `json:"discount" url:"discount"`
	// The amount of days after the invoice issue date.
	NumberOfDays int `json:"number_of_days" url:"number_of_days"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayablePaymentTermDiscount) GetDiscount() int {
	if p == nil {
		return 0
	}
	return p.Discount
}

func (p *PayablePaymentTermDiscount) GetNumberOfDays() int {
	if p == nil {
		return 0
	}
	return p.NumberOfDays
}

func (p *PayablePaymentTermDiscount) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayablePaymentTermDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler PayablePaymentTermDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayablePaymentTermDiscount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayablePaymentTermDiscount) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayablePaymentTermFinal struct {
	// The amount of days after the invoice issue date.
	NumberOfDays int `json:"number_of_days" url:"number_of_days"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayablePaymentTermFinal) GetNumberOfDays() int {
	if p == nil {
		return 0
	}
	return p.NumberOfDays
}

func (p *PayablePaymentTermFinal) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayablePaymentTermFinal) UnmarshalJSON(data []byte) error {
	type unmarshaler PayablePaymentTermFinal
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayablePaymentTermFinal(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayablePaymentTermFinal) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayablePaymentTermsCreatePayload struct {
	Description *string                     `json:"description,omitempty" url:"description,omitempty"`
	Name        string                      `json:"name" url:"name"`
	Term1       *PayablePaymentTermDiscount `json:"term_1,omitempty" url:"term_1,omitempty"`
	Term2       *PayablePaymentTermDiscount `json:"term_2,omitempty" url:"term_2,omitempty"`
	TermFinal   *PayablePaymentTermFinal    `json:"term_final" url:"term_final"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayablePaymentTermsCreatePayload) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PayablePaymentTermsCreatePayload) GetName() string {
	if p == nil {
		return ""
	}
	return p.Name
}

func (p *PayablePaymentTermsCreatePayload) GetTerm1() *PayablePaymentTermDiscount {
	if p == nil {
		return nil
	}
	return p.Term1
}

func (p *PayablePaymentTermsCreatePayload) GetTerm2() *PayablePaymentTermDiscount {
	if p == nil {
		return nil
	}
	return p.Term2
}

func (p *PayablePaymentTermsCreatePayload) GetTermFinal() *PayablePaymentTermFinal {
	if p == nil {
		return nil
	}
	return p.TermFinal
}

func (p *PayablePaymentTermsCreatePayload) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayablePaymentTermsCreatePayload) UnmarshalJSON(data []byte) error {
	type unmarshaler PayablePaymentTermsCreatePayload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayablePaymentTermsCreatePayload(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayablePaymentTermsCreatePayload) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents an Accounts Payable document received from a vendor or supplier.
type PayableResponseSchema struct {
	// A unique ID assigned to this payable.
	Id string `json:"id" url:"id"`
	// UTC date and time when this payable was created. Timestamps follow the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// UTC date and time when this payable was last updated. Timestamps follow the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	// How much is left to be paid on the invoice (in minor units).
	AmountDue *int `json:"amount_due,omitempty" url:"amount_due,omitempty"`
	// How much was paid on the invoice (in minor units).
	AmountPaid *int `json:"amount_paid,omitempty" url:"amount_paid,omitempty"`
	// How much is left to be paid on the invoice (in minor units) with discounts from payment terms.
	AmountToPay *int `json:"amount_to_pay,omitempty" url:"amount_to_pay,omitempty"`
	// Id of existing approval policy that applies to this payable, if any. A policy is applied if the payable matches the policy trigger conditions.
	ApprovalPolicyId *string `json:"approval_policy_id,omitempty" url:"approval_policy_id,omitempty"`
	// Object representing de-normalized counterpart data. Filled at the moment of invoice submitting for approval or payment.
	Counterpart *CounterpartRawData `json:"counterpart,omitempty" url:"counterpart,omitempty"`
	// The ID of counterpart address object stored in counterparts service
	CounterpartAddressId *string `json:"counterpart_address_id,omitempty" url:"counterpart_address_id,omitempty"`
	// The ID of counterpart bank account object stored in counterparts service
	CounterpartBankAccountId *string `json:"counterpart_bank_account_id,omitempty" url:"counterpart_bank_account_id,omitempty"`
	// The ID of the counterpart object that represents the vendor or supplier.
	CounterpartId *string `json:"counterpart_id,omitempty" url:"counterpart_id,omitempty"`
	// Object representing counterpart data which was extracted by OCR. Used for informational purposes.
	CounterpartRawData *CounterpartRawData `json:"counterpart_raw_data,omitempty" url:"counterpart_raw_data,omitempty"`
	// The ID of counterpart VAT ID object stored in counterparts service
	CounterpartVatIdId *string `json:"counterpart_vat_id_id,omitempty" url:"counterpart_vat_id_id,omitempty"`
	// The ID of the role that the entity user who created this payable had at that time. If the payable was created using a partner access token, the value is `null`.
	CreatedByRoleId *string `json:"created_by_role_id,omitempty" url:"created_by_role_id,omitempty"`
	// The [currency code](https://docs.monite.com/docs/currencies) of the currency used in the payable.
	Currency         *CurrencyEnum           `json:"currency,omitempty" url:"currency,omitempty"`
	CurrencyExchange *CurrencyExchangeSchema `json:"currency_exchange,omitempty" url:"currency_exchange,omitempty"`
	// An arbitrary description of this payable.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A unique invoice number assigned by the invoice issuer for payment tracking purposes. This is different from `id` which is an internal ID created automatically by Monite.
	DocumentId *string `json:"document_id,omitempty" url:"document_id,omitempty"`
	// The date by which the payable must be paid, in the YYYY-MM-DD format. If the payable specifies payment terms with early payment discounts, this is the final payment date.
	DueDate *string `json:"due_date,omitempty" url:"due_date,omitempty"`
	// The ID of the entity to which the payable was issued.
	EntityId string `json:"entity_id" url:"entity_id"`
	// The original file from which this payable was created.
	File *FileSchema3 `json:"file,omitempty" url:"file,omitempty"`
	// File id to retrieve file info from file saver.
	FileId *string `json:"file_id,omitempty" url:"file_id,omitempty"`
	// The date when the payable was issued, in the YYYY-MM-DD format.
	IssuedAt *string `json:"issued_at,omitempty" url:"issued_at,omitempty"`
	// The ID of the entity user who marked this document as paid.
	MarkedAsPaidByEntityUserId *string `json:"marked_as_paid_by_entity_user_id,omitempty" url:"marked_as_paid_by_entity_user_id,omitempty"`
	// An arbitrary comment that describes how and when this payable was paid.
	MarkedAsPaidWithComment *string `json:"marked_as_paid_with_comment,omitempty" url:"marked_as_paid_with_comment,omitempty"`
	// Id of OCR request to match asynchronous result of processing payable.
	OcrRequestId *string `json:"ocr_request_id,omitempty" url:"ocr_request_id,omitempty"`
	// The status of the data recognition process using OCR. The 'processing' status means that the data recognition is in progress and the user needs to wait for the data enrichment. The 'error' status indicates that some error occurred on the OCR side and the user can fill in the data manually. The 'success' status means the data recognition has been successfully completed, after which the user can check the data if desired and enrich or correct it.
	OcrStatus *OcrStatusEnum `json:"ocr_status,omitempty" url:"ocr_status,omitempty"`
	// Data extracted from the uploaded payable by OCR.
	OtherExtractedData *PayableResponseSchemaOtherExtractedData `json:"other_extracted_data,omitempty" url:"other_extracted_data,omitempty"`
	// The date by which the payable was paid
	PaidAt *time.Time `json:"paid_at,omitempty" url:"paid_at,omitempty"`
	// Metadata for partner needs
	PartnerMetadata map[string]interface{} `json:"partner_metadata,omitempty" url:"partner_metadata,omitempty"`
	// Specifies how this payable was created in Monite: `upload` - created via an API call, `email` - sent via email to the entity's mailbox.
	PayableOrigin PayableOriginEnum `json:"payable_origin" url:"payable_origin"`
	// The number of days to pay with potential discount for options shorter than due_date
	PaymentTerms *PayablePaymentTermsCreatePayload `json:"payment_terms,omitempty" url:"payment_terms,omitempty"`
	// Project ID of a payable.
	ProjectId *string `json:"project_id,omitempty" url:"project_id,omitempty"`
	// The identifier of the purchase order to which this payable belongs.
	PurchaseOrderId *string `json:"purchase_order_id,omitempty" url:"purchase_order_id,omitempty"`
	// The email address from which the invoice was sent to the entity.
	Sender *string `json:"sender,omitempty" url:"sender,omitempty"`
	// Specifies how the property values of this payable were provided: `ocr` - Monite OCR service extracted the values from the provided PDF or image file, `user_specified` - values were added or updated via an API call.
	SourceOfPayableData SourceOfPayableDataEnum `json:"source_of_payable_data" url:"source_of_payable_data"`
	// The [status](https://docs.monite.com/docs/payables-lifecycle) of the payable.
	Status PayableStateEnum `json:"status" url:"status"`
	// The subtotal amount to be paid, in [minor units](https://docs.monite.com/docs/currencies#minor-units). For example, $12.50 is represented as 1250.
	Subtotal *int `json:"subtotal,omitempty" url:"subtotal,omitempty"`
	// The suggested date and corresponding discount in which payable could be paid. The date is in the YYYY-MM-DD format. The discount is calculated as X * (10^-4) - for example, 100 is 1%, 25 is 0,25%, 10000 is 100 %. Date varies depending on the payment terms and may even be equal to the due date with discount 0.
	SuggestedPaymentTerm *SuggestedPaymentTerm `json:"suggested_payment_term,omitempty" url:"suggested_payment_term,omitempty"`
	// A list of user-defined tags (labels) assigned to this payable. Tags can be used to trigger a specific approval policy for this payable.
	Tags []*TagReadSchema `json:"tags,omitempty" url:"tags,omitempty"`
	// Registered tax percentage applied for a service price in minor units, e.g. 200 means 2%, 1050 means 10.5%.
	Tax *int `json:"tax,omitempty" url:"tax,omitempty"`
	// Tax amount in [minor units](https://docs.monite.com/docs/currencies#minor-units). For example, $12.50 is represented as 1250.
	TaxAmount *int `json:"tax_amount,omitempty" url:"tax_amount,omitempty"`
	// The total amount to be paid, in [minor units](https://docs.monite.com/docs/currencies#minor-units). For example, $12.50 is represented as 1250.
	TotalAmount        *int    `json:"total_amount,omitempty" url:"total_amount,omitempty"`
	WasCreatedByUserId *string `json:"was_created_by_user_id,omitempty" url:"was_created_by_user_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableResponseSchema) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PayableResponseSchema) GetCreatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.CreatedAt
}

func (p *PayableResponseSchema) GetUpdatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.UpdatedAt
}

func (p *PayableResponseSchema) GetAmountDue() *int {
	if p == nil {
		return nil
	}
	return p.AmountDue
}

func (p *PayableResponseSchema) GetAmountPaid() *int {
	if p == nil {
		return nil
	}
	return p.AmountPaid
}

func (p *PayableResponseSchema) GetAmountToPay() *int {
	if p == nil {
		return nil
	}
	return p.AmountToPay
}

func (p *PayableResponseSchema) GetApprovalPolicyId() *string {
	if p == nil {
		return nil
	}
	return p.ApprovalPolicyId
}

func (p *PayableResponseSchema) GetCounterpart() *CounterpartRawData {
	if p == nil {
		return nil
	}
	return p.Counterpart
}

func (p *PayableResponseSchema) GetCounterpartAddressId() *string {
	if p == nil {
		return nil
	}
	return p.CounterpartAddressId
}

func (p *PayableResponseSchema) GetCounterpartBankAccountId() *string {
	if p == nil {
		return nil
	}
	return p.CounterpartBankAccountId
}

func (p *PayableResponseSchema) GetCounterpartId() *string {
	if p == nil {
		return nil
	}
	return p.CounterpartId
}

func (p *PayableResponseSchema) GetCounterpartRawData() *CounterpartRawData {
	if p == nil {
		return nil
	}
	return p.CounterpartRawData
}

func (p *PayableResponseSchema) GetCounterpartVatIdId() *string {
	if p == nil {
		return nil
	}
	return p.CounterpartVatIdId
}

func (p *PayableResponseSchema) GetCreatedByRoleId() *string {
	if p == nil {
		return nil
	}
	return p.CreatedByRoleId
}

func (p *PayableResponseSchema) GetCurrency() *CurrencyEnum {
	if p == nil {
		return nil
	}
	return p.Currency
}

func (p *PayableResponseSchema) GetCurrencyExchange() *CurrencyExchangeSchema {
	if p == nil {
		return nil
	}
	return p.CurrencyExchange
}

func (p *PayableResponseSchema) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PayableResponseSchema) GetDocumentId() *string {
	if p == nil {
		return nil
	}
	return p.DocumentId
}

func (p *PayableResponseSchema) GetDueDate() *string {
	if p == nil {
		return nil
	}
	return p.DueDate
}

func (p *PayableResponseSchema) GetEntityId() string {
	if p == nil {
		return ""
	}
	return p.EntityId
}

func (p *PayableResponseSchema) GetFile() *FileSchema3 {
	if p == nil {
		return nil
	}
	return p.File
}

func (p *PayableResponseSchema) GetFileId() *string {
	if p == nil {
		return nil
	}
	return p.FileId
}

func (p *PayableResponseSchema) GetIssuedAt() *string {
	if p == nil {
		return nil
	}
	return p.IssuedAt
}

func (p *PayableResponseSchema) GetMarkedAsPaidByEntityUserId() *string {
	if p == nil {
		return nil
	}
	return p.MarkedAsPaidByEntityUserId
}

func (p *PayableResponseSchema) GetMarkedAsPaidWithComment() *string {
	if p == nil {
		return nil
	}
	return p.MarkedAsPaidWithComment
}

func (p *PayableResponseSchema) GetOcrRequestId() *string {
	if p == nil {
		return nil
	}
	return p.OcrRequestId
}

func (p *PayableResponseSchema) GetOcrStatus() *OcrStatusEnum {
	if p == nil {
		return nil
	}
	return p.OcrStatus
}

func (p *PayableResponseSchema) GetOtherExtractedData() *PayableResponseSchemaOtherExtractedData {
	if p == nil {
		return nil
	}
	return p.OtherExtractedData
}

func (p *PayableResponseSchema) GetPaidAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.PaidAt
}

func (p *PayableResponseSchema) GetPartnerMetadata() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.PartnerMetadata
}

func (p *PayableResponseSchema) GetPayableOrigin() PayableOriginEnum {
	if p == nil {
		return ""
	}
	return p.PayableOrigin
}

func (p *PayableResponseSchema) GetPaymentTerms() *PayablePaymentTermsCreatePayload {
	if p == nil {
		return nil
	}
	return p.PaymentTerms
}

func (p *PayableResponseSchema) GetProjectId() *string {
	if p == nil {
		return nil
	}
	return p.ProjectId
}

func (p *PayableResponseSchema) GetPurchaseOrderId() *string {
	if p == nil {
		return nil
	}
	return p.PurchaseOrderId
}

func (p *PayableResponseSchema) GetSender() *string {
	if p == nil {
		return nil
	}
	return p.Sender
}

func (p *PayableResponseSchema) GetSourceOfPayableData() SourceOfPayableDataEnum {
	if p == nil {
		return ""
	}
	return p.SourceOfPayableData
}

func (p *PayableResponseSchema) GetStatus() PayableStateEnum {
	if p == nil {
		return ""
	}
	return p.Status
}

func (p *PayableResponseSchema) GetSubtotal() *int {
	if p == nil {
		return nil
	}
	return p.Subtotal
}

func (p *PayableResponseSchema) GetSuggestedPaymentTerm() *SuggestedPaymentTerm {
	if p == nil {
		return nil
	}
	return p.SuggestedPaymentTerm
}

func (p *PayableResponseSchema) GetTags() []*TagReadSchema {
	if p == nil {
		return nil
	}
	return p.Tags
}

func (p *PayableResponseSchema) GetTax() *int {
	if p == nil {
		return nil
	}
	return p.Tax
}

func (p *PayableResponseSchema) GetTaxAmount() *int {
	if p == nil {
		return nil
	}
	return p.TaxAmount
}

func (p *PayableResponseSchema) GetTotalAmount() *int {
	if p == nil {
		return nil
	}
	return p.TotalAmount
}

func (p *PayableResponseSchema) GetWasCreatedByUserId() *string {
	if p == nil {
		return nil
	}
	return p.WasCreatedByUserId
}

func (p *PayableResponseSchema) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableResponseSchema) UnmarshalJSON(data []byte) error {
	type embed PayableResponseSchema
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at"`
		UpdatedAt *internal.DateTime `json:"updated_at"`
		PaidAt    *internal.DateTime `json:"paid_at,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PayableResponseSchema(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.Time()
	p.UpdatedAt = unmarshaler.UpdatedAt.Time()
	p.PaidAt = unmarshaler.PaidAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableResponseSchema) MarshalJSON() ([]byte, error) {
	type embed PayableResponseSchema
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at"`
		UpdatedAt *internal.DateTime `json:"updated_at"`
		PaidAt    *internal.DateTime `json:"paid_at,omitempty"`
	}{
		embed:     embed(*p),
		CreatedAt: internal.NewDateTime(p.CreatedAt),
		UpdatedAt: internal.NewDateTime(p.UpdatedAt),
		PaidAt:    internal.NewOptionalDateTime(p.PaidAt),
	}
	return json.Marshal(marshaler)
}

func (p *PayableResponseSchema) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Data extracted from the uploaded payable by OCR.
type PayableResponseSchemaOtherExtractedData struct {
	OcrResponseInvoiceReceiptData *OcrResponseInvoiceReceiptData
	OcrRecognitionResponse        *OcrRecognitionResponse

	typ string
}

func (p *PayableResponseSchemaOtherExtractedData) GetOcrResponseInvoiceReceiptData() *OcrResponseInvoiceReceiptData {
	if p == nil {
		return nil
	}
	return p.OcrResponseInvoiceReceiptData
}

func (p *PayableResponseSchemaOtherExtractedData) GetOcrRecognitionResponse() *OcrRecognitionResponse {
	if p == nil {
		return nil
	}
	return p.OcrRecognitionResponse
}

func (p *PayableResponseSchemaOtherExtractedData) UnmarshalJSON(data []byte) error {
	valueOcrResponseInvoiceReceiptData := new(OcrResponseInvoiceReceiptData)
	if err := json.Unmarshal(data, &valueOcrResponseInvoiceReceiptData); err == nil {
		p.typ = "OcrResponseInvoiceReceiptData"
		p.OcrResponseInvoiceReceiptData = valueOcrResponseInvoiceReceiptData
		return nil
	}
	valueOcrRecognitionResponse := new(OcrRecognitionResponse)
	if err := json.Unmarshal(data, &valueOcrRecognitionResponse); err == nil {
		p.typ = "OcrRecognitionResponse"
		p.OcrRecognitionResponse = valueOcrRecognitionResponse
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PayableResponseSchemaOtherExtractedData) MarshalJSON() ([]byte, error) {
	if p.typ == "OcrResponseInvoiceReceiptData" || p.OcrResponseInvoiceReceiptData != nil {
		return json.Marshal(p.OcrResponseInvoiceReceiptData)
	}
	if p.typ == "OcrRecognitionResponse" || p.OcrRecognitionResponse != nil {
		return json.Marshal(p.OcrRecognitionResponse)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PayableResponseSchemaOtherExtractedDataVisitor interface {
	VisitOcrResponseInvoiceReceiptData(*OcrResponseInvoiceReceiptData) error
	VisitOcrRecognitionResponse(*OcrRecognitionResponse) error
}

func (p *PayableResponseSchemaOtherExtractedData) Accept(visitor PayableResponseSchemaOtherExtractedDataVisitor) error {
	if p.typ == "OcrResponseInvoiceReceiptData" || p.OcrResponseInvoiceReceiptData != nil {
		return visitor.VisitOcrResponseInvoiceReceiptData(p.OcrResponseInvoiceReceiptData)
	}
	if p.typ == "OcrRecognitionResponse" || p.OcrRecognitionResponse != nil {
		return visitor.VisitOcrRecognitionResponse(p.OcrRecognitionResponse)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PayableTemplatesVariable struct {
	Description string `json:"description" url:"description"`
	Name        string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableTemplatesVariable) GetDescription() string {
	if p == nil {
		return ""
	}
	return p.Description
}

func (p *PayableTemplatesVariable) GetName() string {
	if p == nil {
		return ""
	}
	return p.Name
}

func (p *PayableTemplatesVariable) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableTemplatesVariable) UnmarshalJSON(data []byte) error {
	type unmarshaler PayableTemplatesVariable
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayableTemplatesVariable(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableTemplatesVariable) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayableTemplatesVariablesObject struct {
	ObjectSubtype PayablesVariableType        `json:"object_subtype" url:"object_subtype"`
	ObjectType    ObjectType                  `json:"object_type" url:"object_type"`
	Variables     []*PayableTemplatesVariable `json:"variables" url:"variables"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableTemplatesVariablesObject) GetObjectSubtype() PayablesVariableType {
	if p == nil {
		return ""
	}
	return p.ObjectSubtype
}

func (p *PayableTemplatesVariablesObject) GetObjectType() ObjectType {
	if p == nil {
		return ""
	}
	return p.ObjectType
}

func (p *PayableTemplatesVariablesObject) GetVariables() []*PayableTemplatesVariable {
	if p == nil {
		return nil
	}
	return p.Variables
}

func (p *PayableTemplatesVariablesObject) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableTemplatesVariablesObject) UnmarshalJSON(data []byte) error {
	type unmarshaler PayableTemplatesVariablesObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayableTemplatesVariablesObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableTemplatesVariablesObject) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayableTemplatesVariablesObjectList struct {
	Data []*PayableTemplatesVariablesObject `json:"data" url:"data"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableTemplatesVariablesObjectList) GetData() []*PayableTemplatesVariablesObject {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PayableTemplatesVariablesObjectList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableTemplatesVariablesObjectList) UnmarshalJSON(data []byte) error {
	type unmarshaler PayableTemplatesVariablesObjectList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayableTemplatesVariablesObjectList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableTemplatesVariablesObjectList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayableValidationResponse struct {
	// A unique ID assigned to this payable.
	Id               string                   `json:"id" url:"id"`
	ValidationErrors []map[string]interface{} `json:"validation_errors,omitempty" url:"validation_errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableValidationResponse) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PayableValidationResponse) GetValidationErrors() []map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.ValidationErrors
}

func (p *PayableValidationResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableValidationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PayableValidationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayableValidationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableValidationResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayableValidationsResource struct {
	RequiredFields []PayablesFieldsAllowedForValidate `json:"required_fields" url:"required_fields"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableValidationsResource) GetRequiredFields() []PayablesFieldsAllowedForValidate {
	if p == nil {
		return nil
	}
	return p.RequiredFields
}

func (p *PayableValidationsResource) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableValidationsResource) UnmarshalJSON(data []byte) error {
	type unmarshaler PayableValidationsResource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayableValidationsResource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableValidationsResource) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayablesFieldsAllowedForValidate string

const (
	PayablesFieldsAllowedForValidateCurrency                     PayablesFieldsAllowedForValidate = "currency"
	PayablesFieldsAllowedForValidateDocumentId                   PayablesFieldsAllowedForValidate = "document_id"
	PayablesFieldsAllowedForValidateDueDate                      PayablesFieldsAllowedForValidate = "due_date"
	PayablesFieldsAllowedForValidateIssuedAt                     PayablesFieldsAllowedForValidate = "issued_at"
	PayablesFieldsAllowedForValidateTaxAmount                    PayablesFieldsAllowedForValidate = "tax_amount"
	PayablesFieldsAllowedForValidateTotalAmount                  PayablesFieldsAllowedForValidate = "total_amount"
	PayablesFieldsAllowedForValidateSubtotal                     PayablesFieldsAllowedForValidate = "subtotal"
	PayablesFieldsAllowedForValidateDescription                  PayablesFieldsAllowedForValidate = "description"
	PayablesFieldsAllowedForValidateSuggestedPaymentTerm         PayablesFieldsAllowedForValidate = "suggested_payment_term"
	PayablesFieldsAllowedForValidatePaymentTerms                 PayablesFieldsAllowedForValidate = "payment_terms"
	PayablesFieldsAllowedForValidateTax                          PayablesFieldsAllowedForValidate = "tax"
	PayablesFieldsAllowedForValidateSender                       PayablesFieldsAllowedForValidate = "sender"
	PayablesFieldsAllowedForValidateFileId                       PayablesFieldsAllowedForValidate = "file_id"
	PayablesFieldsAllowedForValidateCounterpartId                PayablesFieldsAllowedForValidate = "counterpart_id"
	PayablesFieldsAllowedForValidateCounterpartBankAccountId     PayablesFieldsAllowedForValidate = "counterpart_bank_account_id"
	PayablesFieldsAllowedForValidateCounterpartAddressId         PayablesFieldsAllowedForValidate = "counterpart_address_id"
	PayablesFieldsAllowedForValidateCounterpartVatIdId           PayablesFieldsAllowedForValidate = "counterpart_vat_id_id"
	PayablesFieldsAllowedForValidateLineItems                    PayablesFieldsAllowedForValidate = "line_items"
	PayablesFieldsAllowedForValidateLineItemsQuantity            PayablesFieldsAllowedForValidate = "line_items.quantity"
	PayablesFieldsAllowedForValidateLineItemsUnitPrice           PayablesFieldsAllowedForValidate = "line_items.unit_price"
	PayablesFieldsAllowedForValidateLineItemsTax                 PayablesFieldsAllowedForValidate = "line_items.tax"
	PayablesFieldsAllowedForValidateLineItemsLedgerAccountId     PayablesFieldsAllowedForValidate = "line_items.ledger_account_id"
	PayablesFieldsAllowedForValidateLineItemsAccountingTaxRateId PayablesFieldsAllowedForValidate = "line_items.accounting_tax_rate_id"
	PayablesFieldsAllowedForValidateLineItemsUnit                PayablesFieldsAllowedForValidate = "line_items.unit"
	PayablesFieldsAllowedForValidateLineItemsName                PayablesFieldsAllowedForValidate = "line_items.name"
	PayablesFieldsAllowedForValidateLineItemsDescription         PayablesFieldsAllowedForValidate = "line_items.description"
	PayablesFieldsAllowedForValidateLineItemsSubtotal            PayablesFieldsAllowedForValidate = "line_items.subtotal"
	PayablesFieldsAllowedForValidateLineItemsTotal               PayablesFieldsAllowedForValidate = "line_items.total"
	PayablesFieldsAllowedForValidateLineItemsTaxAmount           PayablesFieldsAllowedForValidate = "line_items.tax_amount"
)

func NewPayablesFieldsAllowedForValidateFromString(s string) (PayablesFieldsAllowedForValidate, error) {
	switch s {
	case "currency":
		return PayablesFieldsAllowedForValidateCurrency, nil
	case "document_id":
		return PayablesFieldsAllowedForValidateDocumentId, nil
	case "due_date":
		return PayablesFieldsAllowedForValidateDueDate, nil
	case "issued_at":
		return PayablesFieldsAllowedForValidateIssuedAt, nil
	case "tax_amount":
		return PayablesFieldsAllowedForValidateTaxAmount, nil
	case "total_amount":
		return PayablesFieldsAllowedForValidateTotalAmount, nil
	case "subtotal":
		return PayablesFieldsAllowedForValidateSubtotal, nil
	case "description":
		return PayablesFieldsAllowedForValidateDescription, nil
	case "suggested_payment_term":
		return PayablesFieldsAllowedForValidateSuggestedPaymentTerm, nil
	case "payment_terms":
		return PayablesFieldsAllowedForValidatePaymentTerms, nil
	case "tax":
		return PayablesFieldsAllowedForValidateTax, nil
	case "sender":
		return PayablesFieldsAllowedForValidateSender, nil
	case "file_id":
		return PayablesFieldsAllowedForValidateFileId, nil
	case "counterpart_id":
		return PayablesFieldsAllowedForValidateCounterpartId, nil
	case "counterpart_bank_account_id":
		return PayablesFieldsAllowedForValidateCounterpartBankAccountId, nil
	case "counterpart_address_id":
		return PayablesFieldsAllowedForValidateCounterpartAddressId, nil
	case "counterpart_vat_id_id":
		return PayablesFieldsAllowedForValidateCounterpartVatIdId, nil
	case "line_items":
		return PayablesFieldsAllowedForValidateLineItems, nil
	case "line_items.quantity":
		return PayablesFieldsAllowedForValidateLineItemsQuantity, nil
	case "line_items.unit_price":
		return PayablesFieldsAllowedForValidateLineItemsUnitPrice, nil
	case "line_items.tax":
		return PayablesFieldsAllowedForValidateLineItemsTax, nil
	case "line_items.ledger_account_id":
		return PayablesFieldsAllowedForValidateLineItemsLedgerAccountId, nil
	case "line_items.accounting_tax_rate_id":
		return PayablesFieldsAllowedForValidateLineItemsAccountingTaxRateId, nil
	case "line_items.unit":
		return PayablesFieldsAllowedForValidateLineItemsUnit, nil
	case "line_items.name":
		return PayablesFieldsAllowedForValidateLineItemsName, nil
	case "line_items.description":
		return PayablesFieldsAllowedForValidateLineItemsDescription, nil
	case "line_items.subtotal":
		return PayablesFieldsAllowedForValidateLineItemsSubtotal, nil
	case "line_items.total":
		return PayablesFieldsAllowedForValidateLineItemsTotal, nil
	case "line_items.tax_amount":
		return PayablesFieldsAllowedForValidateLineItemsTaxAmount, nil
	}
	var t PayablesFieldsAllowedForValidate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayablesFieldsAllowedForValidate) Ptr() *PayablesFieldsAllowedForValidate {
	return &p
}

type PayablesVariableType string

const (
	PayablesVariableTypePayablesPurchaseOrder  PayablesVariableType = "payables_purchase_order"
	PayablesVariableTypePayablesNotifyApprover PayablesVariableType = "payables_notify_approver"
)

func NewPayablesVariableTypeFromString(s string) (PayablesVariableType, error) {
	switch s {
	case "payables_purchase_order":
		return PayablesVariableTypePayablesPurchaseOrder, nil
	case "payables_notify_approver":
		return PayablesVariableTypePayablesNotifyApprover, nil
	}
	var t PayablesVariableType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayablesVariableType) Ptr() *PayablesVariableType {
	return &p
}

type SourceOfPayableDataEnum string

const (
	SourceOfPayableDataEnumOcr           SourceOfPayableDataEnum = "ocr"
	SourceOfPayableDataEnumUserSpecified SourceOfPayableDataEnum = "user_specified"
)

func NewSourceOfPayableDataEnumFromString(s string) (SourceOfPayableDataEnum, error) {
	switch s {
	case "ocr":
		return SourceOfPayableDataEnumOcr, nil
	case "user_specified":
		return SourceOfPayableDataEnumUserSpecified, nil
	}
	var t SourceOfPayableDataEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceOfPayableDataEnum) Ptr() *SourceOfPayableDataEnum {
	return &s
}

// Suggested payment date and corresponding discount
type SuggestedPaymentTerm struct {
	Date     string `json:"date" url:"date"`
	Discount *int   `json:"discount,omitempty" url:"discount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SuggestedPaymentTerm) GetDate() string {
	if s == nil {
		return ""
	}
	return s.Date
}

func (s *SuggestedPaymentTerm) GetDiscount() *int {
	if s == nil {
		return nil
	}
	return s.Discount
}

func (s *SuggestedPaymentTerm) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SuggestedPaymentTerm) UnmarshalJSON(data []byte) error {
	type unmarshaler SuggestedPaymentTerm
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SuggestedPaymentTerm(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SuggestedPaymentTerm) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type PayableUpdateSchema struct {
	// The ID of counterpart address object stored in counterparts service
	CounterpartAddressId *string `json:"counterpart_address_id,omitempty" url:"-"`
	// The ID of counterpart bank account object stored in counterparts service
	CounterpartBankAccountId *string `json:"counterpart_bank_account_id,omitempty" url:"-"`
	// The ID of the counterpart object that represents the vendor or supplier.
	CounterpartId *string `json:"counterpart_id,omitempty" url:"-"`
	// Allows to fix some data in counterpart recognised fields to correct them in order to make autolinking happen.
	CounterpartRawData *CounterpartRawDataUpdateRequest `json:"counterpart_raw_data,omitempty" url:"-"`
	// The ID of counterpart VAT ID object stored in counterparts service
	CounterpartVatIdId *string `json:"counterpart_vat_id_id,omitempty" url:"-"`
	// The [currency code](https://docs.monite.com/docs/currencies) of the currency used in the payable.
	Currency *CurrencyEnum `json:"currency,omitempty" url:"-"`
	// An arbitrary description of this payable.
	Description *string `json:"description,omitempty" url:"-"`
	// A unique invoice number assigned by the invoice issuer for payment tracking purposes.
	DocumentId *string `json:"document_id,omitempty" url:"-"`
	// The date by which the payable must be paid, in the YYYY-MM-DD format. If the payable specifies payment terms with early payment discounts, this is the final payment date.
	DueDate *string `json:"due_date,omitempty" url:"-"`
	// The date when the payable was issued, in the YYYY-MM-DD format.
	IssuedAt *string `json:"issued_at,omitempty" url:"-"`
	// Metadata for partner needs
	PartnerMetadata map[string]interface{} `json:"partner_metadata,omitempty" url:"-"`
	// The number of days to pay with potential discount for options shorter than due_date
	PaymentTerms *PayablePaymentTermsCreatePayload `json:"payment_terms,omitempty" url:"-"`
	// The project ID of the payable.
	ProjectId *string `json:"project_id,omitempty" url:"-"`
	// The identifier of the purchase order to which this payable belongs.
	PurchaseOrderId *string `json:"purchase_order_id,omitempty" url:"-"`
	// The email address from which the invoice was sent to the entity.
	Sender *string `json:"sender,omitempty" url:"-"`
	// The subtotal amount to be paid, in [minor units](https://docs.monite.com/docs/currencies#minor-units). For example, $12.50 is represented as 1250.
	Subtotal *int `json:"subtotal,omitempty" url:"-"`
	// The suggested date and corresponding discount in which payable could be paid. The date is in the YYYY-MM-DD format. The discount is calculated as X * (10^-4) - for example, 100 is 1%, 25 is 0,25%, 10000 is 100 %. Date varies depending on the payment terms and may even be equal to the due date with discount 0.
	SuggestedPaymentTerm *SuggestedPaymentTerm `json:"suggested_payment_term,omitempty" url:"-"`
	// A list of IDs of user-defined tags (labels) assigned to this payable. Tags can be used to trigger a specific approval policy for this payable.
	TagIds []string `json:"tag_ids,omitempty" url:"-"`
	// Registered tax percentage applied for a service price in minor units, e.g. 200 means 2%, 1050 means 10.5%.
	Tax *int `json:"tax,omitempty" url:"-"`
	// Tax amount in [minor units](https://docs.monite.com/docs/currencies#minor-units). For example, $12.50 is represented as 1250.
	TaxAmount *int `json:"tax_amount,omitempty" url:"-"`
	// The total amount to be paid, in [minor units](https://docs.monite.com/docs/currencies#minor-units). For example, $12.50 is represented as 1250.
	TotalAmount *int `json:"total_amount,omitempty" url:"-"`
}

type PayableValidationsUpdateRequest struct {
	RequiredFields []PayablesFieldsAllowedForValidate `json:"required_fields,omitempty" url:"-"`
}

type PayableUploadFile struct {
	File io.Reader `json:"-" url:"-"`
}
