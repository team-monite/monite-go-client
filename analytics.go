// This file was auto-generated by Fern from our API Definition.

package fluidstack

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/team-monite/monite-go-client/internal"
	time "time"
)

type GetAnalyticsCreditNotesRequest struct {
	Dimension              *CreditNoteDimensionEnum    `json:"-" url:"dimension,omitempty"`
	Metric                 CreditNoteMetricEnum        `json:"-" url:"metric"`
	AggregationFunction    AggregationFunctionEnum     `json:"-" url:"aggregation_function"`
	DateDimensionBreakdown *DateDimensionBreakdownEnum `json:"-" url:"date_dimension_breakdown,omitempty"`
	CreatedAtGt            *time.Time                  `json:"-" url:"created_at__gt,omitempty"`
	CreatedAtLt            *time.Time                  `json:"-" url:"created_at__lt,omitempty"`
	CreatedAtGte           *time.Time                  `json:"-" url:"created_at__gte,omitempty"`
	CreatedAtLte           *time.Time                  `json:"-" url:"created_at__lte,omitempty"`
	IssuedAt               *string                     `json:"-" url:"issued_at,omitempty"`
	IssuedAtGt             *string                     `json:"-" url:"issued_at__gt,omitempty"`
	IssuedAtLt             *string                     `json:"-" url:"issued_at__lt,omitempty"`
	IssuedAtGte            *string                     `json:"-" url:"issued_at__gte,omitempty"`
	IssuedAtLte            *string                     `json:"-" url:"issued_at__lte,omitempty"`
	DocumentId             *string                     `json:"-" url:"document_id,omitempty"`
	DocumentIdIexact       *string                     `json:"-" url:"document_id__iexact,omitempty"`
	DocumentIdContains     *string                     `json:"-" url:"document_id__contains,omitempty"`
	DocumentIdIcontains    *string                     `json:"-" url:"document_id__icontains,omitempty"`
	TotalAmountGt          *int                        `json:"-" url:"total_amount__gt,omitempty"`
	TotalAmountLt          *int                        `json:"-" url:"total_amount__lt,omitempty"`
	TotalAmountGte         *int                        `json:"-" url:"total_amount__gte,omitempty"`
	TotalAmountLte         *int                        `json:"-" url:"total_amount__lte,omitempty"`
	SubtotalGt             *int                        `json:"-" url:"subtotal__gt,omitempty"`
	SubtotalLt             *int                        `json:"-" url:"subtotal__lt,omitempty"`
	SubtotalGte            *int                        `json:"-" url:"subtotal__gte,omitempty"`
	SubtotalLte            *int                        `json:"-" url:"subtotal__lte,omitempty"`
	BasedOn                *string                     `json:"-" url:"based_on,omitempty"`
	CounterpartId          *string                     `json:"-" url:"counterpart_id,omitempty"`
	CreatedByEntityUserId  *string                     `json:"-" url:"created_by_entity_user_id,omitempty"`
	Status                 *CreditNoteStateEnum        `json:"-" url:"status,omitempty"`
	StatusIn               []*CreditNoteStateEnum      `json:"-" url:"status__in,omitempty"`
	StatusNotIn            []*CreditNoteStateEnum      `json:"-" url:"status__not_in,omitempty"`
	Currency               *CurrencyEnum               `json:"-" url:"currency,omitempty"`
}

type GetAnalyticsPayablesRequest struct {
	Dimension              *PayableDimensionEnum       `json:"-" url:"dimension,omitempty"`
	Metric                 PayableMetricEnum           `json:"-" url:"metric"`
	AggregationFunction    AggregationFunctionEnum     `json:"-" url:"aggregation_function"`
	DateDimensionBreakdown *DateDimensionBreakdownEnum `json:"-" url:"date_dimension_breakdown,omitempty"`
	// Return only payables created in Monite after the specified date and time. The value must be in the ISO 8601 format YYYY-MM-DDThh:mm[:ss[.ffffff]][Z|Â±hh:mm].
	CreatedAtGt *time.Time `json:"-" url:"created_at__gt,omitempty"`
	// Return only payables created in Monite before the specified date and time.
	CreatedAtLt *time.Time `json:"-" url:"created_at__lt,omitempty"`
	// Return only payables created in Monite on or after the specified date and time.
	CreatedAtGte *time.Time `json:"-" url:"created_at__gte,omitempty"`
	// Return only payables created in Monite before or on the specified date and time.
	CreatedAtLte *time.Time `json:"-" url:"created_at__lte,omitempty"`
	// Return only payables that have the specified [status](https://docs.monite.com/accounts-payable/payables/index).
	//
	// To query multiple statuses at once, use the `status__in` parameter instead.
	Status *PayableStateEnum `json:"-" url:"status,omitempty"`
	// Return only payables that have the specified [statuses](https://docs.monite.com/accounts-payable/payables/index).
	//
	// To specify multiple statuses, repeat this parameter for each value: `status__in=draft&status__in=new`
	StatusIn []*PayableStateEnum `json:"-" url:"status__in,omitempty"`
	// Return only payables with specified IDs. Valid but nonexistent IDs do not raise errors but produce no results.
	//
	// To specify multiple IDs, repeat this parameter for each value: `id__in=<id1>&id__in=<id2>`
	IdIn []*string `json:"-" url:"id__in,omitempty"`
	// Return only payables with the exact specified total amount. The amount must be specified in the minor units of currency. For example, $12.5 is represented as 1250.
	TotalAmount *int `json:"-" url:"total_amount,omitempty"`
	// Return only payables whose total amount (in minor units) exceeds the specified value.
	TotalAmountGt *int `json:"-" url:"total_amount__gt,omitempty"`
	// Return only payables whose total amount (in minor units) is less than the specified value.
	TotalAmountLt *int `json:"-" url:"total_amount__lt,omitempty"`
	// Return only payables whose total amount (in minor units) is greater than or equal to the specified value.
	TotalAmountGte *int `json:"-" url:"total_amount__gte,omitempty"`
	// Return only payables whose total amount (in minor units) is less than or equal to the specified value.
	TotalAmountLte *int `json:"-" url:"total_amount__lte,omitempty"`
	// Return only payables with the specified amount.
	Amount *int `json:"-" url:"amount,omitempty"`
	// Return only payables whose amount (in minor units) exceeds the specified value.
	AmountGt *int `json:"-" url:"amount__gt,omitempty"`
	// Return only payables whose amount (in minor units) is less than the specified value.
	AmountLt *int `json:"-" url:"amount__lt,omitempty"`
	// Return only payables whose amount (in minor units) is greater than or equal to the specified value.
	AmountGte *int `json:"-" url:"amount__gte,omitempty"`
	// Return only payables whose amount (in minor units) is less than or equal to the specified value.
	AmountLte *int `json:"-" url:"amount__lte,omitempty"`
	// Return only payables that use the specified currency.
	Currency *CurrencyEnum `json:"-" url:"currency,omitempty"`
	// Return only payables received from counterparts with the specified name (exact match, case-sensitive).
	//
	// For counterparts of `type = individual`, the full name is formatted as `first_name last_name`.
	CounterpartName *string `json:"-" url:"counterpart_name,omitempty"`
	// Return only payables received from counterparts whose name contains the specified string (case-sensitive).
	CounterpartNameContains *string `json:"-" url:"counterpart_name__contains,omitempty"`
	// Return only payables received from counterparts whose name contains the specified string (case-insensitive).
	CounterpartNameIcontains *string `json:"-" url:"counterpart_name__icontains,omitempty"`
	// Apply the `icontains` condition to search for the specified text in the `document_id` and `counterpart_name` fields in the payables.
	SearchText *string `json:"-" url:"search_text,omitempty"`
	// Return payables that are due on the specified date (YYYY-MM-DD)
	DueDate *string `json:"-" url:"due_date,omitempty"`
	// Return payables that are due after the specified date (exclusive, YYYY-MM-DD).
	DueDateGt *string `json:"-" url:"due_date__gt,omitempty"`
	// Return payables that are due before the specified date (exclusive, YYYY-MM-DD).
	DueDateLt *string `json:"-" url:"due_date__lt,omitempty"`
	// Return payables that are due on or after the specified date (YYYY-MM-DD).
	DueDateGte *string `json:"-" url:"due_date__gte,omitempty"`
	// Return payables that are due before or on the specified date (YYYY-MM-DD).
	DueDateLte *string `json:"-" url:"due_date__lte,omitempty"`
	// Return a payable with the exact specified document number (case-sensitive).
	//
	// The `document_id` is the user-facing document number such as INV-00042, not to be confused with Monite resource IDs (`id`).
	DocumentId *string `json:"-" url:"document_id,omitempty"`
	// Return only payables whose document number (`document_id`) contains the specified string (case-sensitive).
	DocumentIdContains *string `json:"-" url:"document_id__contains,omitempty"`
	// Return only payables whose document number (`document_id`) contains the specified string (case-insensitive).
	DocumentIdIcontains *string `json:"-" url:"document_id__icontains,omitempty"`
	// Return only payables created in Monite by the entity user with the specified ID.
	WasCreatedByUserId *string `json:"-" url:"was_created_by_user_id,omitempty"`
	// Return only payables received from the counterpart with the specified ID.
	//
	// Counterparts that have been deleted but have associated payables will still return results here because the payables contain a frozen copy of the counterpart data.
	//
	// If the specified counterpart ID does not exist and never existed, no results are returned.
	CounterpartId *string `json:"-" url:"counterpart_id,omitempty"`
	// Return only payables coming from the specified source.
	SourceOfPayableData *SourceOfPayableDataEnum `json:"-" url:"source_of_payable_data,omitempty"`
	// Return only payables with specific OCR statuses.
	OcrStatus *OcrStatusEnum `json:"-" url:"ocr_status,omitempty"`
	// Search for a payable by the identifier of the line item associated with it.
	LineItemId *string `json:"-" url:"line_item_id,omitempty"`
	// Search for a payable by the identifier of the purchase order associated with it.
	PurchaseOrderId *string `json:"-" url:"purchase_order_id,omitempty"`
	// Return only payables assigned to the project with the specified ID.
	//
	// Valid but nonexistent project IDs do not raise errors but return no results.
	ProjectId *string `json:"-" url:"project_id,omitempty"`
	// Return only payables whose `tags` include at least one of the tags with the specified IDs. Valid but nonexistent tag IDs do not raise errors but produce no results.
	TagIds []*string `json:"-" url:"tag_ids,omitempty"`
}

type AggregationFunctionEnum string

const (
	AggregationFunctionEnumCount   AggregationFunctionEnum = "count"
	AggregationFunctionEnumAverage AggregationFunctionEnum = "average"
	AggregationFunctionEnumSummary AggregationFunctionEnum = "summary"
	AggregationFunctionEnumMin     AggregationFunctionEnum = "min"
	AggregationFunctionEnumMax     AggregationFunctionEnum = "max"
)

func NewAggregationFunctionEnumFromString(s string) (AggregationFunctionEnum, error) {
	switch s {
	case "count":
		return AggregationFunctionEnumCount, nil
	case "average":
		return AggregationFunctionEnumAverage, nil
	case "summary":
		return AggregationFunctionEnumSummary, nil
	case "min":
		return AggregationFunctionEnumMin, nil
	case "max":
		return AggregationFunctionEnumMax, nil
	}
	var t AggregationFunctionEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AggregationFunctionEnum) Ptr() *AggregationFunctionEnum {
	return &a
}

type AnalyticsDataPoint struct {
	DimensionValue *string `json:"dimension_value,omitempty" url:"dimension_value,omitempty"`
	MetricValue    int     `json:"metric_value" url:"metric_value"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnalyticsDataPoint) GetDimensionValue() *string {
	if a == nil {
		return nil
	}
	return a.DimensionValue
}

func (a *AnalyticsDataPoint) GetMetricValue() int {
	if a == nil {
		return 0
	}
	return a.MetricValue
}

func (a *AnalyticsDataPoint) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnalyticsDataPoint) UnmarshalJSON(data []byte) error {
	type unmarshaler AnalyticsDataPoint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AnalyticsDataPoint(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnalyticsDataPoint) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type CreditNoteDimensionEnum string

const (
	CreditNoteDimensionEnumCreatedAt     CreditNoteDimensionEnum = "created_at"
	CreditNoteDimensionEnumStatus        CreditNoteDimensionEnum = "status"
	CreditNoteDimensionEnumCounterpartId CreditNoteDimensionEnum = "counterpart_id"
	CreditNoteDimensionEnumCurrency      CreditNoteDimensionEnum = "currency"
	CreditNoteDimensionEnumIssuedAt      CreditNoteDimensionEnum = "issued_at"
	CreditNoteDimensionEnumProjectId     CreditNoteDimensionEnum = "project_id"
)

func NewCreditNoteDimensionEnumFromString(s string) (CreditNoteDimensionEnum, error) {
	switch s {
	case "created_at":
		return CreditNoteDimensionEnumCreatedAt, nil
	case "status":
		return CreditNoteDimensionEnumStatus, nil
	case "counterpart_id":
		return CreditNoteDimensionEnumCounterpartId, nil
	case "currency":
		return CreditNoteDimensionEnumCurrency, nil
	case "issued_at":
		return CreditNoteDimensionEnumIssuedAt, nil
	case "project_id":
		return CreditNoteDimensionEnumProjectId, nil
	}
	var t CreditNoteDimensionEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreditNoteDimensionEnum) Ptr() *CreditNoteDimensionEnum {
	return &c
}

type CreditNoteMetricEnum string

const (
	CreditNoteMetricEnumId          CreditNoteMetricEnum = "id"
	CreditNoteMetricEnumTotalAmount CreditNoteMetricEnum = "total_amount"
)

func NewCreditNoteMetricEnumFromString(s string) (CreditNoteMetricEnum, error) {
	switch s {
	case "id":
		return CreditNoteMetricEnumId, nil
	case "total_amount":
		return CreditNoteMetricEnumTotalAmount, nil
	}
	var t CreditNoteMetricEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreditNoteMetricEnum) Ptr() *CreditNoteMetricEnum {
	return &c
}

type DateDimensionBreakdownEnum string

const (
	DateDimensionBreakdownEnumDaily     DateDimensionBreakdownEnum = "daily"
	DateDimensionBreakdownEnumWeekly    DateDimensionBreakdownEnum = "weekly"
	DateDimensionBreakdownEnumMonthly   DateDimensionBreakdownEnum = "monthly"
	DateDimensionBreakdownEnumQuarterly DateDimensionBreakdownEnum = "quarterly"
	DateDimensionBreakdownEnumYearly    DateDimensionBreakdownEnum = "yearly"
)

func NewDateDimensionBreakdownEnumFromString(s string) (DateDimensionBreakdownEnum, error) {
	switch s {
	case "daily":
		return DateDimensionBreakdownEnumDaily, nil
	case "weekly":
		return DateDimensionBreakdownEnumWeekly, nil
	case "monthly":
		return DateDimensionBreakdownEnumMonthly, nil
	case "quarterly":
		return DateDimensionBreakdownEnumQuarterly, nil
	case "yearly":
		return DateDimensionBreakdownEnumYearly, nil
	}
	var t DateDimensionBreakdownEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DateDimensionBreakdownEnum) Ptr() *DateDimensionBreakdownEnum {
	return &d
}

type PayableAnalyticsResponse struct {
	Data []*AnalyticsDataPoint `json:"data" url:"data"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayableAnalyticsResponse) GetData() []*AnalyticsDataPoint {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PayableAnalyticsResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayableAnalyticsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PayableAnalyticsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayableAnalyticsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayableAnalyticsResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayableDimensionEnum string

const (
	PayableDimensionEnumCreatedAt     PayableDimensionEnum = "created_at"
	PayableDimensionEnumStatus        PayableDimensionEnum = "status"
	PayableDimensionEnumCounterpartId PayableDimensionEnum = "counterpart_id"
	PayableDimensionEnumCurrency      PayableDimensionEnum = "currency"
	PayableDimensionEnumIssuedAt      PayableDimensionEnum = "issued_at"
	PayableDimensionEnumDueDate       PayableDimensionEnum = "due_date"
	PayableDimensionEnumProjectId     PayableDimensionEnum = "project_id"
)

func NewPayableDimensionEnumFromString(s string) (PayableDimensionEnum, error) {
	switch s {
	case "created_at":
		return PayableDimensionEnumCreatedAt, nil
	case "status":
		return PayableDimensionEnumStatus, nil
	case "counterpart_id":
		return PayableDimensionEnumCounterpartId, nil
	case "currency":
		return PayableDimensionEnumCurrency, nil
	case "issued_at":
		return PayableDimensionEnumIssuedAt, nil
	case "due_date":
		return PayableDimensionEnumDueDate, nil
	case "project_id":
		return PayableDimensionEnumProjectId, nil
	}
	var t PayableDimensionEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayableDimensionEnum) Ptr() *PayableDimensionEnum {
	return &p
}

type PayableMetricEnum string

const (
	PayableMetricEnumId          PayableMetricEnum = "id"
	PayableMetricEnumTotalAmount PayableMetricEnum = "total_amount"
)

func NewPayableMetricEnumFromString(s string) (PayableMetricEnum, error) {
	switch s {
	case "id":
		return PayableMetricEnumId, nil
	case "total_amount":
		return PayableMetricEnumTotalAmount, nil
	}
	var t PayableMetricEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayableMetricEnum) Ptr() *PayableMetricEnum {
	return &p
}
